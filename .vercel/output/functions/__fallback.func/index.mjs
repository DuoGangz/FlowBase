import process from 'node:process';globalThis._importMeta_={url:import.meta.url,env:process.env};import { promises, existsSync } from 'node:fs';
import path$3, { resolve as resolve$1, dirname, join } from 'node:path';
import { put, del } from '@vercel/blob';
import { createHead as createHead$1, propsToString, renderSSRHead } from 'unhead/server';
import { stringify as stringify$1, uneval } from 'devalue';
import * as compilerDom from '@vue/compiler-dom';
import * as runtimeDom from '@vue/runtime-dom';
import http$1 from 'node:http';
import https$1 from 'node:https';
import * as node_events from 'node:events';
import { EventEmitter } from 'node:events';
import { Buffer as Buffer$1 } from 'node:buffer';
import { createHash } from 'node:crypto';
import * as fs$1 from 'fs';
import * as url$1 from 'url';
import * as os$1 from 'os';
import * as path$1 from 'path';
import * as http from 'http';
import * as https from 'https';
import * as http2 from 'http2';
import * as events from 'events';
import * as node_stream from 'node:stream';
import * as node_util from 'node:util';
import * as zlib from 'zlib';
import * as jsonwebtoken from 'jsonwebtoken';
import * as nodeForge from 'node-forge';
import * as crypto from 'crypto';
import * as jwksRsa from 'jwks-rsa';
import * as standalone from '@firebase/database-compat/standalone';
import * as firestore$1 from '@google-cloud/firestore';
import * as farmhashModern from 'farmhash-modern';
import * as path$2 from '@google-cloud/firestore/build/src/path';

const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode$1(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode$1(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode$1(text.replace(PLUS_RE, " "));
}

function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return input.endsWith("/");
  }
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return input.endsWith("/") ? input : input + "/";
  }
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withoutBase(input, base) {
  if (isEmptyURL(base)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (!input.startsWith(_base)) {
    return input;
  }
  const trimmed = input.slice(_base.length);
  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function getQuery$1(input) {
  return parseQuery(parseURL(input).search);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
function joinRelativeURL(..._input) {
  const JOIN_SEGMENT_SPLIT_RE = /\/(?!\/)/;
  const input = _input.filter(Boolean);
  const segments = [];
  let segmentsDepth = 0;
  for (const i of input) {
    if (!i || i === "/") {
      continue;
    }
    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {
      if (!s || s === ".") {
        continue;
      }
      if (s === "..") {
        if (segments.length === 1 && hasProtocol(segments[0])) {
          continue;
        }
        segments.pop();
        segmentsDepth--;
        continue;
      }
      if (sindex === 1 && segments[segments.length - 1]?.endsWith(":/")) {
        segments[segments.length - 1] += "/" + s;
        continue;
      }
      segments.push(s);
      segmentsDepth++;
    }
  }
  let url = segments.join("/");
  if (segmentsDepth >= 0) {
    if (input[0]?.startsWith("/") && !url.startsWith("/")) {
      url = "/" + url;
    } else if (input[0]?.startsWith("./") && !url.startsWith("./")) {
      url = "./" + url;
    }
  } else {
    url = "../".repeat(-1 * segmentsDepth) + url;
  }
  if (input[input.length - 1]?.endsWith("/") && !url.endsWith("/")) {
    url += "/";
  }
  return url;
}

const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

function parse$1(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  const obj = {};
  const opt = {};
  const dec = opt.decode || decode;
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (opt?.filter && !opt?.filter(key)) {
      index = endIdx + 1;
      continue;
    }
    if (void 0 === obj[key]) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function decode(str) {
  return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch {
    return str;
  }
}

const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize$1(name, value, options) {
  const opt = options || {};
  const enc = opt.encode || encodeURIComponent;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  const encodedValue = enc(value);
  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + encodedValue;
  if (void 0 !== opt.maxAge && opt.maxAge !== null) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (!isDate$1(opt.expires) || Number.isNaN(opt.expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low": {
        str += "; Priority=Low";
        break;
      }
      case "medium": {
        str += "; Priority=Medium";
        break;
      }
      case "high": {
        str += "; Priority=High";
        break;
      }
      default: {
        throw new TypeError("option priority is invalid");
      }
    }
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true: {
        str += "; SameSite=Strict";
        break;
      }
      case "lax": {
        str += "; SameSite=Lax";
        break;
      }
      case "strict": {
        str += "; SameSite=Strict";
        break;
      }
      case "none": {
        str += "; SameSite=None";
        break;
      }
      default: {
        throw new TypeError("option sameSite is invalid");
      }
    }
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  return str;
}
function isDate$1(val) {
  return Object.prototype.toString.call(val) === "[object Date]" || val instanceof Date;
}

function parseSetCookie(setCookieValue, options) {
  const parts = (setCookieValue || "").split(";").filter((str) => typeof str === "string" && !!str.trim());
  const nameValuePairStr = parts.shift() || "";
  const parsed = _parseNameValuePair(nameValuePairStr);
  const name = parsed.name;
  let value = parsed.value;
  try {
    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);
  } catch {
  }
  const cookie = {
    name,
    value
  };
  for (const part of parts) {
    const sides = part.split("=");
    const partKey = (sides.shift() || "").trimStart().toLowerCase();
    const partValue = sides.join("=");
    switch (partKey) {
      case "expires": {
        cookie.expires = new Date(partValue);
        break;
      }
      case "max-age": {
        cookie.maxAge = Number.parseInt(partValue, 10);
        break;
      }
      case "secure": {
        cookie.secure = true;
        break;
      }
      case "httponly": {
        cookie.httpOnly = true;
        break;
      }
      case "samesite": {
        cookie.sameSite = partValue;
        break;
      }
      default: {
        cookie[partKey] = partValue;
      }
    }
  }
  return cookie;
}
function _parseNameValuePair(nameValuePairStr) {
  let name = "";
  let value = "";
  const nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name, value };
}

const NODE_TYPES = {
  NORMAL: 0,
  WILDCARD: 1,
  PLACEHOLDER: 2
};

function createRouter$1(options = {}) {
  const ctx = {
    options,
    rootNode: createRadixNode(),
    staticRoutesMap: {}
  };
  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\/$/, "") || "/";
  if (options.routes) {
    for (const path in options.routes) {
      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);
    }
  }
  return {
    ctx,
    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),
    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),
    remove: (path) => remove$1(ctx, normalizeTrailingSlash(path))
  };
}
function lookup(ctx, path) {
  const staticPathNode = ctx.staticRoutesMap[path];
  if (staticPathNode) {
    return staticPathNode.data;
  }
  const sections = path.split("/");
  const params = {};
  let paramsFound = false;
  let wildcardNode = null;
  let node = ctx.rootNode;
  let wildCardParam = null;
  for (let i = 0; i < sections.length; i++) {
    const section = sections[i];
    if (node.wildcardChildNode !== null) {
      wildcardNode = node.wildcardChildNode;
      wildCardParam = sections.slice(i).join("/");
    }
    const nextNode = node.children.get(section);
    if (nextNode === void 0) {
      if (node && node.placeholderChildren.length > 1) {
        const remaining = sections.length - i;
        node = node.placeholderChildren.find((c) => c.maxDepth === remaining) || null;
      } else {
        node = node.placeholderChildren[0] || null;
      }
      if (!node) {
        break;
      }
      if (node.paramName) {
        params[node.paramName] = section;
      }
      paramsFound = true;
    } else {
      node = nextNode;
    }
  }
  if ((node === null || node.data === null) && wildcardNode !== null) {
    node = wildcardNode;
    params[node.paramName || "_"] = wildCardParam;
    paramsFound = true;
  }
  if (!node) {
    return null;
  }
  if (paramsFound) {
    return {
      ...node.data,
      params: paramsFound ? params : void 0
    };
  }
  return node.data;
}
function insert(ctx, path, data) {
  let isStaticRoute = true;
  const sections = path.split("/");
  let node = ctx.rootNode;
  let _unnamedPlaceholderCtr = 0;
  const matchedNodes = [node];
  for (const section of sections) {
    let childNode;
    if (childNode = node.children.get(section)) {
      node = childNode;
    } else {
      const type = getNodeType(section);
      childNode = createRadixNode({ type, parent: node });
      node.children.set(section, childNode);
      if (type === NODE_TYPES.PLACEHOLDER) {
        childNode.paramName = section === "*" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);
        node.placeholderChildren.push(childNode);
        isStaticRoute = false;
      } else if (type === NODE_TYPES.WILDCARD) {
        node.wildcardChildNode = childNode;
        childNode.paramName = section.slice(
          3
          /* "**:" */
        ) || "_";
        isStaticRoute = false;
      }
      matchedNodes.push(childNode);
      node = childNode;
    }
  }
  for (const [depth, node2] of matchedNodes.entries()) {
    node2.maxDepth = Math.max(matchedNodes.length - depth, node2.maxDepth || 0);
  }
  node.data = data;
  if (isStaticRoute === true) {
    ctx.staticRoutesMap[path] = node;
  }
  return node;
}
function remove$1(ctx, path) {
  let success = false;
  const sections = path.split("/");
  let node = ctx.rootNode;
  for (const section of sections) {
    node = node.children.get(section);
    if (!node) {
      return success;
    }
  }
  if (node.data) {
    const lastSection = sections.at(-1) || "";
    node.data = null;
    if (Object.keys(node.children).length === 0 && node.parent) {
      node.parent.children.delete(lastSection);
      node.parent.wildcardChildNode = null;
      node.parent.placeholderChildren = [];
    }
    success = true;
  }
  return success;
}
function createRadixNode(options = {}) {
  return {
    type: options.type || NODE_TYPES.NORMAL,
    maxDepth: 0,
    parent: options.parent || null,
    children: /* @__PURE__ */ new Map(),
    data: options.data || null,
    paramName: options.paramName || null,
    wildcardChildNode: null,
    placeholderChildren: []
  };
}
function getNodeType(str) {
  if (str.startsWith("**")) {
    return NODE_TYPES.WILDCARD;
  }
  if (str[0] === ":" || str === "*") {
    return NODE_TYPES.PLACEHOLDER;
  }
  return NODE_TYPES.NORMAL;
}

function toRouteMatcher(router) {
  const table = _routerNodeToTable("", router.ctx.rootNode);
  return _createMatcher(table, router.ctx.options.strictTrailingSlash);
}
function _createMatcher(table, strictTrailingSlash) {
  return {
    ctx: { table },
    matchAll: (path) => _matchRoutes(path, table, strictTrailingSlash)
  };
}
function _createRouteTable() {
  return {
    static: /* @__PURE__ */ new Map(),
    wildcard: /* @__PURE__ */ new Map(),
    dynamic: /* @__PURE__ */ new Map()
  };
}
function _matchRoutes(path, table, strictTrailingSlash) {
  if (strictTrailingSlash !== true && path.endsWith("/")) {
    path = path.slice(0, -1) || "/";
  }
  const matches = [];
  for (const [key, value] of _sortRoutesMap(table.wildcard)) {
    if (path === key || path.startsWith(key + "/")) {
      matches.push(value);
    }
  }
  for (const [key, value] of _sortRoutesMap(table.dynamic)) {
    if (path.startsWith(key + "/")) {
      const subPath = "/" + path.slice(key.length).split("/").splice(2).join("/");
      matches.push(..._matchRoutes(subPath, value));
    }
  }
  const staticMatch = table.static.get(path);
  if (staticMatch) {
    matches.push(staticMatch);
  }
  return matches.filter(Boolean);
}
function _sortRoutesMap(m) {
  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);
}
function _routerNodeToTable(initialPath, initialNode) {
  const table = _createRouteTable();
  function _addNode(path, node) {
    if (path) {
      if (node.type === NODE_TYPES.NORMAL && !(path.includes("*") || path.includes(":"))) {
        if (node.data) {
          table.static.set(path, node.data);
        }
      } else if (node.type === NODE_TYPES.WILDCARD) {
        table.wildcard.set(path.replace("/**", ""), node.data);
      } else if (node.type === NODE_TYPES.PLACEHOLDER) {
        const subTable = _routerNodeToTable("", node);
        if (node.data) {
          subTable.static.set("/", node.data);
        }
        table.dynamic.set(path.replace(/\/\*|\/:\w+/, ""), subTable);
        return;
      }
    }
    for (const [childPath, child] of node.children.entries()) {
      _addNode(`${path}/${childPath}`.replace("//", "/"), child);
    }
  }
  _addNode(initialPath, initialNode);
  return table;
}

function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();
const defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

function o(n){throw new Error(`${n} is not implemented yet!`)}let i$1 = class i extends EventEmitter{__unenv__={};readableEncoding=null;readableEnded=true;readableFlowing=false;readableHighWaterMark=0;readableLength=0;readableObjectMode=false;readableAborted=false;readableDidRead=false;closed=false;errored=null;readable=false;destroyed=false;static from(e,t){return new i(t)}constructor(e){super();}_read(e){}read(e){}setEncoding(e){return this}pause(){return this}resume(){return this}isPaused(){return  true}unpipe(e){return this}unshift(e,t){}wrap(e){return this}push(e,t){return  false}_destroy(e,t){this.removeAllListeners();}destroy(e){return this.destroyed=true,this._destroy(e),this}pipe(e,t){return {}}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return this.destroy(),Promise.resolve()}async*[Symbol.asyncIterator](){throw o("Readable.asyncIterator")}iterator(e){throw o("Readable.iterator")}map(e,t){throw o("Readable.map")}filter(e,t){throw o("Readable.filter")}forEach(e,t){throw o("Readable.forEach")}reduce(e,t,r){throw o("Readable.reduce")}find(e,t){throw o("Readable.find")}findIndex(e,t){throw o("Readable.findIndex")}some(e,t){throw o("Readable.some")}toArray(e){throw o("Readable.toArray")}every(e,t){throw o("Readable.every")}flatMap(e,t){throw o("Readable.flatMap")}drop(e,t){throw o("Readable.drop")}take(e,t){throw o("Readable.take")}asIndexedPairs(e){throw o("Readable.asIndexedPairs")}};let l$1 = class l extends EventEmitter{__unenv__={};writable=true;writableEnded=false;writableFinished=false;writableHighWaterMark=0;writableLength=0;writableObjectMode=false;writableCorked=0;closed=false;errored=null;writableNeedDrain=false;writableAborted=false;destroyed=false;_data;_encoding="utf8";constructor(e){super();}pipe(e,t){return {}}_write(e,t,r){if(this.writableEnded){r&&r();return}if(this._data===void 0)this._data=e;else {const s=typeof this._data=="string"?Buffer$1.from(this._data,this._encoding||t||"utf8"):this._data,a=typeof e=="string"?Buffer$1.from(e,t||this._encoding||"utf8"):e;this._data=Buffer$1.concat([s,a]);}this._encoding=t,r&&r();}_writev(e,t){}_destroy(e,t){}_final(e){}write(e,t,r){const s=typeof t=="string"?this._encoding:"utf8",a=typeof t=="function"?t:typeof r=="function"?r:void 0;return this._write(e,s,a),true}setDefaultEncoding(e){return this}end(e,t,r){const s=typeof e=="function"?e:typeof t=="function"?t:typeof r=="function"?r:void 0;if(this.writableEnded)return s&&s(),this;const a=e===s?void 0:e;if(a){const u=t===s?void 0:t;this.write(a,u,s);}return this.writableEnded=true,this.writableFinished=true,this.emit("close"),this.emit("finish"),this}cork(){}uncork(){}destroy(e){return this.destroyed=true,delete this._data,this.removeAllListeners(),this}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return Promise.resolve()}};const c=class{allowHalfOpen=true;_destroy;constructor(e=new i$1,t=new l$1){Object.assign(this,e),Object.assign(this,t),this._destroy=m(e._destroy,t._destroy);}};function _(){return Object.assign(c.prototype,i$1.prototype),Object.assign(c.prototype,l$1.prototype),c}function m(...n){return function(...e){for(const t of n)t(...e);}}const g=_();class A extends g{__unenv__={};bufferSize=0;bytesRead=0;bytesWritten=0;connecting=false;destroyed=false;pending=false;localAddress="";localPort=0;remoteAddress="";remoteFamily="";remotePort=0;autoSelectFamilyAttemptedAddresses=[];readyState="readOnly";constructor(e){super();}write(e,t,r){return  false}connect(e,t,r){return this}end(e,t,r){return this}setEncoding(e){return this}pause(){return this}resume(){return this}setTimeout(e,t){return this}setNoDelay(e){return this}setKeepAlive(e,t){return this}address(){return {}}unref(){return this}ref(){return this}destroySoon(){this.destroy();}resetAndDestroy(){const e=new Error("ERR_SOCKET_CLOSED");return e.code="ERR_SOCKET_CLOSED",this.destroy(e),this}}class y extends i$1{aborted=false;httpVersion="1.1";httpVersionMajor=1;httpVersionMinor=1;complete=true;connection;socket;headers={};trailers={};method="GET";url="/";statusCode=200;statusMessage="";closed=false;errored=null;readable=false;constructor(e){super(),this.socket=this.connection=e||new A;}get rawHeaders(){const e=this.headers,t=[];for(const r in e)if(Array.isArray(e[r]))for(const s of e[r])t.push(r,s);else t.push(r,e[r]);return t}get rawTrailers(){return []}setTimeout(e,t){return this}get headersDistinct(){return p(this.headers)}get trailersDistinct(){return p(this.trailers)}}function p(n){const e={};for(const[t,r]of Object.entries(n))t&&(e[t]=(Array.isArray(r)?r:[r]).filter(Boolean));return e}class w extends l$1{statusCode=200;statusMessage="";upgrading=false;chunkedEncoding=false;shouldKeepAlive=false;useChunkedEncodingByDefault=false;sendDate=false;finished=false;headersSent=false;strictContentLength=false;connection=null;socket=null;req;_headers={};constructor(e){super(),this.req=e;}assignSocket(e){e._httpMessage=this,this.socket=e,this.connection=e,this.emit("socket",e),this._flush();}_flush(){this.flushHeaders();}detachSocket(e){}writeContinue(e){}writeHead(e,t,r){e&&(this.statusCode=e),typeof t=="string"&&(this.statusMessage=t,t=void 0);const s=r||t;if(s&&!Array.isArray(s))for(const a in s)this.setHeader(a,s[a]);return this.headersSent=true,this}writeProcessing(){}setTimeout(e,t){return this}appendHeader(e,t){e=e.toLowerCase();const r=this._headers[e],s=[...Array.isArray(r)?r:[r],...Array.isArray(t)?t:[t]].filter(Boolean);return this._headers[e]=s.length>1?s:s[0],this}setHeader(e,t){return this._headers[e.toLowerCase()]=t,this}setHeaders(e){for(const[t,r]of Object.entries(e))this.setHeader(t,r);return this}getHeader(e){return this._headers[e.toLowerCase()]}getHeaders(){return this._headers}getHeaderNames(){return Object.keys(this._headers)}hasHeader(e){return e.toLowerCase()in this._headers}removeHeader(e){delete this._headers[e.toLowerCase()];}addTrailers(e){}flushHeaders(){}writeEarlyHints(e,t){typeof t=="function"&&t();}}const E=(()=>{const n=function(){};return n.prototype=Object.create(null),n})();function R(n={}){const e=new E,t=Array.isArray(n)||H(n)?n:Object.entries(n);for(const[r,s]of t)if(s){if(e[r]===void 0){e[r]=s;continue}e[r]=[...Array.isArray(e[r])?e[r]:[e[r]],...Array.isArray(s)?s:[s]];}return e}function H(n){return typeof n?.entries=="function"}function v(n={}){if(n instanceof Headers)return n;const e=new Headers;for(const[t,r]of Object.entries(n))if(r!==void 0){if(Array.isArray(r)){for(const s of r)e.append(t,String(s));continue}e.set(t,String(r));}return e}const S=new Set([101,204,205,304]);async function b(n,e){const t=new y,r=new w(t);t.url=e.url?.toString()||"/";let s;if(!t.url.startsWith("/")){const d=new URL(t.url);s=d.host,t.url=d.pathname+d.search+d.hash;}t.method=e.method||"GET",t.headers=R(e.headers||{}),t.headers.host||(t.headers.host=e.host||s||"localhost"),t.connection.encrypted=t.connection.encrypted||e.protocol==="https",t.body=e.body||null,t.__unenv__=e.context,await n(t,r);let a=r._data;(S.has(r.statusCode)||t.method.toUpperCase()==="HEAD")&&(a=null,delete r._headers["content-length"]);const u={status:r.statusCode,statusText:r.statusMessage,headers:r._headers,body:a};return t.destroy(),r.destroy(),u}async function C(n,e,t={}){try{const r=await b(n,{url:e,...t});return new Response(r.body,{status:r.status,statusText:r.statusText,headers:v(r.headers)})}catch(r){return new Response(r.toString(),{status:Number.parseInt(r.statusCode||r.code)||500,statusText:r.statusText})}}

function hasProp(obj, prop) {
  try {
    return prop in obj;
  } catch {
    return false;
  }
}

class H3Error extends Error {
  static __h3_error__ = true;
  statusCode = 500;
  fatal = false;
  unhandled = false;
  statusMessage;
  data;
  cause;
  constructor(message, opts = {}) {
    super(message, opts);
    if (opts.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
  toJSON() {
    const obj = {
      message: this.message,
      statusCode: sanitizeStatusCode(this.statusCode, 500)
    };
    if (this.statusMessage) {
      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
    }
    if (this.data !== void 0) {
      obj.data = this.data;
    }
    return obj;
  }
}
function createError$1(input) {
  if (typeof input === "string") {
    return new H3Error(input);
  }
  if (isError(input)) {
    return input;
  }
  const err = new H3Error(input.message ?? input.statusMessage ?? "", {
    cause: input.cause || input
  });
  if (hasProp(input, "stack")) {
    try {
      Object.defineProperty(err, "stack", {
        get() {
          return input.stack;
        }
      });
    } catch {
      try {
        err.stack = input.stack;
      } catch {
      }
    }
  }
  if (input.data) {
    err.data = input.data;
  }
  if (input.statusCode) {
    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
  } else if (input.status) {
    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  } else if (input.statusText) {
    err.statusMessage = input.statusText;
  }
  if (err.statusMessage) {
    const originalMessage = err.statusMessage;
    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);
    if (sanitizedMessage !== originalMessage) {
      console.warn(
        "[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default."
      );
    }
  }
  if (input.fatal !== void 0) {
    err.fatal = input.fatal;
  }
  if (input.unhandled !== void 0) {
    err.unhandled = input.unhandled;
  }
  return err;
}
function sendError(event, error, debug) {
  if (event.handled) {
    return;
  }
  const h3Error = isError(error) ? error : createError$1(error);
  const responseBody = {
    statusCode: h3Error.statusCode,
    statusMessage: h3Error.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
  }
  if (event.handled) {
    return;
  }
  const _code = Number.parseInt(h3Error.statusCode);
  setResponseStatus(event, _code, h3Error.statusMessage);
  event.node.res.setHeader("content-type", MIMES.json);
  event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError(input) {
  return input?.constructor?.__h3_error__ === true;
}

function parse(multipartBodyBuffer, boundary) {
  let lastline = "";
  let state = 0 /* INIT */;
  let buffer = [];
  const allParts = [];
  let currentPartHeaders = [];
  for (let i = 0; i < multipartBodyBuffer.length; i++) {
    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;
    const currByte = multipartBodyBuffer[i];
    const newLineChar = currByte === 10 || currByte === 13;
    if (!newLineChar) {
      lastline += String.fromCodePoint(currByte);
    }
    const newLineDetected = currByte === 10 && prevByte === 13;
    if (0 /* INIT */ === state && newLineDetected) {
      if ("--" + boundary === lastline) {
        state = 1 /* READING_HEADERS */;
      }
      lastline = "";
    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {
      if (lastline.length > 0) {
        const i2 = lastline.indexOf(":");
        if (i2 > 0) {
          const name = lastline.slice(0, i2).toLowerCase();
          const value = lastline.slice(i2 + 1).trim();
          currentPartHeaders.push([name, value]);
        }
      } else {
        state = 2 /* READING_DATA */;
        buffer = [];
      }
      lastline = "";
    } else if (2 /* READING_DATA */ === state) {
      if (lastline.length > boundary.length + 4) {
        lastline = "";
      }
      if ("--" + boundary === lastline) {
        const j = buffer.length - lastline.length;
        const part = buffer.slice(0, j - 1);
        allParts.push(process$1(part, currentPartHeaders));
        buffer = [];
        currentPartHeaders = [];
        lastline = "";
        state = 3 /* READING_PART_SEPARATOR */;
      } else {
        buffer.push(currByte);
      }
      if (newLineDetected) {
        lastline = "";
      }
    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {
      state = 1 /* READING_HEADERS */;
    }
  }
  return allParts;
}
function process$1(data, headers) {
  const dataObj = {};
  const contentDispositionHeader = headers.find((h) => h[0] === "content-disposition")?.[1] || "";
  for (const i of contentDispositionHeader.split(";")) {
    const s = i.split("=");
    if (s.length !== 2) {
      continue;
    }
    const key = (s[0] || "").trim();
    if (key === "name" || key === "filename") {
      const _value = (s[1] || "").trim().replace(/"/g, "");
      dataObj[key] = Buffer.from(_value, "latin1").toString("utf8");
    }
  }
  const contentType = headers.find((h) => h[0] === "content-type")?.[1] || "";
  if (contentType) {
    dataObj.type = contentType;
  }
  dataObj.data = Buffer.from(data);
  return dataObj;
}

function getQuery(event) {
  return getQuery$1(event.path || "");
}
function getRouterParams(event, opts = {}) {
  let params = event.context.params || {};
  if (opts.decode) {
    params = { ...params };
    for (const key in params) {
      params[key] = decode$1(params[key]);
    }
  }
  return params;
}
function getMethod(event, defaultMethod = "GET") {
  return (event.node.req.method || defaultMethod).toUpperCase();
}
function isMethod(event, expected, allowHead) {
  if (typeof expected === "string") {
    if (event.method === expected) {
      return true;
    }
  } else if (expected.includes(event.method)) {
    return true;
  }
  return false;
}
function assertMethod(event, expected, allowHead) {
  if (!isMethod(event, expected)) {
    throw createError$1({
      statusCode: 405,
      statusMessage: "HTTP method is not allowed."
    });
  }
}
function getRequestHeaders(event) {
  const _headers = {};
  for (const key in event.node.req.headers) {
    const val = event.node.req.headers[key];
    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(", ") : val;
  }
  return _headers;
}
function getRequestHeader(event, name) {
  const headers = getRequestHeaders(event);
  const value = headers[name.toLowerCase()];
  return value;
}
function getRequestHost(event, opts = {}) {
  if (opts.xForwardedHost) {
    const _header = event.node.req.headers["x-forwarded-host"];
    const xForwardedHost = (_header || "").split(",").shift()?.trim();
    if (xForwardedHost) {
      return xForwardedHost;
    }
  }
  return event.node.req.headers.host || "localhost";
}
function getRequestProtocol(event, opts = {}) {
  if (opts.xForwardedProto !== false && event.node.req.headers["x-forwarded-proto"] === "https") {
    return "https";
  }
  return event.node.req.connection?.encrypted ? "https" : "http";
}
function getRequestURL(event, opts = {}) {
  const host = getRequestHost(event, opts);
  const protocol = getRequestProtocol(event, opts);
  const path = (event.node.req.originalUrl || event.path).replace(
    /^[/\\]+/g,
    "/"
  );
  return new URL(path, `${protocol}://${host}`);
}

const RawBodySymbol = Symbol.for("h3RawBody");
const ParsedBodySymbol = Symbol.for("h3ParsedBody");
const PayloadMethods$1 = ["PATCH", "POST", "PUT", "DELETE"];
function readRawBody(event, encoding = "utf8") {
  assertMethod(event, PayloadMethods$1);
  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;
  if (_rawBody) {
    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {
      if (Buffer.isBuffer(_resolved)) {
        return _resolved;
      }
      if (typeof _resolved.pipeTo === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.pipeTo(
            new WritableStream({
              write(chunk) {
                chunks.push(chunk);
              },
              close() {
                resolve(Buffer.concat(chunks));
              },
              abort(reason) {
                reject(reason);
              }
            })
          ).catch(reject);
        });
      } else if (typeof _resolved.pipe === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.on("data", (chunk) => {
            chunks.push(chunk);
          }).on("end", () => {
            resolve(Buffer.concat(chunks));
          }).on("error", reject);
        });
      }
      if (_resolved.constructor === Object) {
        return Buffer.from(JSON.stringify(_resolved));
      }
      if (_resolved instanceof URLSearchParams) {
        return Buffer.from(_resolved.toString());
      }
      if (_resolved instanceof FormData) {
        return new Response(_resolved).bytes().then((uint8arr) => Buffer.from(uint8arr));
      }
      return Buffer.from(_resolved);
    });
    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
  }
  if (!Number.parseInt(event.node.req.headers["content-length"] || "") && !String(event.node.req.headers["transfer-encoding"] ?? "").split(",").map((e) => e.trim()).filter(Boolean).includes("chunked")) {
    return Promise.resolve(void 0);
  }
  const promise = event.node.req[RawBodySymbol] = new Promise(
    (resolve, reject) => {
      const bodyData = [];
      event.node.req.on("error", (err) => {
        reject(err);
      }).on("data", (chunk) => {
        bodyData.push(chunk);
      }).on("end", () => {
        resolve(Buffer.concat(bodyData));
      });
    }
  );
  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
  return result;
}
async function readBody(event, options = {}) {
  const request = event.node.req;
  if (hasProp(request, ParsedBodySymbol)) {
    return request[ParsedBodySymbol];
  }
  const contentType = request.headers["content-type"] || "";
  const body = await readRawBody(event);
  let parsed;
  if (contentType === "application/json") {
    parsed = _parseJSON(body, options.strict ?? true);
  } else if (contentType.startsWith("application/x-www-form-urlencoded")) {
    parsed = _parseURLEncodedBody(body);
  } else if (contentType.startsWith("text/")) {
    parsed = body;
  } else {
    parsed = _parseJSON(body, options.strict ?? false);
  }
  request[ParsedBodySymbol] = parsed;
  return parsed;
}
async function readMultipartFormData(event) {
  const contentType = getRequestHeader(event, "content-type");
  if (!contentType || !contentType.startsWith("multipart/form-data")) {
    return;
  }
  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];
  if (!boundary) {
    return;
  }
  const body = await readRawBody(event, false);
  if (!body) {
    return;
  }
  return parse(body, boundary);
}
function getRequestWebStream(event) {
  if (!PayloadMethods$1.includes(event.method)) {
    return;
  }
  const bodyStream = event.web?.request?.body || event._requestBody;
  if (bodyStream) {
    return bodyStream;
  }
  const _hasRawBody = RawBodySymbol in event.node.req || "rawBody" in event.node.req || "body" in event.node.req || "__unenv__" in event.node.req;
  if (_hasRawBody) {
    return new ReadableStream({
      async start(controller) {
        const _rawBody = await readRawBody(event, false);
        if (_rawBody) {
          controller.enqueue(_rawBody);
        }
        controller.close();
      }
    });
  }
  return new ReadableStream({
    start: (controller) => {
      event.node.req.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      event.node.req.on("end", () => {
        controller.close();
      });
      event.node.req.on("error", (err) => {
        controller.error(err);
      });
    }
  });
}
function _parseJSON(body = "", strict) {
  if (!body) {
    return void 0;
  }
  try {
    return destr(body, { strict });
  } catch {
    throw createError$1({
      statusCode: 400,
      statusMessage: "Bad Request",
      message: "Invalid JSON body"
    });
  }
}
function _parseURLEncodedBody(body) {
  const form = new URLSearchParams(body);
  const parsedForm = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of form.entries()) {
    if (hasProp(parsedForm, key)) {
      if (!Array.isArray(parsedForm[key])) {
        parsedForm[key] = [parsedForm[key]];
      }
      parsedForm[key].push(value);
    } else {
      parsedForm[key] = value;
    }
  }
  return parsedForm;
}

function handleCacheHeaders(event, opts) {
  const cacheControls = ["public", ...opts.cacheControls || []];
  let cacheMatched = false;
  if (opts.maxAge !== void 0) {
    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);
  }
  if (opts.modifiedTime) {
    const modifiedTime = new Date(opts.modifiedTime);
    const ifModifiedSince = event.node.req.headers["if-modified-since"];
    event.node.res.setHeader("last-modified", modifiedTime.toUTCString());
    if (ifModifiedSince && new Date(ifModifiedSince) >= modifiedTime) {
      cacheMatched = true;
    }
  }
  if (opts.etag) {
    event.node.res.setHeader("etag", opts.etag);
    const ifNonMatch = event.node.req.headers["if-none-match"];
    if (ifNonMatch === opts.etag) {
      cacheMatched = true;
    }
  }
  event.node.res.setHeader("cache-control", cacheControls.join(", "));
  if (cacheMatched) {
    event.node.res.statusCode = 304;
    if (!event.handled) {
      event.node.res.end();
    }
    return true;
  }
  return false;
}

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
  return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
  if (!statusCode) {
    return defaultStatusCode;
  }
  if (typeof statusCode === "string") {
    statusCode = Number.parseInt(statusCode, 10);
  }
  if (statusCode < 100 || statusCode > 999) {
    return defaultStatusCode;
  }
  return statusCode;
}

function getDistinctCookieKey(name, opts) {
  return [name, opts.domain || "", opts.path || "/"].join(";");
}

function parseCookies(event) {
  return parse$1(event.node.req.headers.cookie || "");
}
function getCookie(event, name) {
  return parseCookies(event)[name];
}
function setCookie(event, name, value, serializeOptions = {}) {
  if (!serializeOptions.path) {
    serializeOptions = { path: "/", ...serializeOptions };
  }
  const newCookie = serialize$1(name, value, serializeOptions);
  const currentCookies = splitCookiesString(
    event.node.res.getHeader("set-cookie")
  );
  if (currentCookies.length === 0) {
    event.node.res.setHeader("set-cookie", newCookie);
    return;
  }
  const newCookieKey = getDistinctCookieKey(name, serializeOptions);
  event.node.res.removeHeader("set-cookie");
  for (const cookie of currentCookies) {
    const parsed = parseSetCookie(cookie);
    const key = getDistinctCookieKey(parsed.name, parsed);
    if (key === newCookieKey) {
      continue;
    }
    event.node.res.appendHeader("set-cookie", cookie);
  }
  event.node.res.appendHeader("set-cookie", newCookie);
}
function deleteCookie(event, name, serializeOptions) {
  setCookie(event, name, "", {
    ...serializeOptions,
    maxAge: 0
  });
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString.flatMap((c) => splitCookiesString(c));
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  const cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  const skipWhitespace = () => {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  };
  const notSpecialChar = () => {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  };
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.slice(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.slice(start));
    }
  }
  return cookiesStrings;
}

const defer = typeof setImmediate === "undefined" ? (fn) => fn() : setImmediate;
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      if (!event.handled) {
        event.node.res.end(data);
      }
      resolve();
    });
  });
}
function sendNoContent(event, code) {
  if (event.handled) {
    return;
  }
  if (!code && event.node.res.statusCode !== 200) {
    code = event.node.res.statusCode;
  }
  const _code = sanitizeStatusCode(code, 204);
  if (_code === 204) {
    event.node.res.removeHeader("content-length");
  }
  event.node.res.writeHead(_code);
  event.node.res.end();
}
function setResponseStatus(event, code, text) {
  if (code) {
    event.node.res.statusCode = sanitizeStatusCode(
      code,
      event.node.res.statusCode
    );
  }
  if (text) {
    event.node.res.statusMessage = sanitizeStatusMessage(text);
  }
}
function getResponseStatus(event) {
  return event.node.res.statusCode;
}
function getResponseStatusText(event) {
  return event.node.res.statusMessage;
}
function defaultContentType(event, type) {
  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader("content-type")) {
    event.node.res.setHeader("content-type", type);
  }
}
function sendRedirect(event, location, code = 302) {
  event.node.res.statusCode = sanitizeStatusCode(
    code,
    event.node.res.statusCode
  );
  event.node.res.setHeader("location", location);
  const encodedLoc = location.replace(/"/g, "%22");
  const html = `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`;
  return send(event, html, MIMES.html);
}
function getResponseHeader(event, name) {
  return event.node.res.getHeader(name);
}
function setResponseHeaders(event, headers) {
  for (const [name, value] of Object.entries(headers)) {
    event.node.res.setHeader(
      name,
      value
    );
  }
}
const setHeaders = setResponseHeaders;
function setResponseHeader(event, name, value) {
  event.node.res.setHeader(name, value);
}
const setHeader = setResponseHeader;
function appendResponseHeader(event, name, value) {
  let current = event.node.res.getHeader(name);
  if (!current) {
    event.node.res.setHeader(name, value);
    return;
  }
  if (!Array.isArray(current)) {
    current = [current.toString()];
  }
  event.node.res.setHeader(name, [...current, value]);
}
function isStream(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  if (typeof data.pipe === "function") {
    if (typeof data._read === "function") {
      return true;
    }
    if (typeof data.abort === "function") {
      return true;
    }
  }
  if (typeof data.pipeTo === "function") {
    return true;
  }
  return false;
}
function isWebResponse(data) {
  return typeof Response !== "undefined" && data instanceof Response;
}
function sendStream(event, stream) {
  if (!stream || typeof stream !== "object") {
    throw new Error("[h3] Invalid stream provided.");
  }
  event.node.res._data = stream;
  if (!event.node.res.socket) {
    event._handled = true;
    return Promise.resolve();
  }
  if (hasProp(stream, "pipeTo") && typeof stream.pipeTo === "function") {
    return stream.pipeTo(
      new WritableStream({
        write(chunk) {
          event.node.res.write(chunk);
        }
      })
    ).then(() => {
      event.node.res.end();
    });
  }
  if (hasProp(stream, "pipe") && typeof stream.pipe === "function") {
    return new Promise((resolve, reject) => {
      stream.pipe(event.node.res);
      if (stream.on) {
        stream.on("end", () => {
          event.node.res.end();
          resolve();
        });
        stream.on("error", (error) => {
          reject(error);
        });
      }
      event.node.res.on("close", () => {
        if (stream.abort) {
          stream.abort();
        }
      });
    });
  }
  throw new Error("[h3] Invalid or incompatible stream provided.");
}
function sendWebResponse(event, response) {
  for (const [key, value] of response.headers) {
    if (key === "set-cookie") {
      event.node.res.appendHeader(key, splitCookiesString(value));
    } else {
      event.node.res.setHeader(key, value);
    }
  }
  if (response.status) {
    event.node.res.statusCode = sanitizeStatusCode(
      response.status,
      event.node.res.statusCode
    );
  }
  if (response.statusText) {
    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  }
  if (response.redirected) {
    event.node.res.setHeader("location", response.url);
  }
  if (!response.body) {
    event.node.res.end();
    return;
  }
  return sendStream(event, response.body);
}

const PayloadMethods = /* @__PURE__ */ new Set(["PATCH", "POST", "PUT", "DELETE"]);
const ignoredHeaders = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "accept-encoding",
  "connection",
  "keep-alive",
  "upgrade",
  "expect",
  "host",
  "accept"
]);
async function proxyRequest(event, target, opts = {}) {
  let body;
  let duplex;
  if (PayloadMethods.has(event.method)) {
    if (opts.streamRequest) {
      body = getRequestWebStream(event);
      duplex = "half";
    } else {
      body = await readRawBody(event, false).catch(() => void 0);
    }
  }
  const method = opts.fetchOptions?.method || event.method;
  const fetchHeaders = mergeHeaders$1(
    getProxyRequestHeaders(event, { host: target.startsWith("/") }),
    opts.fetchOptions?.headers,
    opts.headers
  );
  return sendProxy(event, target, {
    ...opts,
    fetchOptions: {
      method,
      body,
      duplex,
      ...opts.fetchOptions,
      headers: fetchHeaders
    }
  });
}
async function sendProxy(event, target, opts = {}) {
  let response;
  try {
    response = await _getFetch(opts.fetch)(target, {
      headers: opts.headers,
      ignoreResponseError: true,
      // make $ofetch.raw transparent
      ...opts.fetchOptions
    });
  } catch (error) {
    throw createError$1({
      status: 502,
      statusMessage: "Bad Gateway",
      cause: error
    });
  }
  event.node.res.statusCode = sanitizeStatusCode(
    response.status,
    event.node.res.statusCode
  );
  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  const cookies = [];
  for (const [key, value] of response.headers.entries()) {
    if (key === "content-encoding") {
      continue;
    }
    if (key === "content-length") {
      continue;
    }
    if (key === "set-cookie") {
      cookies.push(...splitCookiesString(value));
      continue;
    }
    event.node.res.setHeader(key, value);
  }
  if (cookies.length > 0) {
    event.node.res.setHeader(
      "set-cookie",
      cookies.map((cookie) => {
        if (opts.cookieDomainRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookieDomainRewrite,
            "domain"
          );
        }
        if (opts.cookiePathRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookiePathRewrite,
            "path"
          );
        }
        return cookie;
      })
    );
  }
  if (opts.onResponse) {
    await opts.onResponse(event, response);
  }
  if (response._data !== void 0) {
    return response._data;
  }
  if (event.handled) {
    return;
  }
  if (opts.sendStream === false) {
    const data = new Uint8Array(await response.arrayBuffer());
    return event.node.res.end(data);
  }
  if (response.body) {
    for await (const chunk of response.body) {
      event.node.res.write(chunk);
    }
  }
  return event.node.res.end();
}
function getProxyRequestHeaders(event, opts) {
  const headers = /* @__PURE__ */ Object.create(null);
  const reqHeaders = getRequestHeaders(event);
  for (const name in reqHeaders) {
    if (!ignoredHeaders.has(name) || name === "host" && opts?.host) {
      headers[name] = reqHeaders[name];
    }
  }
  return headers;
}
function fetchWithEvent(event, req, init, options) {
  return _getFetch(options?.fetch)(req, {
    ...init,
    context: init?.context || event.context,
    headers: {
      ...getProxyRequestHeaders(event, {
        host: typeof req === "string" && req.startsWith("/")
      }),
      ...init?.headers
    }
  });
}
function _getFetch(_fetch) {
  if (_fetch) {
    return _fetch;
  }
  if (globalThis.fetch) {
    return globalThis.fetch;
  }
  throw new Error(
    "fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js."
  );
}
function rewriteCookieProperty(header, map, property) {
  const _map = typeof map === "string" ? { "*": map } : map;
  return header.replace(
    new RegExp(`(;\\s*${property}=)([^;]+)`, "gi"),
    (match, prefix, previousValue) => {
      let newValue;
      if (previousValue in _map) {
        newValue = _map[previousValue];
      } else if ("*" in _map) {
        newValue = _map["*"];
      } else {
        return match;
      }
      return newValue ? prefix + newValue : "";
    }
  );
}
function mergeHeaders$1(defaults, ...inputs) {
  const _inputs = inputs.filter(Boolean);
  if (_inputs.length === 0) {
    return defaults;
  }
  const merged = new Headers(defaults);
  for (const input of _inputs) {
    const entries = Array.isArray(input) ? input : typeof input.entries === "function" ? input.entries() : Object.entries(input);
    for (const [key, value] of entries) {
      if (value !== void 0) {
        merged.set(key, value);
      }
    }
  }
  return merged;
}

class H3Event {
  "__is_event__" = true;
  // Context
  node;
  // Node
  web;
  // Web
  context = {};
  // Shared
  // Request
  _method;
  _path;
  _headers;
  _requestBody;
  // Response
  _handled = false;
  // Hooks
  _onBeforeResponseCalled;
  _onAfterResponseCalled;
  constructor(req, res) {
    this.node = { req, res };
  }
  // --- Request ---
  get method() {
    if (!this._method) {
      this._method = (this.node.req.method || "GET").toUpperCase();
    }
    return this._method;
  }
  get path() {
    return this._path || this.node.req.url || "/";
  }
  get headers() {
    if (!this._headers) {
      this._headers = _normalizeNodeHeaders(this.node.req.headers);
    }
    return this._headers;
  }
  // --- Respoonse ---
  get handled() {
    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
  }
  respondWith(response) {
    return Promise.resolve(response).then(
      (_response) => sendWebResponse(this, _response)
    );
  }
  // --- Utils ---
  toString() {
    return `[${this.method}] ${this.path}`;
  }
  toJSON() {
    return this.toString();
  }
  // --- Deprecated ---
  /** @deprecated Please use `event.node.req` instead. */
  get req() {
    return this.node.req;
  }
  /** @deprecated Please use `event.node.res` instead. */
  get res() {
    return this.node.res;
  }
}
function isEvent(input) {
  return hasProp(input, "__is_event__");
}
function createEvent(req, res) {
  return new H3Event(req, res);
}
function _normalizeNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [name, value] of Object.entries(nodeHeaders)) {
    if (Array.isArray(value)) {
      for (const item of value) {
        headers.append(name, item);
      }
    } else if (value) {
      headers.set(name, value);
    }
  }
  return headers;
}

function defineEventHandler(handler) {
  if (typeof handler === "function") {
    handler.__is_handler__ = true;
    return handler;
  }
  const _hooks = {
    onRequest: _normalizeArray(handler.onRequest),
    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)
  };
  const _handler = (event) => {
    return _callHandler(event, handler.handler, _hooks);
  };
  _handler.__is_handler__ = true;
  _handler.__resolve__ = handler.handler.__resolve__;
  _handler.__websocket__ = handler.websocket;
  return _handler;
}
function _normalizeArray(input) {
  return input ? Array.isArray(input) ? input : [input] : void 0;
}
async function _callHandler(event, handler, hooks) {
  if (hooks.onRequest) {
    for (const hook of hooks.onRequest) {
      await hook(event);
      if (event.handled) {
        return;
      }
    }
  }
  const body = await handler(event);
  const response = { body };
  if (hooks.onBeforeResponse) {
    for (const hook of hooks.onBeforeResponse) {
      await hook(event, response);
    }
  }
  return response.body;
}
const eventHandler = defineEventHandler;
function isEventHandler(input) {
  return hasProp(input, "__is_handler__");
}
function toEventHandler(input, _, _route) {
  if (!isEventHandler(input)) {
    console.warn(
      "[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.",
      _route && _route !== "/" ? `
     Route: ${_route}` : "",
      `
     Handler: ${input}`
    );
  }
  return input;
}
function defineLazyEventHandler(factory) {
  let _promise;
  let _resolved;
  const resolveHandler = () => {
    if (_resolved) {
      return Promise.resolve(_resolved);
    }
    if (!_promise) {
      _promise = Promise.resolve(factory()).then((r) => {
        const handler2 = r.default || r;
        if (typeof handler2 !== "function") {
          throw new TypeError(
            "Invalid lazy handler result. It should be a function:",
            handler2
          );
        }
        _resolved = { handler: toEventHandler(r.default || r) };
        return _resolved;
      });
    }
    return _promise;
  };
  const handler = eventHandler((event) => {
    if (_resolved) {
      return _resolved.handler(event);
    }
    return resolveHandler().then((r) => r.handler(event));
  });
  handler.__resolve__ = resolveHandler;
  return handler;
}
const lazyEventHandler = defineLazyEventHandler;

function createApp(options = {}) {
  const stack = [];
  const handler = createAppEventHandler(stack, options);
  const resolve = createResolver(stack);
  handler.__resolve__ = resolve;
  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));
  const app = {
    // @ts-expect-error
    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),
    resolve,
    handler,
    stack,
    options,
    get websocket() {
      return getWebsocket();
    }
  };
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    for (const i of arg1) {
      use(app, i, arg2, arg3);
    }
  } else if (Array.isArray(arg2)) {
    for (const i of arg2) {
      use(app, arg1, i, arg3);
    }
  } else if (typeof arg1 === "string") {
    app.stack.push(
      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })
    );
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createAppEventHandler(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return eventHandler(async (event) => {
    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || "/";
    const _reqPath = event._path || event.node.req.url || "/";
    let _layerPath;
    if (options.onRequest) {
      await options.onRequest(event);
    }
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!_reqPath.startsWith(layer.route)) {
          continue;
        }
        _layerPath = _reqPath.slice(layer.route.length) || "/";
      } else {
        _layerPath = _reqPath;
      }
      if (layer.match && !layer.match(_layerPath, event)) {
        continue;
      }
      event._path = _layerPath;
      event.node.req.url = _layerPath;
      const val = await layer.handler(event);
      const _body = val === void 0 ? void 0 : await val;
      if (_body !== void 0) {
        const _response = { body: _body };
        if (options.onBeforeResponse) {
          event._onBeforeResponseCalled = true;
          await options.onBeforeResponse(event, _response);
        }
        await handleHandlerResponse(event, _response.body, spacing);
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, _response);
        }
        return;
      }
      if (event.handled) {
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, void 0);
        }
        return;
      }
    }
    if (!event.handled) {
      throw createError$1({
        statusCode: 404,
        statusMessage: `Cannot find any path matching ${event.path || "/"}.`
      });
    }
    if (options.onAfterResponse) {
      event._onAfterResponseCalled = true;
      await options.onAfterResponse(event, void 0);
    }
  });
}
function createResolver(stack) {
  return async (path) => {
    let _layerPath;
    for (const layer of stack) {
      if (layer.route === "/" && !layer.handler.__resolve__) {
        continue;
      }
      if (!path.startsWith(layer.route)) {
        continue;
      }
      _layerPath = path.slice(layer.route.length) || "/";
      if (layer.match && !layer.match(_layerPath, void 0)) {
        continue;
      }
      let res = { route: layer.route, handler: layer.handler };
      if (res.handler.__resolve__) {
        const _res = await res.handler.__resolve__(_layerPath);
        if (!_res) {
          continue;
        }
        res = {
          ...res,
          ..._res,
          route: joinURL(res.route || "/", _res.route || "/")
        };
      }
      return res;
    }
  };
}
function normalizeLayer(input) {
  let handler = input.handler;
  if (handler.handler) {
    handler = handler.handler;
  }
  if (input.lazy) {
    handler = lazyEventHandler(handler);
  } else if (!isEventHandler(handler)) {
    handler = toEventHandler(handler, void 0, input.route);
  }
  return {
    route: withoutTrailingSlash(input.route),
    match: input.match,
    handler
  };
}
function handleHandlerResponse(event, val, jsonSpace) {
  if (val === null) {
    return sendNoContent(event);
  }
  if (val) {
    if (isWebResponse(val)) {
      return sendWebResponse(event, val);
    }
    if (isStream(val)) {
      return sendStream(event, val);
    }
    if (val.buffer) {
      return send(event, val);
    }
    if (val.arrayBuffer && typeof val.arrayBuffer === "function") {
      return val.arrayBuffer().then((arrayBuffer) => {
        return send(event, Buffer.from(arrayBuffer), val.type);
      });
    }
    if (val instanceof Error) {
      throw createError$1(val);
    }
    if (typeof val.end === "function") {
      return true;
    }
  }
  const valType = typeof val;
  if (valType === "string") {
    return send(event, val, MIMES.html);
  }
  if (valType === "object" || valType === "boolean" || valType === "number") {
    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);
  }
  if (valType === "bigint") {
    return send(event, val.toString(), MIMES.json);
  }
  throw createError$1({
    statusCode: 500,
    statusMessage: `[h3] Cannot send ${valType} as response.`
  });
}
function cachedFn(fn) {
  let cache;
  return () => {
    if (!cache) {
      cache = fn();
    }
    return cache;
  };
}
function websocketOptions(evResolver, appOptions) {
  return {
    ...appOptions.websocket,
    async resolve(info) {
      const url = info.request?.url || info.url || "/";
      const { pathname } = typeof url === "string" ? parseURL(url) : url;
      const resolved = await evResolver(pathname);
      return resolved?.handler?.__websocket__ || {};
    }
  };
}

const RouterMethods = [
  "connect",
  "delete",
  "get",
  "head",
  "options",
  "post",
  "put",
  "trace",
  "patch"
];
function createRouter(opts = {}) {
  const _router = createRouter$1({});
  const routes = {};
  let _matcher;
  const router = {};
  const addRoute = (path, handler, method) => {
    let route = routes[path];
    if (!route) {
      routes[path] = route = { path, handlers: {} };
      _router.insert(path, route);
    }
    if (Array.isArray(method)) {
      for (const m of method) {
        addRoute(path, handler, m);
      }
    } else {
      route.handlers[method] = toEventHandler(handler, void 0, path);
    }
    return router;
  };
  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || "all");
  for (const method of RouterMethods) {
    router[method] = (path, handle) => router.add(path, handle, method);
  }
  const matchHandler = (path = "/", method = "get") => {
    const qIndex = path.indexOf("?");
    if (qIndex !== -1) {
      path = path.slice(0, Math.max(0, qIndex));
    }
    const matched = _router.lookup(path);
    if (!matched || !matched.handlers) {
      return {
        error: createError$1({
          statusCode: 404,
          name: "Not Found",
          statusMessage: `Cannot find any route matching ${path || "/"}.`
        })
      };
    }
    let handler = matched.handlers[method] || matched.handlers.all;
    if (!handler) {
      if (!_matcher) {
        _matcher = toRouteMatcher(_router);
      }
      const _matches = _matcher.matchAll(path).reverse();
      for (const _match of _matches) {
        if (_match.handlers[method]) {
          handler = _match.handlers[method];
          matched.handlers[method] = matched.handlers[method] || handler;
          break;
        }
        if (_match.handlers.all) {
          handler = _match.handlers.all;
          matched.handlers.all = matched.handlers.all || handler;
          break;
        }
      }
    }
    if (!handler) {
      return {
        error: createError$1({
          statusCode: 405,
          name: "Method Not Allowed",
          statusMessage: `Method ${method} is not allowed on this route.`
        })
      };
    }
    return { matched, handler };
  };
  const isPreemptive = opts.preemptive || opts.preemtive;
  router.handler = eventHandler((event) => {
    const match = matchHandler(
      event.path,
      event.method.toLowerCase()
    );
    if ("error" in match) {
      if (isPreemptive) {
        throw match.error;
      } else {
        return;
      }
    }
    event.context.matchedRoute = match.matched;
    const params = match.matched.params || {};
    event.context.params = params;
    return Promise.resolve(match.handler(event)).then((res) => {
      if (res === void 0 && isPreemptive) {
        return null;
      }
      return res;
    });
  });
  router.handler.__resolve__ = async (path) => {
    path = withLeadingSlash(path);
    const match = matchHandler(path);
    if ("error" in match) {
      return;
    }
    let res = {
      route: match.matched.path,
      handler: match.handler
    };
    if (match.handler.__resolve__) {
      const _res = await match.handler.__resolve__(path);
      if (!_res) {
        return;
      }
      res = { ...res, ..._res };
    }
    return res;
  };
  return router;
}
function toNodeListener(app) {
  const toNodeHandle = async function(req, res) {
    const event = createEvent(req, res);
    try {
      await app.handler(event);
    } catch (_error) {
      const error = createError$1(_error);
      if (!isError(_error)) {
        error.unhandled = true;
      }
      setResponseStatus(event, error.statusCode, error.statusMessage);
      if (app.options.onError) {
        await app.options.onError(error, event);
      }
      if (event.handled) {
        return;
      }
      if (error.unhandled || error.fatal) {
        console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
      }
      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {
        await app.options.onBeforeResponse(event, { body: error });
      }
      await sendError(event, error, !!app.options.debug);
      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {
        await app.options.onAfterResponse(event, { body: error });
      }
    }
  };
  return toNodeHandle;
}

function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}

class Hookable {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}

const s$1=globalThis.Headers,i=globalThis.AbortController,l=globalThis.fetch||(()=>{throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!")});

class FetchError extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
}
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}

const payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers) {
  const headers = mergeHeaders(
    input?.headers ?? request?.headers,
    defaults?.headers,
    Headers
  );
  let query;
  if (defaults?.query || defaults?.params || input?.params || input?.query) {
    query = {
      ...defaults?.params,
      ...defaults?.query,
      ...input?.params,
      ...input?.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers) {
  if (!defaults) {
    return new Headers(input);
  }
  const headers = new Headers(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}

const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
const nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch = globalThis.fetch,
    Headers = globalThis.Headers,
    AbortController = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r = await $fetchRaw(request, options);
    return r._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

function createNodeFetch() {
  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || "false");
  if (!useKeepAlive) {
    return l;
  }
  const agentOptions = { keepAlive: true };
  const httpAgent = new http$1.Agent(agentOptions);
  const httpsAgent = new https$1.Agent(agentOptions);
  const nodeFetchOptions = {
    agent(parsedURL) {
      return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
    }
  };
  return function nodeFetchWithKeepAlive(input, init) {
    return l(input, { ...nodeFetchOptions, ...init });
  };
}
const fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();
const Headers$1 = globalThis.Headers || s$1;
const AbortController = globalThis.AbortController || i;
createFetch({ fetch, Headers: Headers$1, AbortController });

function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c) => c.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}

const storageKeyProperties = [
  "has",
  "hasItem",
  "get",
  "getItem",
  "getItemRaw",
  "set",
  "setItem",
  "setItemRaw",
  "del",
  "remove",
  "removeItem",
  "getMeta",
  "setMeta",
  "removeMeta",
  "getKeys",
  "clear",
  "mount",
  "unmount"
];
function prefixStorage(storage, base) {
  base = normalizeBaseKey(base);
  if (!base) {
    return storage;
  }
  const nsStorage = { ...storage };
  for (const property of storageKeyProperties) {
    nsStorage[property] = (key = "", ...args) => (
      // @ts-ignore
      storage[property](base + key, ...args)
    );
  }
  nsStorage.getKeys = (key = "", ...arguments_) => storage.getKeys(base + key, ...arguments_).then((keys) => keys.map((key2) => key2.slice(base.length)));
  nsStorage.keys = nsStorage.getKeys;
  nsStorage.getItems = async (items, commonOptions) => {
    const prefixedItems = items.map(
      (item) => typeof item === "string" ? base + item : { ...item, key: base + item.key }
    );
    const results = await storage.getItems(prefixedItems, commonOptions);
    return results.map((entry) => ({
      key: entry.key.slice(base.length),
      value: entry.value
    }));
  };
  nsStorage.setItems = async (items, commonOptions) => {
    const prefixedItems = items.map((item) => ({
      key: base + item.key,
      value: item.value,
      options: item.options
    }));
    return storage.setItems(prefixedItems, commonOptions);
  };
  return nsStorage;
}
function normalizeKey$1(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
  return normalizeKey$1(keys.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey$1(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

function defineDriver$1(factory) {
  return factory;
}

const DRIVER_NAME$1 = "memory";
const memory = defineDriver$1(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME$1,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey$1(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey$1(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey$1(key);
          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m) => {
          if (m.driver.clear) {
            return asyncCall(m.driver.clear, m.relativeBase, opts);
          }
          if (m.driver.removeItem) {
            const keys = await m.driver.getKeys(m.relativeBase || "", opts);
            return Promise.all(
              keys.map((key) => m.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a, b) => b.length - a.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]?.();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey$1(key) + ":";
      const m = getMount(key);
      return {
        driver: m.driver,
        base: m.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey$1(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

const _assets = {

};

const normalizeKey = function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
};

const assets = {
  getKeys() {
    return Promise.resolve(Object.keys(_assets))
  },
  hasItem (id) {
    id = normalizeKey(id);
    return Promise.resolve(id in _assets)
  },
  getItem (id) {
    id = normalizeKey(id);
    return Promise.resolve(_assets[id] ? _assets[id].import() : null)
  },
  getMeta (id) {
    id = normalizeKey(id);
    return Promise.resolve(_assets[id] ? _assets[id].meta : {})
  }
};

function defineDriver(factory) {
  return factory;
}
function createError(driver, message, opts) {
  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, createError);
  }
  return err;
}
function createRequiredError(driver, name) {
  if (Array.isArray(name)) {
    return createError(
      driver,
      `Missing some of the required options ${name.map((n) => "`" + n + "`").join(", ")}`
    );
  }
  return createError(driver, `Missing required option \`${name}\`.`);
}

function ignoreNotfound(err) {
  return err.code === "ENOENT" || err.code === "EISDIR" ? null : err;
}
function ignoreExists(err) {
  return err.code === "EEXIST" ? null : err;
}
async function writeFile(path, data, encoding) {
  await ensuredir(dirname(path));
  return promises.writeFile(path, data, encoding);
}
function readFile(path, encoding) {
  return promises.readFile(path, encoding).catch(ignoreNotfound);
}
function unlink(path) {
  return promises.unlink(path).catch(ignoreNotfound);
}
function readdir(dir) {
  return promises.readdir(dir, { withFileTypes: true }).catch(ignoreNotfound).then((r) => r || []);
}
async function ensuredir(dir) {
  if (existsSync(dir)) {
    return;
  }
  await ensuredir(dirname(dir)).catch(ignoreExists);
  await promises.mkdir(dir).catch(ignoreExists);
}
async function readdirRecursive(dir, ignore, maxDepth) {
  if (ignore && ignore(dir)) {
    return [];
  }
  const entries = await readdir(dir);
  const files = [];
  await Promise.all(
    entries.map(async (entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        if (maxDepth === void 0 || maxDepth > 0) {
          const dirFiles = await readdirRecursive(
            entryPath,
            ignore,
            maxDepth === void 0 ? void 0 : maxDepth - 1
          );
          files.push(...dirFiles.map((f) => entry.name + "/" + f));
        }
      } else {
        if (!(ignore && ignore(entry.name))) {
          files.push(entry.name);
        }
      }
    })
  );
  return files;
}
async function rmRecursive(dir) {
  const entries = await readdir(dir);
  await Promise.all(
    entries.map((entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        return rmRecursive(entryPath).then(() => promises.rmdir(entryPath));
      } else {
        return promises.unlink(entryPath);
      }
    })
  );
}

const PATH_TRAVERSE_RE = /\.\.:|\.\.$/;
const DRIVER_NAME = "fs-lite";
const unstorage_47drivers_47fs_45lite = defineDriver((opts = {}) => {
  if (!opts.base) {
    throw createRequiredError(DRIVER_NAME, "base");
  }
  opts.base = resolve$1(opts.base);
  const r = (key) => {
    if (PATH_TRAVERSE_RE.test(key)) {
      throw createError(
        DRIVER_NAME,
        `Invalid key: ${JSON.stringify(key)}. It should not contain .. segments`
      );
    }
    const resolved = join(opts.base, key.replace(/:/g, "/"));
    return resolved;
  };
  return {
    name: DRIVER_NAME,
    options: opts,
    flags: {
      maxDepth: true
    },
    hasItem(key) {
      return existsSync(r(key));
    },
    getItem(key) {
      return readFile(r(key), "utf8");
    },
    getItemRaw(key) {
      return readFile(r(key));
    },
    async getMeta(key) {
      const { atime, mtime, size, birthtime, ctime } = await promises.stat(r(key)).catch(() => ({}));
      return { atime, mtime, size, birthtime, ctime };
    },
    setItem(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value, "utf8");
    },
    setItemRaw(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value);
    },
    removeItem(key) {
      if (opts.readOnly) {
        return;
      }
      return unlink(r(key));
    },
    getKeys(_base, topts) {
      return readdirRecursive(r("."), opts.ignore, topts?.maxDepth);
    },
    async clear() {
      if (opts.readOnly || opts.noClear) {
        return;
      }
      await rmRecursive(r("."));
    }
  };
});

const storage$2 = createStorage({});

storage$2.mount('/assets', assets);

storage$2.mount('data', unstorage_47drivers_47fs_45lite({"driver":"fsLite","base":"./.data/kv"}));

function useStorage(base = "") {
  return base ? prefixStorage(storage$2, base) : storage$2;
}

const e=globalThis.process?.getBuiltinModule?.("crypto")?.hash,r="sha256",s="base64url";function digest(t){if(e)return e(r,t,s);const o=createHash(r).update(t);return globalThis.process?.versions?.webcontainer?o.digest().toString(s):o.digest(s)}

const Hasher = /* @__PURE__ */ (() => {
  class Hasher2 {
    buff = "";
    #context = /* @__PURE__ */ new Map();
    write(str) {
      this.buff += str;
    }
    dispatch(value) {
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    }
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      objType = objectLength < 10 ? "unknown:[" + objString + "]" : objString.slice(8, objectLength - 1);
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = this.#context.get(object)) === void 0) {
        this.#context.set(object, this.#context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        this.write("buffer:");
        return this.write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else {
          this.unknown(object, objType);
        }
      } else {
        const keys = Object.keys(object).sort();
        const extraKeys = [];
        this.write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          this.write(":");
          this.dispatch(object[key]);
          this.write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    }
    array(arr, unordered) {
      unordered = unordered === void 0 ? false : unordered;
      this.write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = new Hasher2();
        hasher.dispatch(entry);
        for (const [key, value] of hasher.#context) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      this.#context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    }
    date(date) {
      return this.write("date:" + date.toJSON());
    }
    symbol(sym) {
      return this.write("symbol:" + sym.toString());
    }
    unknown(value, type) {
      this.write(type);
      if (!value) {
        return;
      }
      this.write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          [...value.entries()],
          true
          /* ordered */
        );
      }
    }
    error(err) {
      return this.write("error:" + err.toString());
    }
    boolean(bool) {
      return this.write("bool:" + bool);
    }
    string(string) {
      this.write("string:" + string.length + ":");
      this.write(string);
    }
    function(fn) {
      this.write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
    }
    number(number) {
      return this.write("number:" + number);
    }
    null() {
      return this.write("Null");
    }
    undefined() {
      return this.write("Undefined");
    }
    regexp(regex) {
      return this.write("regex:" + regex.toString());
    }
    arraybuffer(arr) {
      this.write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    }
    url(url) {
      return this.write("url:" + url.toString());
    }
    map(map) {
      this.write("map:");
      const arr = [...map];
      return this.array(arr, false);
    }
    set(set) {
      this.write("set:");
      const arr = [...set];
      return this.array(arr, false);
    }
    bigint(number) {
      return this.write("bigint:" + number.toString());
    }
  }
  for (const type of [
    "uint8array",
    "uint8clampedarray",
    "unt8array",
    "uint16array",
    "unt16array",
    "uint32array",
    "unt32array",
    "float32array",
    "float64array"
  ]) {
    Hasher2.prototype[type] = function(arr) {
      this.write(type + ":");
      return this.array([...arr], false);
    };
  }
  function isNativeFunction(f) {
    if (typeof f !== "function") {
      return false;
    }
    return Function.prototype.toString.call(f).slice(
      -15
      /* "[native code] }".length */
    ) === "[native code] }";
  }
  return Hasher2;
})();
function serialize(object) {
  const hasher = new Hasher();
  hasher.dispatch(object);
  return hasher.buff;
}
function hash(value) {
  return digest(typeof value === "string" ? value : serialize(value)).replace(/[-_]/g, "").slice(0, 10);
}

function defaultCacheOptions() {
  return {
    name: "_",
    base: "/cache",
    swr: true,
    maxAge: 1
  };
}
function defineCachedFunction(fn, opts = {}) {
  opts = { ...defaultCacheOptions(), ...opts };
  const pending = {};
  const group = opts.group || "nitro/functions";
  const name = opts.name || fn.name || "_";
  const integrity = opts.integrity || hash([fn, opts]);
  const validate = opts.validate || ((entry) => entry.value !== void 0);
  async function get(key, resolver, shouldInvalidateCache, event) {
    const cacheKey = [opts.base, group, name, key + ".json"].filter(Boolean).join(":").replace(/:\/$/, ":index");
    let entry = await useStorage().getItem(cacheKey).catch((error) => {
      console.error(`[cache] Cache read error.`, error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }) || {};
    if (typeof entry !== "object") {
      entry = {};
      const error = new Error("Malformed data read from cache.");
      console.error("[cache]", error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }
    const ttl = (opts.maxAge ?? 0) * 1e3;
    if (ttl) {
      entry.expires = Date.now() + ttl;
    }
    const expired = shouldInvalidateCache || entry.integrity !== integrity || ttl && Date.now() - (entry.mtime || 0) > ttl || validate(entry) === false;
    const _resolve = async () => {
      const isPending = pending[key];
      if (!isPending) {
        if (entry.value !== void 0 && (opts.staleMaxAge || 0) >= 0 && opts.swr === false) {
          entry.value = void 0;
          entry.integrity = void 0;
          entry.mtime = void 0;
          entry.expires = void 0;
        }
        pending[key] = Promise.resolve(resolver());
      }
      try {
        entry.value = await pending[key];
      } catch (error) {
        if (!isPending) {
          delete pending[key];
        }
        throw error;
      }
      if (!isPending) {
        entry.mtime = Date.now();
        entry.integrity = integrity;
        delete pending[key];
        if (validate(entry) !== false) {
          let setOpts;
          if (opts.maxAge && !opts.swr) {
            setOpts = { ttl: opts.maxAge };
          }
          const promise = useStorage().setItem(cacheKey, entry, setOpts).catch((error) => {
            console.error(`[cache] Cache write error.`, error);
            useNitroApp().captureError(error, { event, tags: ["cache"] });
          });
          if (event?.waitUntil) {
            event.waitUntil(promise);
          }
        }
      }
    };
    const _resolvePromise = expired ? _resolve() : Promise.resolve();
    if (entry.value === void 0) {
      await _resolvePromise;
    } else if (expired && event && event.waitUntil) {
      event.waitUntil(_resolvePromise);
    }
    if (opts.swr && validate(entry) !== false) {
      _resolvePromise.catch((error) => {
        console.error(`[cache] SWR handler error.`, error);
        useNitroApp().captureError(error, { event, tags: ["cache"] });
      });
      return entry;
    }
    return _resolvePromise.then(() => entry);
  }
  return async (...args) => {
    const shouldBypassCache = await opts.shouldBypassCache?.(...args);
    if (shouldBypassCache) {
      return fn(...args);
    }
    const key = await (opts.getKey || getKey)(...args);
    const shouldInvalidateCache = await opts.shouldInvalidateCache?.(...args);
    const entry = await get(
      key,
      () => fn(...args),
      shouldInvalidateCache,
      args[0] && isEvent(args[0]) ? args[0] : void 0
    );
    let value = entry.value;
    if (opts.transform) {
      value = await opts.transform(entry, ...args) || value;
    }
    return value;
  };
}
function cachedFunction(fn, opts = {}) {
  return defineCachedFunction(fn, opts);
}
function getKey(...args) {
  return args.length > 0 ? hash(args) : "";
}
function escapeKey(key) {
  return String(key).replace(/\W/g, "");
}
function defineCachedEventHandler(handler, opts = defaultCacheOptions()) {
  const variableHeaderNames = (opts.varies || []).filter(Boolean).map((h) => h.toLowerCase()).sort();
  const _opts = {
    ...opts,
    getKey: async (event) => {
      const customKey = await opts.getKey?.(event);
      if (customKey) {
        return escapeKey(customKey);
      }
      const _path = event.node.req.originalUrl || event.node.req.url || event.path;
      let _pathname;
      try {
        _pathname = escapeKey(decodeURI(parseURL(_path).pathname)).slice(0, 16) || "index";
      } catch {
        _pathname = "-";
      }
      const _hashedPath = `${_pathname}.${hash(_path)}`;
      const _headers = variableHeaderNames.map((header) => [header, event.node.req.headers[header]]).map(([name, value]) => `${escapeKey(name)}.${hash(value)}`);
      return [_hashedPath, ..._headers].join(":");
    },
    validate: (entry) => {
      if (!entry.value) {
        return false;
      }
      if (entry.value.code >= 400) {
        return false;
      }
      if (entry.value.body === void 0) {
        return false;
      }
      if (entry.value.headers.etag === "undefined" || entry.value.headers["last-modified"] === "undefined") {
        return false;
      }
      return true;
    },
    group: opts.group || "nitro/handlers",
    integrity: opts.integrity || hash([handler, opts])
  };
  const _cachedHandler = cachedFunction(
    async (incomingEvent) => {
      const variableHeaders = {};
      for (const header of variableHeaderNames) {
        const value = incomingEvent.node.req.headers[header];
        if (value !== void 0) {
          variableHeaders[header] = value;
        }
      }
      const reqProxy = cloneWithProxy(incomingEvent.node.req, {
        headers: variableHeaders
      });
      const resHeaders = {};
      let _resSendBody;
      const resProxy = cloneWithProxy(incomingEvent.node.res, {
        statusCode: 200,
        writableEnded: false,
        writableFinished: false,
        headersSent: false,
        closed: false,
        getHeader(name) {
          return resHeaders[name];
        },
        setHeader(name, value) {
          resHeaders[name] = value;
          return this;
        },
        getHeaderNames() {
          return Object.keys(resHeaders);
        },
        hasHeader(name) {
          return name in resHeaders;
        },
        removeHeader(name) {
          delete resHeaders[name];
        },
        getHeaders() {
          return resHeaders;
        },
        end(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2();
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return this;
        },
        write(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2(void 0);
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return true;
        },
        writeHead(statusCode, headers2) {
          this.statusCode = statusCode;
          if (headers2) {
            if (Array.isArray(headers2) || typeof headers2 === "string") {
              throw new TypeError("Raw headers  is not supported.");
            }
            for (const header in headers2) {
              const value = headers2[header];
              if (value !== void 0) {
                this.setHeader(
                  header,
                  value
                );
              }
            }
          }
          return this;
        }
      });
      const event = createEvent(reqProxy, resProxy);
      event.fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: useNitroApp().localFetch
      });
      event.$fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: globalThis.$fetch
      });
      event.waitUntil = incomingEvent.waitUntil;
      event.context = incomingEvent.context;
      event.context.cache = {
        options: _opts
      };
      const body = await handler(event) || _resSendBody;
      const headers = event.node.res.getHeaders();
      headers.etag = String(
        headers.Etag || headers.etag || `W/"${hash(body)}"`
      );
      headers["last-modified"] = String(
        headers["Last-Modified"] || headers["last-modified"] || (/* @__PURE__ */ new Date()).toUTCString()
      );
      const cacheControl = [];
      if (opts.swr) {
        if (opts.maxAge) {
          cacheControl.push(`s-maxage=${opts.maxAge}`);
        }
        if (opts.staleMaxAge) {
          cacheControl.push(`stale-while-revalidate=${opts.staleMaxAge}`);
        } else {
          cacheControl.push("stale-while-revalidate");
        }
      } else if (opts.maxAge) {
        cacheControl.push(`max-age=${opts.maxAge}`);
      }
      if (cacheControl.length > 0) {
        headers["cache-control"] = cacheControl.join(", ");
      }
      const cacheEntry = {
        code: event.node.res.statusCode,
        headers,
        body
      };
      return cacheEntry;
    },
    _opts
  );
  return defineEventHandler(async (event) => {
    if (opts.headersOnly) {
      if (handleCacheHeaders(event, { maxAge: opts.maxAge })) {
        return;
      }
      return handler(event);
    }
    const response = await _cachedHandler(
      event
    );
    if (event.node.res.headersSent || event.node.res.writableEnded) {
      return response.body;
    }
    if (handleCacheHeaders(event, {
      modifiedTime: new Date(response.headers["last-modified"]),
      etag: response.headers.etag,
      maxAge: opts.maxAge
    })) {
      return;
    }
    event.node.res.statusCode = response.code;
    for (const name in response.headers) {
      const value = response.headers[name];
      if (name === "set-cookie") {
        event.node.res.appendHeader(
          name,
          splitCookiesString(value)
        );
      } else {
        if (value !== void 0) {
          event.node.res.setHeader(name, value);
        }
      }
    }
    return response.body;
  });
}
function cloneWithProxy(obj, overrides) {
  return new Proxy(obj, {
    get(target, property, receiver) {
      if (property in overrides) {
        return overrides[property];
      }
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      if (property in overrides) {
        overrides[property] = value;
        return true;
      }
      return Reflect.set(target, property, value, receiver);
    }
  });
}
const cachedEventHandler = defineCachedEventHandler;

function klona(x) {
	if (typeof x !== 'object') return x;

	var k, tmp, str=Object.prototype.toString.call(x);

	if (str === '[object Object]') {
		if (x.constructor !== Object && typeof x.constructor === 'function') {
			tmp = new x.constructor();
			for (k in x) {
				if (x.hasOwnProperty(k) && tmp[k] !== x[k]) {
					tmp[k] = klona(x[k]);
				}
			}
		} else {
			tmp = {}; // null
			for (k in x) {
				if (k === '__proto__') {
					Object.defineProperty(tmp, k, {
						value: klona(x[k]),
						configurable: true,
						enumerable: true,
						writable: true,
					});
				} else {
					tmp[k] = klona(x[k]);
				}
			}
		}
		return tmp;
	}

	if (str === '[object Array]') {
		k = x.length;
		for (tmp=Array(k); k--;) {
			tmp[k] = klona(x[k]);
		}
		return tmp;
	}

	if (str === '[object Set]') {
		tmp = new Set;
		x.forEach(function (val) {
			tmp.add(klona(val));
		});
		return tmp;
	}

	if (str === '[object Map]') {
		tmp = new Map;
		x.forEach(function (val, key) {
			tmp.set(klona(key), klona(val));
		});
		return tmp;
	}

	if (str === '[object Date]') {
		return new Date(+x);
	}

	if (str === '[object RegExp]') {
		tmp = new RegExp(x.source, x.flags);
		tmp.lastIndex = x.lastIndex;
		return tmp;
	}

	if (str === '[object DataView]') {
		return new x.constructor( klona(x.buffer) );
	}

	if (str === '[object ArrayBuffer]') {
		return x.slice(0);
	}

	// ArrayBuffer.isView(x)
	// ~> `new` bcuz `Buffer.slice` => ref
	if (str.slice(-6) === 'Array]') {
		return new x.constructor(x);
	}

	return x;
}

const inlineAppConfig = {
  "nuxt": {}
};



const appConfig = defuFn(inlineAppConfig);

const NUMBER_CHAR_RE = /\d/;
const STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return void 0;
  }
  return char !== char.toLowerCase();
}
function splitByCase(str, separators) {
  const splitters = STR_SPLITTERS;
  const parts = [];
  if (!str || typeof str !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function kebabCase(str, joiner) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join(joiner) : "";
}
function snakeCase(str) {
  return kebabCase(str || "", "_");
}

function getEnv(key, opts) {
  const envKey = snakeCase(key).toUpperCase();
  return destr(
    process.env[opts.prefix + envKey] ?? process.env[opts.altPrefix + envKey]
  );
}
function _isObject(input) {
  return typeof input === "object" && !Array.isArray(input);
}
function applyEnv(obj, opts, parentKey = "") {
  for (const key in obj) {
    const subKey = parentKey ? `${parentKey}_${key}` : key;
    const envValue = getEnv(subKey, opts);
    if (_isObject(obj[key])) {
      if (_isObject(envValue)) {
        obj[key] = { ...obj[key], ...envValue };
        applyEnv(obj[key], opts, subKey);
      } else if (envValue === void 0) {
        applyEnv(obj[key], opts, subKey);
      } else {
        obj[key] = envValue ?? obj[key];
      }
    } else {
      obj[key] = envValue ?? obj[key];
    }
    if (opts.envExpansion && typeof obj[key] === "string") {
      obj[key] = _expandFromEnv(obj[key]);
    }
  }
  return obj;
}
const envExpandRx = /\{\{([^{}]*)\}\}/g;
function _expandFromEnv(value) {
  return value.replace(envExpandRx, (match, key) => {
    return process.env[key] || match;
  });
}

const _inlineRuntimeConfig = {
  "app": {
    "baseURL": "/",
    "buildId": "b70fb834-de3d-41bd-8a6c-06850d6dcc36",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_",
    "routeRules": {
      "/__nuxt_error": {
        "cache": false,
        "isr": false
      },
      "/**": {
        "headers": {
          "Cross-Origin-Opener-Policy": "same-origin-allow-popups"
        }
      },
      "/_nuxt/builds/meta/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      },
      "/_nuxt/builds/**": {
        "headers": {
          "cache-control": "public, max-age=1, immutable"
        }
      },
      "/_nuxt/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      }
    }
  },
  "public": {
    "fbApiKey": "AIzaSyA18nwqrf9scBsbxUhYD54-lCEhW6fJvQQ",
    "fbAuthDomain": "fb-firebase-74a19.firebaseapp.com"
  },
  "fbProjectId": "fb-firebase-74a19",
  "fbClientEmail": "firebase-adminsdk-fbsvc@fb-firebase-74a19.iam.gserviceaccount.com",
  "fbPrivateKey": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDBxB2W0s9XU9n3\nuJqRO57O2719eiMt913txIyGxw+VyiM81fngbuE0QfA0yQGbZo8aPfA4pUT5CCQf\nqDBYaoclzxyHJvEriNl9uuajxHgZ/VjaEvWqI63Rj1gjAfJV5zGD1KU+xuLq/Ckd\nQmW8D9VyG6uj5aGIolBKNr42smKIkVFvS8VaPjwwESrGamtoqyB+EDu7BFKIiRzG\nHd4EYXTfYqfFZfYI1Yh+KkUoc7OW6w87IlR8HnbnmcA1NQIOpeZoWwY898I/vSwn\nESWr9Obgxlytc59khKaxOb8I0deD2TZO5VK/PA+Xsem7EqA4EwTJgv56iH1lEplQ\n1hHMVTfFAgMBAAECggEAA9U33c2nsdKCmPwRpWN/GPV7COUKohAG5rKLGv46R8OB\nbnAqI4I7zigfe5QvgCgzFsqBRkXxYUSJnjYOkSDPPULuNj1hqvOKq3jHSq7kTnw2\n2mQ0B4bDMp2VfFriTFQIu5izIOv6jxcWztdiax5n4bxCEegn7ILsiYdISBkFkC4H\nAac2XaeJ54Re8lIqieOBwfAw342485l54A50KAjJtBwX45wfSZy6XwA833wweifI\n8zTgdbKNZk2GUj+MYu6ZXjWbRiOmB+96FBmWiPpLAgLZRKctpx4ik3h26FldOFnr\n09z3gZY2sscRXG/UHLN2pC1pMai92pK+Evp/ZPJrwQKBgQD+DEdEemkw974zKTM2\n+ZuhHMGAMxel+DldIRNLuRlk1wVqW6o8QojSAUlUUlXhbRNpIRSQe+tvFyHoqnEo\nQSartVLx5tVYWmjjHZfy+X26XQWWjkq5OKg/r2t4TB9zPqQpZTemD71UyOivfSym\nmvK8+iYWGmqk9WJATmUvV4mlQQKBgQDDQUKxwct/7IaYa/JRvju73LzbHTU4uSPB\n+yMPkw9i1YPQgeq58HKoXkRX7BBflYQdhSh+pqgoOU4HmXm7V5BuTwtAUddbzzFf\n+A77FjkLfFqMqDKsAt+ge2HVmsEZQXoKYj6HMhacM4nX0IY0dqvklqNDunNGxkCZ\nTADIEZodhQKBgF0GpfofUPGLZmxZg9V3pVNjsj99dgViVa8Sc3xg9TmFuwftNPMH\n8g3kRrPHyobXaCow4NTfa6CsOdB2ySTSZpStuwe1XR4TTSENLxzb2vwpH+i3hgk5\nA/L+Cz5rsYCDyZ0W4T+/t7aaMwo/rd/8ETK97sBdP/vTlvyxOEATr+WBAoGBAIuQ\nDhf4qXiam+o+3knHa/Lv6J3F1tDgpMp2s6ziNNE0RK+47QpS7+Gg38DonxtzR6fC\nEhvVC8UUkM2lyfk6saXnIeerl/+rrWMnb63RSJ0JGcAISY/hze5rwpZnszZWMuFR\nL9h62OZ1gEWeaw789AjEE5bJorQn6OyqArT+v+XxAoGBALU2cuklusgFyXc0jbR0\nyoGXL38MZCPdFkrp0PZUpAo9zKPbVApbqCVtNh16HcG5DQz60u5xvn+BjTrSBw2+\n5j1YYzrS5FuOmcCRQBTDquE+pwFuur06akFTvNfw4LIxQqmBQpS4dAkawjEbHnLm\nG1ZeKjQ3J9WQ4bMKqX95Qzow\n-----END PRIVATE KEY-----\n"
};
const envOptions = {
  prefix: "NITRO_",
  altPrefix: _inlineRuntimeConfig.nitro.envPrefix ?? process.env.NITRO_ENV_PREFIX ?? "_",
  envExpansion: _inlineRuntimeConfig.nitro.envExpansion ?? process.env.NITRO_ENV_EXPANSION ?? false
};
const _sharedRuntimeConfig = _deepFreeze(
  applyEnv(klona(_inlineRuntimeConfig), envOptions)
);
function useRuntimeConfig(event) {
  if (!event) {
    return _sharedRuntimeConfig;
  }
  if (event.context.nitro.runtimeConfig) {
    return event.context.nitro.runtimeConfig;
  }
  const runtimeConfig = klona(_inlineRuntimeConfig);
  applyEnv(runtimeConfig, envOptions);
  event.context.nitro.runtimeConfig = runtimeConfig;
  return runtimeConfig;
}
_deepFreeze(klona(appConfig));
function _deepFreeze(object) {
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      _deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
new Proxy(/* @__PURE__ */ Object.create(null), {
  get: (_, prop) => {
    console.warn(
      "Please use `useRuntimeConfig()` instead of accessing config directly."
    );
    const runtimeConfig = useRuntimeConfig();
    if (prop in runtimeConfig) {
      return runtimeConfig[prop];
    }
    return void 0;
  }
});

const config = useRuntimeConfig();
const _routeRulesMatcher = toRouteMatcher(
  createRouter$1({ routes: config.nitro.routeRules })
);
function createRouteRulesHandler(ctx) {
  return eventHandler((event) => {
    const routeRules = getRouteRules(event);
    if (routeRules.headers) {
      setHeaders(event, routeRules.headers);
    }
    if (routeRules.redirect) {
      let target = routeRules.redirect.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.redirect._redirectStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return sendRedirect(event, target, routeRules.redirect.statusCode);
    }
    if (routeRules.proxy) {
      let target = routeRules.proxy.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.proxy._proxyStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return proxyRequest(event, target, {
        fetch: ctx.localFetch,
        ...routeRules.proxy
      });
    }
  });
}
function getRouteRules(event) {
  event.context._nitro = event.context._nitro || {};
  if (!event.context._nitro.routeRules) {
    event.context._nitro.routeRules = getRouteRulesForPath(
      withoutBase(event.path.split("?")[0], useRuntimeConfig().app.baseURL)
    );
  }
  return event.context._nitro.routeRules;
}
function getRouteRulesForPath(path) {
  return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
}

function joinHeaders(value) {
  return Array.isArray(value) ? value.join(", ") : String(value);
}
function normalizeFetchResponse(response) {
  if (!response.headers.has("set-cookie")) {
    return response;
  }
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: normalizeCookieHeaders(response.headers)
  });
}
function normalizeCookieHeader(header = "") {
  return splitCookiesString(joinHeaders(header));
}
function normalizeCookieHeaders(headers) {
  const outgoingHeaders = new Headers();
  for (const [name, header] of headers) {
    if (name === "set-cookie") {
      for (const cookie of normalizeCookieHeader(header)) {
        outgoingHeaders.append("set-cookie", cookie);
      }
    } else {
      outgoingHeaders.set(name, joinHeaders(header));
    }
  }
  return outgoingHeaders;
}

function isJsonRequest(event) {
  if (hasReqHeader(event, "accept", "text/html")) {
    return false;
  }
  return hasReqHeader(event, "accept", "application/json") || hasReqHeader(event, "user-agent", "curl/") || hasReqHeader(event, "user-agent", "httpie/") || hasReqHeader(event, "sec-fetch-mode", "cors") || event.path.startsWith("/api/") || event.path.endsWith(".json");
}
function hasReqHeader(event, name, includes) {
  const value = getRequestHeader(event, name);
  return value && typeof value === "string" && value.toLowerCase().includes(includes);
}

const errorHandler$0 = (async function errorhandler(error, event, { defaultHandler }) {
  if (event.handled || isJsonRequest(event)) {
    return;
  }
  const defaultRes = await defaultHandler(error, event, { json: true });
  const statusCode = error.statusCode || 500;
  if (statusCode === 404 && defaultRes.status === 302) {
    setResponseHeaders(event, defaultRes.headers);
    setResponseStatus(event, defaultRes.status, defaultRes.statusText);
    return send(event, JSON.stringify(defaultRes.body, null, 2));
  }
  const errorObject = defaultRes.body;
  const url = new URL(errorObject.url);
  errorObject.url = withoutBase(url.pathname, useRuntimeConfig(event).app.baseURL) + url.search + url.hash;
  errorObject.message ||= "Server Error";
  errorObject.data ||= error.data;
  errorObject.statusMessage ||= error.statusMessage;
  delete defaultRes.headers["content-type"];
  delete defaultRes.headers["content-security-policy"];
  setResponseHeaders(event, defaultRes.headers);
  const reqHeaders = getRequestHeaders(event);
  const isRenderingError = event.path.startsWith("/__nuxt_error") || !!reqHeaders["x-nuxt-error"];
  const res = isRenderingError ? null : await useNitroApp().localFetch(
    withQuery(joinURL(useRuntimeConfig(event).app.baseURL, "/__nuxt_error"), errorObject),
    {
      headers: { ...reqHeaders, "x-nuxt-error": "true" },
      redirect: "manual"
    }
  ).catch(() => null);
  if (event.handled) {
    return;
  }
  if (!res) {
    const { template } = await Promise.resolve().then(function () { return error500; });
    setResponseHeader(event, "Content-Type", "text/html;charset=UTF-8");
    return send(event, template(errorObject));
  }
  const html = await res.text();
  for (const [header, value] of res.headers.entries()) {
    if (header === "set-cookie") {
      appendResponseHeader(event, header, value);
      continue;
    }
    setResponseHeader(event, header, value);
  }
  setResponseStatus(event, res.status && res.status !== 200 ? res.status : defaultRes.status, res.statusText || defaultRes.statusText);
  return send(event, html);
});

function defineNitroErrorHandler(handler) {
  return handler;
}

const errorHandler$1 = defineNitroErrorHandler(
  function defaultNitroErrorHandler(error, event) {
    const res = defaultHandler(error, event);
    setResponseHeaders(event, res.headers);
    setResponseStatus(event, res.status, res.statusText);
    return send(event, JSON.stringify(res.body, null, 2));
  }
);
function defaultHandler(error, event, opts) {
  const isSensitive = error.unhandled || error.fatal;
  const statusCode = error.statusCode || 500;
  const statusMessage = error.statusMessage || "Server Error";
  const url = getRequestURL(event, { xForwardedHost: true, xForwardedProto: true });
  if (statusCode === 404) {
    const baseURL = "/";
    if (/^\/[^/]/.test(baseURL) && !url.pathname.startsWith(baseURL)) {
      const redirectTo = `${baseURL}${url.pathname.slice(1)}${url.search}`;
      return {
        status: 302,
        statusText: "Found",
        headers: { location: redirectTo },
        body: `Redirecting...`
      };
    }
  }
  if (isSensitive && !opts?.silent) {
    const tags = [error.unhandled && "[unhandled]", error.fatal && "[fatal]"].filter(Boolean).join(" ");
    console.error(`[request error] ${tags} [${event.method}] ${url}
`, error);
  }
  const headers = {
    "content-type": "application/json",
    // Prevent browser from guessing the MIME types of resources.
    "x-content-type-options": "nosniff",
    // Prevent error page from being embedded in an iframe
    "x-frame-options": "DENY",
    // Prevent browsers from sending the Referer header
    "referrer-policy": "no-referrer",
    // Disable the execution of any js
    "content-security-policy": "script-src 'none'; frame-ancestors 'none';"
  };
  setResponseStatus(event, statusCode, statusMessage);
  if (statusCode === 404 || !getResponseHeader(event, "cache-control")) {
    headers["cache-control"] = "no-cache";
  }
  const body = {
    error: true,
    url: url.href,
    statusCode,
    statusMessage,
    message: isSensitive ? "Server Error" : error.message,
    data: isSensitive ? void 0 : error.data
  };
  return {
    status: statusCode,
    statusText: statusMessage,
    headers,
    body
  };
}

const errorHandlers = [errorHandler$0, errorHandler$1];

async function errorHandler(error, event) {
  for (const handler of errorHandlers) {
    try {
      await handler(error, event, { defaultHandler });
      if (event.handled) {
        return; // Response handled
      }
    } catch(error) {
      // Handler itself thrown, log and continue
      console.error(error);
    }
  }
  // H3 will handle fallback
}

function defineNitroPlugin(def) {
  return def;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : "undefined" !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

var firebaseNamespace = {};

var lifecycle = {};

const require$$0$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(fs$1);

var validator$2 = {};

const require$$0$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(url$1);

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(validator$2, "__esModule", { value: true });
validator$2.isTaskId = validator$2.isTopic = validator$2.isURL = validator$2.isUTCDateString = validator$2.isISODateString = validator$2.isPhoneNumber = validator$2.isEmail = validator$2.isPassword = validator$2.isUid = validator$2.isNonNullObject = validator$2.isObject = validator$2.isNonEmptyString = validator$2.isBase64String = validator$2.isString = validator$2.isNumber = validator$2.isBoolean = validator$2.isNonEmptyArray = validator$2.isArray = validator$2.isBuffer = void 0;
const url = require$$0$2;
/**
 * Validates that a value is a byte buffer.
 *
 * @param value - The value to validate.
 * @returns Whether the value is byte buffer or not.
 */
function isBuffer(value) {
    return value instanceof Buffer;
}
validator$2.isBuffer = isBuffer;
/**
 * Validates that a value is an array.
 *
 * @param value - The value to validate.
 * @returns Whether the value is an array or not.
 */
function isArray$1(value) {
    return Array.isArray(value);
}
validator$2.isArray = isArray$1;
/**
 * Validates that a value is a non-empty array.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a non-empty array or not.
 */
function isNonEmptyArray(value) {
    return isArray$1(value) && value.length !== 0;
}
validator$2.isNonEmptyArray = isNonEmptyArray;
/**
 * Validates that a value is a boolean.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a boolean or not.
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
validator$2.isBoolean = isBoolean;
/**
 * Validates that a value is a number.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a number or not.
 */
function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
}
validator$2.isNumber = isNumber;
/**
 * Validates that a value is a string.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a string or not.
 */
function isString$1(value) {
    return typeof value === 'string';
}
validator$2.isString = isString$1;
/**
 * Validates that a value is a base64 string.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a base64 string or not.
 */
function isBase64String(value) {
    if (!isString$1(value)) {
        return false;
    }
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value);
}
validator$2.isBase64String = isBase64String;
/**
 * Validates that a value is a non-empty string.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a non-empty string or not.
 */
function isNonEmptyString(value) {
    return isString$1(value) && value !== '';
}
validator$2.isNonEmptyString = isNonEmptyString;
/**
 * Validates that a value is a nullable object.
 *
 * @param value - The value to validate.
 * @returns Whether the value is an object or not.
 */
function isObject$1(value) {
    return typeof value === 'object' && !isArray$1(value);
}
validator$2.isObject = isObject$1;
/**
 * Validates that a value is a non-null object.
 *
 * @param value - The value to validate.
 * @returns Whether the value is a non-null object or not.
 */
function isNonNullObject(value) {
    return isObject$1(value) && value !== null;
}
validator$2.isNonNullObject = isNonNullObject;
/**
 * Validates that a string is a valid Firebase Auth uid.
 *
 * @param uid - The string to validate.
 * @returns Whether the string is a valid Firebase Auth uid.
 */
function isUid(uid) {
    return typeof uid === 'string' && uid.length > 0 && uid.length <= 128;
}
validator$2.isUid = isUid;
/**
 * Validates that a string is a valid Firebase Auth password.
 *
 * @param password - The password string to validate.
 * @returns Whether the string is a valid Firebase Auth password.
 */
function isPassword(password) {
    // A password must be a string of at least 6 characters.
    return typeof password === 'string' && password.length >= 6;
}
validator$2.isPassword = isPassword;
/**
 * Validates that a string is a valid email.
 *
 * @param email - The string to validate.
 * @returns Whether the string is valid email or not.
 */
function isEmail(email) {
    if (typeof email !== 'string') {
        return false;
    }
    // There must at least one character before the @ symbol and another after.
    const re = /^[^@]+@[^@]+$/;
    return re.test(email);
}
validator$2.isEmail = isEmail;
/**
 * Validates that a string is a valid phone number.
 *
 * @param phoneNumber - The string to validate.
 * @returns Whether the string is a valid phone number or not.
 */
function isPhoneNumber(phoneNumber) {
    if (typeof phoneNumber !== 'string') {
        return false;
    }
    // Phone number validation is very lax here. Backend will enforce E.164
    // spec compliance and will normalize accordingly.
    // The phone number string must be non-empty and starts with a plus sign.
    const re1 = /^\+/;
    // The phone number string must contain at least one alphanumeric character.
    const re2 = /[\da-zA-Z]+/;
    return re1.test(phoneNumber) && re2.test(phoneNumber);
}
validator$2.isPhoneNumber = isPhoneNumber;
/**
 * Validates that a string is a valid ISO date string.
 *
 * @param dateString - The string to validate.
 * @returns Whether the string is a valid ISO date string.
 */
function isISODateString(dateString) {
    try {
        return isNonEmptyString(dateString) &&
            (new Date(dateString).toISOString() === dateString);
    }
    catch (e) {
        return false;
    }
}
validator$2.isISODateString = isISODateString;
/**
 * Validates that a string is a valid UTC date string.
 *
 * @param dateString - The string to validate.
 * @returns Whether the string is a valid UTC date string.
 */
function isUTCDateString(dateString) {
    try {
        return isNonEmptyString(dateString) &&
            (new Date(dateString).toUTCString() === dateString);
    }
    catch (e) {
        return false;
    }
}
validator$2.isUTCDateString = isUTCDateString;
/**
 * Validates that a string is a valid web URL.
 *
 * @param urlStr - The string to validate.
 * @returns Whether the string is valid web URL or not.
 */
function isURL(urlStr) {
    if (typeof urlStr !== 'string') {
        return false;
    }
    // Lookup illegal characters.
    const re = /[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i;
    if (re.test(urlStr)) {
        return false;
    }
    try {
        const uri = url.parse(urlStr);
        const scheme = uri.protocol;
        const slashes = uri.slashes;
        const hostname = uri.hostname;
        const pathname = uri.pathname;
        if ((scheme !== 'http:' && scheme !== 'https:') || !slashes) {
            return false;
        }
        // Validate hostname: Can contain letters, numbers, underscore and dashes separated by a dot.
        // Each zone must not start with a hyphen or underscore.
        if (!hostname || !/^[a-zA-Z0-9]+[\w-]*([.]?[a-zA-Z0-9]+[\w-]*)*$/.test(hostname)) {
            return false;
        }
        // Allow for pathnames: (/chars+)*/?
        // Where chars can be a combination of: a-z A-Z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ %
        const pathnameRe = /^(\/[\w\-.~!$'()*+,;=:@%]+)*\/?$/;
        // Validate pathname.
        if (pathname &&
            pathname !== '/' &&
            !pathnameRe.test(pathname)) {
            return false;
        }
        // Allow any query string and hash as long as no invalid character is used.
    }
    catch (e) {
        return false;
    }
    return true;
}
validator$2.isURL = isURL;
/**
 * Validates that the provided topic is a valid FCM topic name.
 *
 * @param topic - The topic to validate.
 * @returns Whether the provided topic is a valid FCM topic name.
 */
function isTopic(topic) {
    if (typeof topic !== 'string') {
        return false;
    }
    const VALID_TOPIC_REGEX = /^(\/topics\/)?(private\/)?[a-zA-Z0-9-_.~%]+$/;
    return VALID_TOPIC_REGEX.test(topic);
}
validator$2.isTopic = isTopic;
/**
 * Validates that the provided string can be used as a task ID
 * for Cloud Tasks.
 *
 * @param taskId - the task ID to validate.
 * @returns Whether the provided task ID is valid.
 */
function isTaskId(taskId) {
    if (typeof taskId !== 'string') {
        return false;
    }
    const VALID_TASK_ID_REGEX = /^[A-Za-z0-9_-]+$/;
    return VALID_TASK_ID_REGEX.test(taskId);
}
validator$2.isTaskId = isTaskId;

var error = {};

var deepCopy = {};

/*! firebase-admin v12.7.0 */

var hasRequiredDeepCopy;

function requireDeepCopy () {
	if (hasRequiredDeepCopy) return deepCopy;
	hasRequiredDeepCopy = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(deepCopy, "__esModule", { value: true });
	deepCopy.deepExtend = deepCopy.deepCopy = void 0;
	/**
	 * Returns a deep copy of an object or array.
	 *
	 * @param value - The object or array to deep copy.
	 * @returns A deep copy of the provided object or array.
	 */
	function deepCopy$1(value) {
	    return deepExtend(undefined, value);
	}
	deepCopy.deepCopy = deepCopy$1;
	/**
	 * Copies properties from source to target (recursively allows extension of objects and arrays).
	 * Scalar values in the target are over-written. If target is undefined, an object of the
	 * appropriate type will be created (and returned).
	 *
	 * We recursively copy all child properties of plain objects in the source - so that namespace-like
	 * objects are merged.
	 *
	 * Note that the target can be a function, in which case the properties in the source object are
	 * copied onto it as static properties of the function.
	 *
	 * @param target - The value which is being extended.
	 * @param source - The value whose properties are extending the target.
	 * @returns The target value.
	 */
	function deepExtend(target, source) {
	    if (!(source instanceof Object)) {
	        return source;
	    }
	    switch (source.constructor) {
	        case Date: {
	            // Treat Dates like scalars; if the target date object had any child
	            // properties - they will be lost!
	            const dateValue = source;
	            return new Date(dateValue.getTime());
	        }
	        case Object:
	            if (target === undefined) {
	                target = {};
	            }
	            break;
	        case Array:
	            // Always copy the array source and overwrite the target.
	            target = [];
	            break;
	        default:
	            // Not a plain Object - treat it as a scalar.
	            return source;
	    }
	    for (const prop in source) {
	        if (!Object.prototype.hasOwnProperty.call(source, prop)) {
	            continue;
	        }
	        target[prop] = deepExtend(target[prop], source[prop]);
	    }
	    return target;
	}
	deepCopy.deepExtend = deepExtend;
	return deepCopy;
}

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(error, "__esModule", { value: true });
error.InstanceIdClientErrorCode = error.InstallationsClientErrorCode = error.MessagingClientErrorCode = error.AuthClientErrorCode = error.AppErrorCodes = error.FirebaseProjectManagementError = error.FirebaseMessagingError = error.FirebaseInstallationsError = error.FirebaseInstanceIdError = error.FirebaseFirestoreError = error.FirebaseDatabaseError = error.FirebaseAuthError = error.FirebaseAppError = error.PrefixedFirebaseError = error.FirebaseError = void 0;
const deep_copy_1$1 = /*@__PURE__*/ requireDeepCopy();
/**
 * Firebase error code structure. This extends Error.
 */
class FirebaseError extends Error {
    /**
     * @param errorInfo - The error information (code and message).
     * @constructor
     * @internal
     */
    constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseError.prototype;
    }
    /** @returns The error code. */
    get code() {
        return this.errorInfo?.code;
    }
    /** @returns The error message. */
    get message() {
        return this.errorInfo?.message;
    }
    /** @returns The object representation of the error. */
    toJSON() {
        return {
            code: this.code,
            message: this.message,
        };
    }
}
error.FirebaseError = FirebaseError;
/**
 * A FirebaseError with a prefix in front of the error code.
 */
class PrefixedFirebaseError extends FirebaseError {
    /**
     * @param codePrefix - The prefix to apply to the error code.
     * @param code - The error code.
     * @param message - The error message.
     * @constructor
     * @internal
     */
    constructor(codePrefix, code, message) {
        super({
            code: `${codePrefix}/${code}`,
            message,
        });
        this.codePrefix = codePrefix;
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = PrefixedFirebaseError.prototype;
    }
    /**
     * Allows the error type to be checked without needing to know implementation details
     * of the code prefixing.
     *
     * @param code - The non-prefixed error code to test against.
     * @returns True if the code matches, false otherwise.
     */
    hasCode(code) {
        return `${this.codePrefix}/${code}` === this.code;
    }
}
error.PrefixedFirebaseError = PrefixedFirebaseError;
/**
 * Firebase App error code structure. This extends PrefixedFirebaseError.
 */
class FirebaseAppError extends PrefixedFirebaseError {
    /**
     * @param code - The error code.
     * @param message - The error message.
     * @constructor
     * @internal
     */
    constructor(code, message) {
        super('app', code, message);
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseAppError.prototype;
    }
}
error.FirebaseAppError = FirebaseAppError;
/**
 * Firebase Auth error code structure. This extends PrefixedFirebaseError.
 */
class FirebaseAuthError extends PrefixedFirebaseError {
    /**
     * Creates the developer-facing error corresponding to the backend error code.
     *
     * @param serverErrorCode - The server error code.
     * @param [message] The error message. The default message is used
     *     if not provided.
     * @param [rawServerResponse] The error's raw server response.
     * @returns The corresponding developer-facing error.
     * @internal
     */
    static fromServerError(serverErrorCode, message, rawServerResponse) {
        // serverErrorCode could contain additional details:
        // ERROR_CODE : Detailed message which can also contain colons
        const colonSeparator = (serverErrorCode || '').indexOf(':');
        let customMessage = null;
        if (colonSeparator !== -1) {
            customMessage = serverErrorCode.substring(colonSeparator + 1).trim();
            serverErrorCode = serverErrorCode.substring(0, colonSeparator).trim();
        }
        // If not found, default to internal error.
        const clientCodeKey = AUTH_SERVER_TO_CLIENT_CODE[serverErrorCode] || 'INTERNAL_ERROR';
        const error = (0, deep_copy_1$1.deepCopy)(AuthClientErrorCode[clientCodeKey]);
        // Server detailed message should have highest priority.
        error.message = customMessage || message || error.message;
        if (clientCodeKey === 'INTERNAL_ERROR' && typeof rawServerResponse !== 'undefined') {
            try {
                error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
            }
            catch (e) {
                // Ignore JSON parsing error.
            }
        }
        return new FirebaseAuthError(error);
    }
    /**
     * @param info - The error code info.
     * @param message - The error message. This will override the default message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super('auth', info.code, message || info.message);
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseAuthError.prototype;
    }
}
error.FirebaseAuthError = FirebaseAuthError;
/**
 * Firebase Database error code structure. This extends FirebaseError.
 */
class FirebaseDatabaseError extends FirebaseError {
    /**
     * @param info - The error code info.
     * @param message - The error message. This will override the default
     *     message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super({ code: 'database/' + info.code, message: message || info.message });
    }
}
error.FirebaseDatabaseError = FirebaseDatabaseError;
/**
 * Firebase Firestore error code structure. This extends FirebaseError.
 */
class FirebaseFirestoreError extends FirebaseError {
    /**
     * @param info - The error code info.
     * @param message - The error message. This will override the default
     *     message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super({ code: 'firestore/' + info.code, message: message || info.message });
    }
}
error.FirebaseFirestoreError = FirebaseFirestoreError;
/**
 * Firebase instance ID error code structure. This extends FirebaseError.
 */
class FirebaseInstanceIdError extends FirebaseError {
    /**
     *
     * @param info - The error code info.
     * @param message - The error message. This will override the default
     *     message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super({ code: 'instance-id/' + info.code, message: message || info.message });
        this.__proto__ = FirebaseInstanceIdError.prototype;
    }
}
error.FirebaseInstanceIdError = FirebaseInstanceIdError;
/**
 * Firebase Installations service error code structure. This extends `FirebaseError`.
 */
class FirebaseInstallationsError extends FirebaseError {
    /**
     *
     * @param info - The error code info.
     * @param message - The error message. This will override the default
     *     message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super({ code: 'installations/' + info.code, message: message || info.message });
        this.__proto__ = FirebaseInstallationsError.prototype;
    }
}
error.FirebaseInstallationsError = FirebaseInstallationsError;
/**
 * Firebase Messaging error code structure. This extends PrefixedFirebaseError.
 */
class FirebaseMessagingError extends PrefixedFirebaseError {
    /**
     * Creates the developer-facing error corresponding to the backend error code.
     *
     * @param serverErrorCode - The server error code.
     * @param [message] The error message. The default message is used
     *     if not provided.
     * @param [rawServerResponse] The error's raw server response.
     * @returns The corresponding developer-facing error.
     * @internal
     */
    static fromServerError(serverErrorCode, message, rawServerResponse) {
        // If not found, default to unknown error.
        let clientCodeKey = 'UNKNOWN_ERROR';
        if (serverErrorCode && serverErrorCode in MESSAGING_SERVER_TO_CLIENT_CODE) {
            clientCodeKey = MESSAGING_SERVER_TO_CLIENT_CODE[serverErrorCode];
        }
        const error = (0, deep_copy_1$1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error.message = message || error.message;
        if (clientCodeKey === 'UNKNOWN_ERROR' && typeof rawServerResponse !== 'undefined') {
            try {
                error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
            }
            catch (e) {
                // Ignore JSON parsing error.
            }
        }
        return new FirebaseMessagingError(error);
    }
    /**
     * @internal
     */
    static fromTopicManagementServerError(serverErrorCode, message, rawServerResponse) {
        // If not found, default to unknown error.
        const clientCodeKey = TOPIC_MGT_SERVER_TO_CLIENT_CODE[serverErrorCode] || 'UNKNOWN_ERROR';
        const error = (0, deep_copy_1$1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error.message = message || error.message;
        if (clientCodeKey === 'UNKNOWN_ERROR' && typeof rawServerResponse !== 'undefined') {
            try {
                error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
            }
            catch (e) {
                // Ignore JSON parsing error.
            }
        }
        return new FirebaseMessagingError(error);
    }
    /**
     *
     * @param info - The error code info.
     * @param message - The error message. This will override the default message if provided.
     * @constructor
     * @internal
     */
    constructor(info, message) {
        // Override default message if custom message provided.
        super('messaging', info.code, message || info.message);
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseMessagingError.prototype;
    }
}
error.FirebaseMessagingError = FirebaseMessagingError;
/**
 * Firebase project management error code structure. This extends PrefixedFirebaseError.
 */
class FirebaseProjectManagementError extends PrefixedFirebaseError {
    /**
     * @param code - The error code.
     * @param message - The error message.
     * @constructor
     * @internal
     */
    constructor(code, message) {
        super('project-management', code, message);
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseProjectManagementError.prototype;
    }
}
error.FirebaseProjectManagementError = FirebaseProjectManagementError;
/**
 * App client error codes and their default messages.
 */
class AppErrorCodes {
}
error.AppErrorCodes = AppErrorCodes;
AppErrorCodes.APP_DELETED = 'app-deleted';
AppErrorCodes.DUPLICATE_APP = 'duplicate-app';
AppErrorCodes.INVALID_ARGUMENT = 'invalid-argument';
AppErrorCodes.INTERNAL_ERROR = 'internal-error';
AppErrorCodes.INVALID_APP_NAME = 'invalid-app-name';
AppErrorCodes.INVALID_APP_OPTIONS = 'invalid-app-options';
AppErrorCodes.INVALID_CREDENTIAL = 'invalid-credential';
AppErrorCodes.NETWORK_ERROR = 'network-error';
AppErrorCodes.NETWORK_TIMEOUT = 'network-timeout';
AppErrorCodes.NO_APP = 'no-app';
AppErrorCodes.UNABLE_TO_PARSE_RESPONSE = 'unable-to-parse-response';
/**
 * Auth client error codes and their default messages.
 */
class AuthClientErrorCode {
}
error.AuthClientErrorCode = AuthClientErrorCode;
AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED = {
    code: 'auth-blocking-token-expired',
    message: 'The provided Firebase Auth Blocking token is expired.',
};
AuthClientErrorCode.BILLING_NOT_ENABLED = {
    code: 'billing-not-enabled',
    message: 'Feature requires billing to be enabled.',
};
AuthClientErrorCode.CLAIMS_TOO_LARGE = {
    code: 'claims-too-large',
    message: 'Developer claims maximum payload size exceeded.',
};
AuthClientErrorCode.CONFIGURATION_EXISTS = {
    code: 'configuration-exists',
    message: 'A configuration already exists with the provided identifier.',
};
AuthClientErrorCode.CONFIGURATION_NOT_FOUND = {
    code: 'configuration-not-found',
    message: 'There is no configuration corresponding to the provided identifier.',
};
AuthClientErrorCode.ID_TOKEN_EXPIRED = {
    code: 'id-token-expired',
    message: 'The provided Firebase ID token is expired.',
};
AuthClientErrorCode.INVALID_ARGUMENT = {
    code: 'argument-error',
    message: 'Invalid argument provided.',
};
AuthClientErrorCode.INVALID_CONFIG = {
    code: 'invalid-config',
    message: 'The provided configuration is invalid.',
};
AuthClientErrorCode.EMAIL_ALREADY_EXISTS = {
    code: 'email-already-exists',
    message: 'The email address is already in use by another account.',
};
AuthClientErrorCode.EMAIL_NOT_FOUND = {
    code: 'email-not-found',
    message: 'There is no user record corresponding to the provided email.',
};
AuthClientErrorCode.FORBIDDEN_CLAIM = {
    code: 'reserved-claim',
    message: 'The specified developer claim is reserved and cannot be specified.',
};
AuthClientErrorCode.INVALID_ID_TOKEN = {
    code: 'invalid-id-token',
    message: 'The provided ID token is not a valid Firebase ID token.',
};
AuthClientErrorCode.ID_TOKEN_REVOKED = {
    code: 'id-token-revoked',
    message: 'The Firebase ID token has been revoked.',
};
AuthClientErrorCode.INTERNAL_ERROR = {
    code: 'internal-error',
    message: 'An internal error has occurred.',
};
AuthClientErrorCode.INVALID_CLAIMS = {
    code: 'invalid-claims',
    message: 'The provided custom claim attributes are invalid.',
};
AuthClientErrorCode.INVALID_CONTINUE_URI = {
    code: 'invalid-continue-uri',
    message: 'The continue URL must be a valid URL string.',
};
AuthClientErrorCode.INVALID_CREATION_TIME = {
    code: 'invalid-creation-time',
    message: 'The creation time must be a valid UTC date string.',
};
AuthClientErrorCode.INVALID_CREDENTIAL = {
    code: 'invalid-credential',
    message: 'Invalid credential object provided.',
};
AuthClientErrorCode.INVALID_DISABLED_FIELD = {
    code: 'invalid-disabled-field',
    message: 'The disabled field must be a boolean.',
};
AuthClientErrorCode.INVALID_DISPLAY_NAME = {
    code: 'invalid-display-name',
    message: 'The displayName field must be a valid string.',
};
AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN = {
    code: 'invalid-dynamic-link-domain',
    message: 'The provided dynamic link domain is not configured or authorized ' +
        'for the current project.',
};
AuthClientErrorCode.INVALID_EMAIL_VERIFIED = {
    code: 'invalid-email-verified',
    message: 'The emailVerified field must be a boolean.',
};
AuthClientErrorCode.INVALID_EMAIL = {
    code: 'invalid-email',
    message: 'The email address is improperly formatted.',
};
AuthClientErrorCode.INVALID_NEW_EMAIL = {
    code: 'invalid-new-email',
    message: 'The new email address is improperly formatted.',
};
AuthClientErrorCode.INVALID_ENROLLED_FACTORS = {
    code: 'invalid-enrolled-factors',
    message: 'The enrolled factors must be a valid array of MultiFactorInfo objects.',
};
AuthClientErrorCode.INVALID_ENROLLMENT_TIME = {
    code: 'invalid-enrollment-time',
    message: 'The second factor enrollment time must be a valid UTC date string.',
};
AuthClientErrorCode.INVALID_HASH_ALGORITHM = {
    code: 'invalid-hash-algorithm',
    message: 'The hash algorithm must match one of the strings in the list of ' +
        'supported algorithms.',
};
AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE = {
    code: 'invalid-hash-block-size',
    message: 'The hash block size must be a valid number.',
};
AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH = {
    code: 'invalid-hash-derived-key-length',
    message: 'The hash derived key length must be a valid number.',
};
AuthClientErrorCode.INVALID_HASH_KEY = {
    code: 'invalid-hash-key',
    message: 'The hash key must a valid byte buffer.',
};
AuthClientErrorCode.INVALID_HASH_MEMORY_COST = {
    code: 'invalid-hash-memory-cost',
    message: 'The hash memory cost must be a valid number.',
};
AuthClientErrorCode.INVALID_HASH_PARALLELIZATION = {
    code: 'invalid-hash-parallelization',
    message: 'The hash parallelization must be a valid number.',
};
AuthClientErrorCode.INVALID_HASH_ROUNDS = {
    code: 'invalid-hash-rounds',
    message: 'The hash rounds must be a valid number.',
};
AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR = {
    code: 'invalid-hash-salt-separator',
    message: 'The hashing algorithm salt separator field must be a valid byte buffer.',
};
AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME = {
    code: 'invalid-last-sign-in-time',
    message: 'The last sign-in time must be a valid UTC date string.',
};
AuthClientErrorCode.INVALID_NAME = {
    code: 'invalid-name',
    message: 'The resource name provided is invalid.',
};
AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID = {
    code: 'invalid-oauth-client-id',
    message: 'The provided OAuth client ID is invalid.',
};
AuthClientErrorCode.INVALID_PAGE_TOKEN = {
    code: 'invalid-page-token',
    message: 'The page token must be a valid non-empty string.',
};
AuthClientErrorCode.INVALID_PASSWORD = {
    code: 'invalid-password',
    message: 'The password must be a string with at least 6 characters.',
};
AuthClientErrorCode.INVALID_PASSWORD_HASH = {
    code: 'invalid-password-hash',
    message: 'The password hash must be a valid byte buffer.',
};
AuthClientErrorCode.INVALID_PASSWORD_SALT = {
    code: 'invalid-password-salt',
    message: 'The password salt must be a valid byte buffer.',
};
AuthClientErrorCode.INVALID_PHONE_NUMBER = {
    code: 'invalid-phone-number',
    message: 'The phone number must be a non-empty E.164 standard compliant identifier ' +
        'string.',
};
AuthClientErrorCode.INVALID_PHOTO_URL = {
    code: 'invalid-photo-url',
    message: 'The photoURL field must be a valid URL.',
};
AuthClientErrorCode.INVALID_PROJECT_ID = {
    code: 'invalid-project-id',
    message: 'Invalid parent project. Either parent project doesn\'t exist or didn\'t enable multi-tenancy.',
};
AuthClientErrorCode.INVALID_PROVIDER_DATA = {
    code: 'invalid-provider-data',
    message: 'The providerData must be a valid array of UserInfo objects.',
};
AuthClientErrorCode.INVALID_PROVIDER_ID = {
    code: 'invalid-provider-id',
    message: 'The providerId must be a valid supported provider identifier string.',
};
AuthClientErrorCode.INVALID_PROVIDER_UID = {
    code: 'invalid-provider-uid',
    message: 'The providerUid must be a valid provider uid string.',
};
AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE = {
    code: 'invalid-oauth-responsetype',
    message: 'Only exactly one OAuth responseType should be set to true.',
};
AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION = {
    code: 'invalid-session-cookie-duration',
    message: 'The session cookie duration must be a valid number in milliseconds ' +
        'between 5 minutes and 2 weeks.',
};
AuthClientErrorCode.INVALID_TENANT_ID = {
    code: 'invalid-tenant-id',
    message: 'The tenant ID must be a valid non-empty string.',
};
AuthClientErrorCode.INVALID_TENANT_TYPE = {
    code: 'invalid-tenant-type',
    message: 'Tenant type must be either "full_service" or "lightweight".',
};
AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER = {
    code: 'invalid-testing-phone-number',
    message: 'Invalid testing phone number or invalid test code provided.',
};
AuthClientErrorCode.INVALID_UID = {
    code: 'invalid-uid',
    message: 'The uid must be a non-empty string with at most 128 characters.',
};
AuthClientErrorCode.INVALID_USER_IMPORT = {
    code: 'invalid-user-import',
    message: 'The user record to import is invalid.',
};
AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME = {
    code: 'invalid-tokens-valid-after-time',
    message: 'The tokensValidAfterTime must be a valid UTC number in seconds.',
};
AuthClientErrorCode.MISMATCHING_TENANT_ID = {
    code: 'mismatching-tenant-id',
    message: 'User tenant ID does not match with the current TenantAwareAuth tenant ID.',
};
AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME = {
    code: 'missing-android-pkg-name',
    message: 'An Android Package Name must be provided if the Android App is ' +
        'required to be installed.',
};
AuthClientErrorCode.MISSING_CONFIG = {
    code: 'missing-config',
    message: 'The provided configuration is missing required attributes.',
};
AuthClientErrorCode.MISSING_CONTINUE_URI = {
    code: 'missing-continue-uri',
    message: 'A valid continue URL must be provided in the request.',
};
AuthClientErrorCode.MISSING_DISPLAY_NAME = {
    code: 'missing-display-name',
    message: 'The resource being created or edited is missing a valid display name.',
};
AuthClientErrorCode.MISSING_EMAIL = {
    code: 'missing-email',
    message: 'The email is required for the specified action. For example, a multi-factor user ' +
        'requires a verified email.',
};
AuthClientErrorCode.MISSING_IOS_BUNDLE_ID = {
    code: 'missing-ios-bundle-id',
    message: 'The request is missing an iOS Bundle ID.',
};
AuthClientErrorCode.MISSING_ISSUER = {
    code: 'missing-issuer',
    message: 'The OAuth/OIDC configuration issuer must not be empty.',
};
AuthClientErrorCode.MISSING_HASH_ALGORITHM = {
    code: 'missing-hash-algorithm',
    message: 'Importing users with password hashes requires that the hashing ' +
        'algorithm and its parameters be provided.',
};
AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID = {
    code: 'missing-oauth-client-id',
    message: 'The OAuth/OIDC configuration client ID must not be empty.',
};
AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET = {
    code: 'missing-oauth-client-secret',
    message: 'The OAuth configuration client secret is required to enable OIDC code flow.',
};
AuthClientErrorCode.MISSING_PROVIDER_ID = {
    code: 'missing-provider-id',
    message: 'A valid provider ID must be provided in the request.',
};
AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG = {
    code: 'missing-saml-relying-party-config',
    message: 'The SAML configuration provided is missing a relying party configuration.',
};
AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED = {
    code: 'test-phone-number-limit-exceeded',
    message: 'The maximum allowed number of test phone number / code pairs has been exceeded.',
};
AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED = {
    code: 'maximum-user-count-exceeded',
    message: 'The maximum allowed number of users to import has been exceeded.',
};
AuthClientErrorCode.MISSING_UID = {
    code: 'missing-uid',
    message: 'A uid identifier is required for the current operation.',
};
AuthClientErrorCode.OPERATION_NOT_ALLOWED = {
    code: 'operation-not-allowed',
    message: 'The given sign-in provider is disabled for this Firebase project. ' +
        'Enable it in the Firebase console, under the sign-in method tab of the ' +
        'Auth section.',
};
AuthClientErrorCode.PHONE_NUMBER_ALREADY_EXISTS = {
    code: 'phone-number-already-exists',
    message: 'The user with the provided phone number already exists.',
};
AuthClientErrorCode.PROJECT_NOT_FOUND = {
    code: 'project-not-found',
    message: 'No Firebase project was found for the provided credential.',
};
AuthClientErrorCode.INSUFFICIENT_PERMISSION = {
    code: 'insufficient-permission',
    message: 'Credential implementation provided to initializeApp() via the "credential" property ' +
        'has insufficient permission to access the requested resource. See ' +
        'https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK ' +
        'with appropriate permissions.',
};
AuthClientErrorCode.QUOTA_EXCEEDED = {
    code: 'quota-exceeded',
    message: 'The project quota for the specified operation has been exceeded.',
};
AuthClientErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED = {
    code: 'second-factor-limit-exceeded',
    message: 'The maximum number of allowed second factors on a user has been exceeded.',
};
AuthClientErrorCode.SECOND_FACTOR_UID_ALREADY_EXISTS = {
    code: 'second-factor-uid-already-exists',
    message: 'The specified second factor "uid" already exists.',
};
AuthClientErrorCode.SESSION_COOKIE_EXPIRED = {
    code: 'session-cookie-expired',
    message: 'The Firebase session cookie is expired.',
};
AuthClientErrorCode.SESSION_COOKIE_REVOKED = {
    code: 'session-cookie-revoked',
    message: 'The Firebase session cookie has been revoked.',
};
AuthClientErrorCode.TENANT_NOT_FOUND = {
    code: 'tenant-not-found',
    message: 'There is no tenant corresponding to the provided identifier.',
};
AuthClientErrorCode.UID_ALREADY_EXISTS = {
    code: 'uid-already-exists',
    message: 'The user with the provided uid already exists.',
};
AuthClientErrorCode.UNAUTHORIZED_DOMAIN = {
    code: 'unauthorized-continue-uri',
    message: 'The domain of the continue URL is not whitelisted. Whitelist the domain in the ' +
        'Firebase console.',
};
AuthClientErrorCode.UNSUPPORTED_FIRST_FACTOR = {
    code: 'unsupported-first-factor',
    message: 'A multi-factor user requires a supported first factor.',
};
AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR = {
    code: 'unsupported-second-factor',
    message: 'The request specified an unsupported type of second factor.',
};
AuthClientErrorCode.UNSUPPORTED_TENANT_OPERATION = {
    code: 'unsupported-tenant-operation',
    message: 'This operation is not supported in a multi-tenant context.',
};
AuthClientErrorCode.UNVERIFIED_EMAIL = {
    code: 'unverified-email',
    message: 'A verified email is required for the specified action. For example, a multi-factor user ' +
        'requires a verified email.',
};
AuthClientErrorCode.USER_NOT_FOUND = {
    code: 'user-not-found',
    message: 'There is no user record corresponding to the provided identifier.',
};
AuthClientErrorCode.NOT_FOUND = {
    code: 'not-found',
    message: 'The requested resource was not found.',
};
AuthClientErrorCode.USER_DISABLED = {
    code: 'user-disabled',
    message: 'The user record is disabled.',
};
AuthClientErrorCode.USER_NOT_DISABLED = {
    code: 'user-not-disabled',
    message: 'The user must be disabled in order to bulk delete it (or you must pass force=true).',
};
AuthClientErrorCode.INVALID_RECAPTCHA_ACTION = {
    code: 'invalid-recaptcha-action',
    message: 'reCAPTCHA action must be "BLOCK".'
};
AuthClientErrorCode.INVALID_RECAPTCHA_ENFORCEMENT_STATE = {
    code: 'invalid-recaptcha-enforcement-state',
    message: 'reCAPTCHA enforcement state must be either "OFF", "AUDIT" or "ENFORCE".'
};
AuthClientErrorCode.RECAPTCHA_NOT_ENABLED = {
    code: 'racaptcha-not-enabled',
    message: 'reCAPTCHA enterprise is not enabled.'
};
/**
 * Messaging client error codes and their default messages.
 */
class MessagingClientErrorCode {
}
error.MessagingClientErrorCode = MessagingClientErrorCode;
MessagingClientErrorCode.INVALID_ARGUMENT = {
    code: 'invalid-argument',
    message: 'Invalid argument provided.',
};
MessagingClientErrorCode.INVALID_RECIPIENT = {
    code: 'invalid-recipient',
    message: 'Invalid message recipient provided.',
};
MessagingClientErrorCode.INVALID_PAYLOAD = {
    code: 'invalid-payload',
    message: 'Invalid message payload provided.',
};
MessagingClientErrorCode.INVALID_DATA_PAYLOAD_KEY = {
    code: 'invalid-data-payload-key',
    message: 'The data message payload contains an invalid key. See the reference documentation ' +
        'for the DataMessagePayload type for restricted keys.',
};
MessagingClientErrorCode.PAYLOAD_SIZE_LIMIT_EXCEEDED = {
    code: 'payload-size-limit-exceeded',
    message: 'The provided message payload exceeds the FCM size limits. See the error documentation ' +
        'for more details.',
};
MessagingClientErrorCode.INVALID_OPTIONS = {
    code: 'invalid-options',
    message: 'Invalid message options provided.',
};
MessagingClientErrorCode.INVALID_REGISTRATION_TOKEN = {
    code: 'invalid-registration-token',
    message: 'Invalid registration token provided. Make sure it matches the registration token ' +
        'the client app receives from registering with FCM.',
};
MessagingClientErrorCode.REGISTRATION_TOKEN_NOT_REGISTERED = {
    code: 'registration-token-not-registered',
    message: 'The provided registration token is not registered. A previously valid registration ' +
        'token can be unregistered for a variety of reasons. See the error documentation for more ' +
        'details. Remove this registration token and stop using it to send messages.',
};
MessagingClientErrorCode.MISMATCHED_CREDENTIAL = {
    code: 'mismatched-credential',
    message: 'The credential used to authenticate this SDK does not have permission to send ' +
        'messages to the device corresponding to the provided registration token. Make sure the ' +
        'credential and registration token both belong to the same Firebase project.',
};
MessagingClientErrorCode.INVALID_PACKAGE_NAME = {
    code: 'invalid-package-name',
    message: 'The message was addressed to a registration token whose package name does not match ' +
        'the provided "restrictedPackageName" option.',
};
MessagingClientErrorCode.DEVICE_MESSAGE_RATE_EXCEEDED = {
    code: 'device-message-rate-exceeded',
    message: 'The rate of messages to a particular device is too high. Reduce the number of ' +
        'messages sent to this device and do not immediately retry sending to this device.',
};
MessagingClientErrorCode.TOPICS_MESSAGE_RATE_EXCEEDED = {
    code: 'topics-message-rate-exceeded',
    message: 'The rate of messages to subscribers to a particular topic is too high. Reduce the ' +
        'number of messages sent for this topic, and do not immediately retry sending to this topic.',
};
MessagingClientErrorCode.MESSAGE_RATE_EXCEEDED = {
    code: 'message-rate-exceeded',
    message: 'Sending limit exceeded for the message target.',
};
MessagingClientErrorCode.THIRD_PARTY_AUTH_ERROR = {
    code: 'third-party-auth-error',
    message: 'A message targeted to an iOS device could not be sent because the required APNs ' +
        'SSL certificate was not uploaded or has expired. Check the validity of your development ' +
        'and production certificates.',
};
MessagingClientErrorCode.TOO_MANY_TOPICS = {
    code: 'too-many-topics',
    message: 'The maximum number of topics the provided registration token can be subscribed to ' +
        'has been exceeded.',
};
MessagingClientErrorCode.AUTHENTICATION_ERROR = {
    code: 'authentication-error',
    message: 'An error occurred when trying to authenticate to the FCM servers. Make sure the ' +
        'credential used to authenticate this SDK has the proper permissions. See ' +
        'https://firebase.google.com/docs/admin/setup for setup instructions.',
};
MessagingClientErrorCode.SERVER_UNAVAILABLE = {
    code: 'server-unavailable',
    message: 'The FCM server could not process the request in time. See the error documentation ' +
        'for more details.',
};
MessagingClientErrorCode.INTERNAL_ERROR = {
    code: 'internal-error',
    message: 'An internal error has occurred. Please retry the request.',
};
MessagingClientErrorCode.UNKNOWN_ERROR = {
    code: 'unknown-error',
    message: 'An unknown server error was returned.',
};
class InstallationsClientErrorCode {
}
error.InstallationsClientErrorCode = InstallationsClientErrorCode;
InstallationsClientErrorCode.INVALID_ARGUMENT = {
    code: 'invalid-argument',
    message: 'Invalid argument provided.',
};
InstallationsClientErrorCode.INVALID_PROJECT_ID = {
    code: 'invalid-project-id',
    message: 'Invalid project ID provided.',
};
InstallationsClientErrorCode.INVALID_INSTALLATION_ID = {
    code: 'invalid-installation-id',
    message: 'Invalid installation ID provided.',
};
InstallationsClientErrorCode.API_ERROR = {
    code: 'api-error',
    message: 'Installation ID API call failed.',
};
class InstanceIdClientErrorCode extends InstallationsClientErrorCode {
}
error.InstanceIdClientErrorCode = InstanceIdClientErrorCode;
InstanceIdClientErrorCode.INVALID_INSTANCE_ID = {
    code: 'invalid-instance-id',
    message: 'Invalid instance ID provided.',
};
/** @const {ServerToClientCode} Auth server to client enum error codes. */
const AUTH_SERVER_TO_CLIENT_CODE = {
    // Feature being configured or used requires a billing account.
    BILLING_NOT_ENABLED: 'BILLING_NOT_ENABLED',
    // Claims payload is too large.
    CLAIMS_TOO_LARGE: 'CLAIMS_TOO_LARGE',
    // Configuration being added already exists.
    CONFIGURATION_EXISTS: 'CONFIGURATION_EXISTS',
    // Configuration not found.
    CONFIGURATION_NOT_FOUND: 'CONFIGURATION_NOT_FOUND',
    // Provided credential has insufficient permissions.
    INSUFFICIENT_PERMISSION: 'INSUFFICIENT_PERMISSION',
    // Provided configuration has invalid fields.
    INVALID_CONFIG: 'INVALID_CONFIG',
    // Provided configuration identifier is invalid.
    INVALID_CONFIG_ID: 'INVALID_PROVIDER_ID',
    // ActionCodeSettings missing continue URL.
    INVALID_CONTINUE_URI: 'INVALID_CONTINUE_URI',
    // Dynamic link domain in provided ActionCodeSettings is not authorized.
    INVALID_DYNAMIC_LINK_DOMAIN: 'INVALID_DYNAMIC_LINK_DOMAIN',
    // uploadAccount provides an email that already exists.
    DUPLICATE_EMAIL: 'EMAIL_ALREADY_EXISTS',
    // uploadAccount provides a localId that already exists.
    DUPLICATE_LOCAL_ID: 'UID_ALREADY_EXISTS',
    // Request specified a multi-factor enrollment ID that already exists.
    DUPLICATE_MFA_ENROLLMENT_ID: 'SECOND_FACTOR_UID_ALREADY_EXISTS',
    // setAccountInfo email already exists.
    EMAIL_EXISTS: 'EMAIL_ALREADY_EXISTS',
    // /accounts:sendOobCode for password reset when user is not found.
    EMAIL_NOT_FOUND: 'EMAIL_NOT_FOUND',
    // Reserved claim name.
    FORBIDDEN_CLAIM: 'FORBIDDEN_CLAIM',
    // Invalid claims provided.
    INVALID_CLAIMS: 'INVALID_CLAIMS',
    // Invalid session cookie duration.
    INVALID_DURATION: 'INVALID_SESSION_COOKIE_DURATION',
    // Invalid email provided.
    INVALID_EMAIL: 'INVALID_EMAIL',
    // Invalid new email provided.
    INVALID_NEW_EMAIL: 'INVALID_NEW_EMAIL',
    // Invalid tenant display name. This can be thrown on CreateTenant and UpdateTenant.
    INVALID_DISPLAY_NAME: 'INVALID_DISPLAY_NAME',
    // Invalid ID token provided.
    INVALID_ID_TOKEN: 'INVALID_ID_TOKEN',
    // Invalid tenant/parent resource name.
    INVALID_NAME: 'INVALID_NAME',
    // OIDC configuration has an invalid OAuth client ID.
    INVALID_OAUTH_CLIENT_ID: 'INVALID_OAUTH_CLIENT_ID',
    // Invalid page token.
    INVALID_PAGE_SELECTION: 'INVALID_PAGE_TOKEN',
    // Invalid phone number.
    INVALID_PHONE_NUMBER: 'INVALID_PHONE_NUMBER',
    // Invalid agent project. Either agent project doesn't exist or didn't enable multi-tenancy.
    INVALID_PROJECT_ID: 'INVALID_PROJECT_ID',
    // Invalid provider ID.
    INVALID_PROVIDER_ID: 'INVALID_PROVIDER_ID',
    // Invalid service account.
    INVALID_SERVICE_ACCOUNT: 'INVALID_SERVICE_ACCOUNT',
    // Invalid testing phone number.
    INVALID_TESTING_PHONE_NUMBER: 'INVALID_TESTING_PHONE_NUMBER',
    // Invalid tenant type.
    INVALID_TENANT_TYPE: 'INVALID_TENANT_TYPE',
    // Missing Android package name.
    MISSING_ANDROID_PACKAGE_NAME: 'MISSING_ANDROID_PACKAGE_NAME',
    // Missing configuration.
    MISSING_CONFIG: 'MISSING_CONFIG',
    // Missing configuration identifier.
    MISSING_CONFIG_ID: 'MISSING_PROVIDER_ID',
    // Missing tenant display name: This can be thrown on CreateTenant and UpdateTenant.
    MISSING_DISPLAY_NAME: 'MISSING_DISPLAY_NAME',
    // Email is required for the specified action. For example a multi-factor user requires
    // a verified email.
    MISSING_EMAIL: 'MISSING_EMAIL',
    // Missing iOS bundle ID.
    MISSING_IOS_BUNDLE_ID: 'MISSING_IOS_BUNDLE_ID',
    // Missing OIDC issuer.
    MISSING_ISSUER: 'MISSING_ISSUER',
    // No localId provided (deleteAccount missing localId).
    MISSING_LOCAL_ID: 'MISSING_UID',
    // OIDC configuration is missing an OAuth client ID.
    MISSING_OAUTH_CLIENT_ID: 'MISSING_OAUTH_CLIENT_ID',
    // Missing provider ID.
    MISSING_PROVIDER_ID: 'MISSING_PROVIDER_ID',
    // Missing SAML RP config.
    MISSING_SAML_RELYING_PARTY_CONFIG: 'MISSING_SAML_RELYING_PARTY_CONFIG',
    // Empty user list in uploadAccount.
    MISSING_USER_ACCOUNT: 'MISSING_UID',
    // Password auth disabled in console.
    OPERATION_NOT_ALLOWED: 'OPERATION_NOT_ALLOWED',
    // Provided credential has insufficient permissions.
    PERMISSION_DENIED: 'INSUFFICIENT_PERMISSION',
    // Phone number already exists.
    PHONE_NUMBER_EXISTS: 'PHONE_NUMBER_ALREADY_EXISTS',
    // Project not found.
    PROJECT_NOT_FOUND: 'PROJECT_NOT_FOUND',
    // In multi-tenancy context: project creation quota exceeded.
    QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
    // Currently only 5 second factors can be set on the same user.
    SECOND_FACTOR_LIMIT_EXCEEDED: 'SECOND_FACTOR_LIMIT_EXCEEDED',
    // Tenant not found.
    TENANT_NOT_FOUND: 'TENANT_NOT_FOUND',
    // Tenant ID mismatch.
    TENANT_ID_MISMATCH: 'MISMATCHING_TENANT_ID',
    // Token expired error.
    TOKEN_EXPIRED: 'ID_TOKEN_EXPIRED',
    // Continue URL provided in ActionCodeSettings has a domain that is not whitelisted.
    UNAUTHORIZED_DOMAIN: 'UNAUTHORIZED_DOMAIN',
    // A multi-factor user requires a supported first factor.
    UNSUPPORTED_FIRST_FACTOR: 'UNSUPPORTED_FIRST_FACTOR',
    // The request specified an unsupported type of second factor.
    UNSUPPORTED_SECOND_FACTOR: 'UNSUPPORTED_SECOND_FACTOR',
    // Operation is not supported in a multi-tenant context.
    UNSUPPORTED_TENANT_OPERATION: 'UNSUPPORTED_TENANT_OPERATION',
    // A verified email is required for the specified action. For example a multi-factor user
    // requires a verified email.
    UNVERIFIED_EMAIL: 'UNVERIFIED_EMAIL',
    // User on which action is to be performed is not found.
    USER_NOT_FOUND: 'USER_NOT_FOUND',
    // User record is disabled.
    USER_DISABLED: 'USER_DISABLED',
    // Password provided is too weak.
    WEAK_PASSWORD: 'INVALID_PASSWORD',
    // Unrecognized reCAPTCHA action.
    INVALID_RECAPTCHA_ACTION: 'INVALID_RECAPTCHA_ACTION',
    // Unrecognized reCAPTCHA enforcement state.
    INVALID_RECAPTCHA_ENFORCEMENT_STATE: 'INVALID_RECAPTCHA_ENFORCEMENT_STATE',
    // reCAPTCHA is not enabled for account defender.
    RECAPTCHA_NOT_ENABLED: 'RECAPTCHA_NOT_ENABLED'
};
/** @const {ServerToClientCode} Messaging server to client enum error codes. */
const MESSAGING_SERVER_TO_CLIENT_CODE = {
    /* GENERIC ERRORS */
    // Generic invalid message parameter provided.
    InvalidParameters: 'INVALID_ARGUMENT',
    // Mismatched sender ID.
    MismatchSenderId: 'MISMATCHED_CREDENTIAL',
    // FCM server unavailable.
    Unavailable: 'SERVER_UNAVAILABLE',
    // FCM server internal error.
    InternalServerError: 'INTERNAL_ERROR',
    /* SEND ERRORS */
    // Invalid registration token format.
    InvalidRegistration: 'INVALID_REGISTRATION_TOKEN',
    // Registration token is not registered.
    NotRegistered: 'REGISTRATION_TOKEN_NOT_REGISTERED',
    // Registration token does not match restricted package name.
    InvalidPackageName: 'INVALID_PACKAGE_NAME',
    // Message payload size limit exceeded.
    MessageTooBig: 'PAYLOAD_SIZE_LIMIT_EXCEEDED',
    // Invalid key in the data message payload.
    InvalidDataKey: 'INVALID_DATA_PAYLOAD_KEY',
    // Invalid time to live option.
    InvalidTtl: 'INVALID_OPTIONS',
    // Device message rate exceeded.
    DeviceMessageRateExceeded: 'DEVICE_MESSAGE_RATE_EXCEEDED',
    // Topics message rate exceeded.
    TopicsMessageRateExceeded: 'TOPICS_MESSAGE_RATE_EXCEEDED',
    // Invalid APNs credentials.
    InvalidApnsCredential: 'THIRD_PARTY_AUTH_ERROR',
    /* FCM v1 canonical error codes */
    NOT_FOUND: 'REGISTRATION_TOKEN_NOT_REGISTERED',
    PERMISSION_DENIED: 'MISMATCHED_CREDENTIAL',
    RESOURCE_EXHAUSTED: 'MESSAGE_RATE_EXCEEDED',
    UNAUTHENTICATED: 'THIRD_PARTY_AUTH_ERROR',
    /* FCM v1 new error codes */
    APNS_AUTH_ERROR: 'THIRD_PARTY_AUTH_ERROR',
    INTERNAL: 'INTERNAL_ERROR',
    INVALID_ARGUMENT: 'INVALID_ARGUMENT',
    QUOTA_EXCEEDED: 'MESSAGE_RATE_EXCEEDED',
    SENDER_ID_MISMATCH: 'MISMATCHED_CREDENTIAL',
    THIRD_PARTY_AUTH_ERROR: 'THIRD_PARTY_AUTH_ERROR',
    UNAVAILABLE: 'SERVER_UNAVAILABLE',
    UNREGISTERED: 'REGISTRATION_TOKEN_NOT_REGISTERED',
    UNSPECIFIED_ERROR: 'UNKNOWN_ERROR',
};
/** @const {ServerToClientCode} Topic management (IID) server to client enum error codes. */
const TOPIC_MGT_SERVER_TO_CLIENT_CODE = {
    /* TOPIC SUBSCRIPTION MANAGEMENT ERRORS */
    NOT_FOUND: 'REGISTRATION_TOKEN_NOT_REGISTERED',
    INVALID_ARGUMENT: 'INVALID_REGISTRATION_TOKEN',
    TOO_MANY_TOPICS: 'TOO_MANY_TOPICS',
    RESOURCE_EXHAUSTED: 'TOO_MANY_TOPICS',
    PERMISSION_DENIED: 'AUTHENTICATION_ERROR',
    DEADLINE_EXCEEDED: 'SERVER_UNAVAILABLE',
    INTERNAL: 'INTERNAL_ERROR',
    UNKNOWN: 'UNKNOWN_ERROR',
};

var credentialInternal = {};

const require$$1$5 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(os$1);

const require$$1$4 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(path$1);

var apiRequest = {};

const require$$2$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(http);

const require$$3$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(https);

const require$$4$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(http2);

const require$$6 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(events);

var main = {exports: {}};

const require$$3$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(node_stream);

const require$$1$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(node_util);

const require$$0$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(node_events);

var sbmh;
var hasRequiredSbmh;

function requireSbmh () {
	if (hasRequiredSbmh) return sbmh;
	hasRequiredSbmh = 1;

	/**
	 * Copyright Brian White. All rights reserved.
	 *
	 * @see https://github.com/mscdex/streamsearch
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	 */

	const { EventEmitter } = require$$0$1;
	const { inherits } = require$$1$3;

	function SBMH (needle) {
	  if (typeof needle === 'string') {
	    needle = Buffer.from(needle);
	  }

	  if (!Buffer.isBuffer(needle)) {
	    throw new TypeError('The needle has to be a String or a Buffer.')
	  }

	  const needleLength = needle.length;
	  const needleLastCharIndex = needleLength - 1;

	  if (needleLength === 0) {
	    throw new Error('The needle cannot be an empty String/Buffer.')
	  }

	  if (needleLength > 256) {
	    throw new Error('The needle cannot have a length bigger than 256.')
	  }

	  this.maxMatches = Infinity;
	  this.matches = 0;

	  this._occ = new Uint8Array(256)
	    .fill(needleLength); // Initialize occurrence table.
	  this._lookbehind_size = 0;
	  this._needle = needle;
	  this._bufpos = 0;

	  this._lookbehind = Buffer.alloc(needleLastCharIndex);

	  // Populate occurrence table with analysis of the needle,
	  // ignoring last letter.
	  for (var i = 0; i < needleLastCharIndex; ++i) { // eslint-disable-line no-var
	    this._occ[needle[i]] = needleLastCharIndex - i;
	  }
	}
	inherits(SBMH, EventEmitter);

	SBMH.prototype.reset = function () {
	  this._lookbehind_size = 0;
	  this.matches = 0;
	  this._bufpos = 0;
	};

	SBMH.prototype.push = function (chunk, pos) {
	  if (!Buffer.isBuffer(chunk)) {
	    chunk = Buffer.from(chunk, 'binary');
	  }
	  const chlen = chunk.length;
	  this._bufpos = pos || 0;
	  let r;
	  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk); }
	  return r
	};

	SBMH.prototype._sbmh_feed = function (data) {
	  const len = data.length;
	  const needle = this._needle;
	  const needleLength = needle.length;
	  const needleLastCharIndex = needleLength - 1;
	  const needleLastChar = needle[needleLastCharIndex];

	  // Positive: points to a position in `data`
	  //           pos == 3 points to data[3]
	  // Negative: points to a position in the lookbehind buffer
	  //           pos == -2 points to lookbehind[lookbehind_size - 2]
	  let pos = -this._lookbehind_size;
	  let ch;

	  if (pos < 0) {
	    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
	    // search with character lookup code that considers both the
	    // lookbehind buffer and the current round's haystack data.
	    //
	    // Loop until
	    //   there is a match.
	    // or until
	    //   we've moved past the position that requires the
	    //   lookbehind buffer. In this case we switch to the
	    //   optimized loop.
	    // or until
	    //   the character to look at lies outside the haystack.
	    while (pos < 0 && pos <= len - needleLength) {
	      ch = data[pos + needleLastCharIndex];

	      if (
	        ch === needleLastChar &&
	        this._sbmh_memcmp(data, pos, needleLastCharIndex)
	      ) {
	        this._lookbehind_size = 0;
	        ++this.matches;
	        this.emit('info', true);
	        return (this._bufpos = pos + needleLength)
	      }

	      pos += this._occ[ch];
	    }

	    // No match.

	    while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
	      // There's too few data for Boyer-Moore-Horspool to run,
	      // so let's use a different algorithm to skip as much as
	      // we can.
	      // Forward pos until
	      //   the trailing part of lookbehind + data
	      //   looks like the beginning of the needle
	      // or until
	      //   pos == 0
	      ++pos;
	    }

	    if (pos >= 0) {
	      // Discard lookbehind buffer.
	      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
	      this._lookbehind_size = 0;
	    } else {
	      // Cut off part of the lookbehind buffer that has
	      // been processed and append the entire haystack
	      // into it.
	      const bytesToCutOff = this._lookbehind_size + pos;
	      if (bytesToCutOff > 0) {
	        // The cut off data is guaranteed not to contain the needle.
	        this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
	      }

	      this._lookbehind_size -= bytesToCutOff;
	      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size);

	      data.copy(this._lookbehind, this._lookbehind_size);
	      this._lookbehind_size += len;

	      this._bufpos = len;
	      return len
	    }
	  }

	  // Lookbehind buffer is now empty. We only need to check if the
	  // needle is in the haystack.
	  pos = data.indexOf(needle, pos + this._bufpos);

	  if (pos !== -1) {
	    ++this.matches;
	    if (pos === 0) { this.emit('info', true); } else { this.emit('info', true, data, this._bufpos, pos); }
	    return (this._bufpos = pos + needleLength)
	  }

	  pos = len - needleLastCharIndex;
	  if (pos < 0) {
	    pos = 0;
	  }

	  // There was no match. If there's trailing haystack data that we cannot
	  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
	  // data is less than the needle size) then match using a modified
	  // algorithm that starts matching from the beginning instead of the end.
	  // Whatever trailing data is left after running this algorithm is added to
	  // the lookbehind buffer.
	  while (
	    pos !== len &&
	    (
	      data[pos] !== needle[0] ||
	      Buffer.compare(
	        data.subarray(pos + 1, len),
	        needle.subarray(1, len - pos)
	      ) !== 0
	    )
	  ) {
	    ++pos;
	  }

	  if (pos !== len) {
	    data.copy(this._lookbehind, 0, pos, len);
	    this._lookbehind_size = len - pos;
	  }

	  // Everything until pos is guaranteed not to contain needle data.
	  if (pos !== 0) { this.emit('info', false, data, this._bufpos, pos); }

	  this._bufpos = len;
	  return len
	};

	SBMH.prototype._sbmh_lookup_char = function (data, pos) {
	  return pos < 0
	    ? this._lookbehind[this._lookbehind_size + pos]
	    : data[pos]
	};

	SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
	  }
	  return true
	};

	sbmh = SBMH;
	return sbmh;
}

var PartStream_1;
var hasRequiredPartStream;

function requirePartStream () {
	if (hasRequiredPartStream) return PartStream_1;
	hasRequiredPartStream = 1;

	const inherits = require$$1$3.inherits;
	const ReadableStream = require$$3$1.Readable;

	function PartStream (opts) {
	  ReadableStream.call(this, opts);
	}
	inherits(PartStream, ReadableStream);

	PartStream.prototype._read = function (n) {};

	PartStream_1 = PartStream;
	return PartStream_1;
}

var getLimit;
var hasRequiredGetLimit;

function requireGetLimit () {
	if (hasRequiredGetLimit) return getLimit;
	hasRequiredGetLimit = 1;

	getLimit = function getLimit (limits, name, defaultLimit) {
	  if (
	    !limits ||
	    limits[name] === undefined ||
	    limits[name] === null
	  ) { return defaultLimit }

	  if (
	    typeof limits[name] !== 'number' ||
	    isNaN(limits[name])
	  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }

	  return limits[name]
	};
	return getLimit;
}

var HeaderParser_1;
var hasRequiredHeaderParser;

function requireHeaderParser () {
	if (hasRequiredHeaderParser) return HeaderParser_1;
	hasRequiredHeaderParser = 1;

	const EventEmitter = require$$0$1.EventEmitter;
	const inherits = require$$1$3.inherits;
	const getLimit = /*@__PURE__*/ requireGetLimit();

	const StreamSearch = /*@__PURE__*/ requireSbmh();

	const B_DCRLF = Buffer.from('\r\n\r\n');
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/; // eslint-disable-line no-control-regex

	function HeaderParser (cfg) {
	  EventEmitter.call(this);

	  cfg = cfg || {};
	  const self = this;
	  this.nread = 0;
	  this.maxed = false;
	  this.npairs = 0;
	  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);
	  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);
	  this.buffer = '';
	  this.header = {};
	  this.finished = false;
	  this.ss = new StreamSearch(B_DCRLF);
	  this.ss.on('info', function (isMatch, data, start, end) {
	    if (data && !self.maxed) {
	      if (self.nread + end - start >= self.maxHeaderSize) {
	        end = self.maxHeaderSize - self.nread + start;
	        self.nread = self.maxHeaderSize;
	        self.maxed = true;
	      } else { self.nread += (end - start); }

	      self.buffer += data.toString('binary', start, end);
	    }
	    if (isMatch) { self._finish(); }
	  });
	}
	inherits(HeaderParser, EventEmitter);

	HeaderParser.prototype.push = function (data) {
	  const r = this.ss.push(data);
	  if (this.finished) { return r }
	};

	HeaderParser.prototype.reset = function () {
	  this.finished = false;
	  this.buffer = '';
	  this.header = {};
	  this.ss.reset();
	};

	HeaderParser.prototype._finish = function () {
	  if (this.buffer) { this._parseHeader(); }
	  this.ss.matches = this.ss.maxMatches;
	  const header = this.header;
	  this.header = {};
	  this.buffer = '';
	  this.finished = true;
	  this.nread = this.npairs = 0;
	  this.maxed = false;
	  this.emit('header', header);
	};

	HeaderParser.prototype._parseHeader = function () {
	  if (this.npairs === this.maxHeaderPairs) { return }

	  const lines = this.buffer.split(RE_CRLF);
	  const len = lines.length;
	  let m, h;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (lines[i].length === 0) { continue }
	    if (lines[i][0] === '\t' || lines[i][0] === ' ') {
	      // folded header content
	      // RFC2822 says to just remove the CRLF and not the whitespace following
	      // it, so we follow the RFC and include the leading whitespace ...
	      if (h) {
	        this.header[h][this.header[h].length - 1] += lines[i];
	        continue
	      }
	    }

	    const posColon = lines[i].indexOf(':');
	    if (
	      posColon === -1 ||
	      posColon === 0
	    ) {
	      return
	    }
	    m = RE_HDR.exec(lines[i]);
	    h = m[1].toLowerCase();
	    this.header[h] = this.header[h] || [];
	    this.header[h].push((m[2] || ''));
	    if (++this.npairs === this.maxHeaderPairs) { break }
	  }
	};

	HeaderParser_1 = HeaderParser;
	return HeaderParser_1;
}

var Dicer_1;
var hasRequiredDicer;

function requireDicer () {
	if (hasRequiredDicer) return Dicer_1;
	hasRequiredDicer = 1;

	const WritableStream = require$$3$1.Writable;
	const inherits = require$$1$3.inherits;

	const StreamSearch = /*@__PURE__*/ requireSbmh();

	const PartStream = /*@__PURE__*/ requirePartStream();
	const HeaderParser = /*@__PURE__*/ requireHeaderParser();

	const DASH = 45;
	const B_ONEDASH = Buffer.from('-');
	const B_CRLF = Buffer.from('\r\n');
	const EMPTY_FN = function () {};

	function Dicer (cfg) {
	  if (!(this instanceof Dicer)) { return new Dicer(cfg) }
	  WritableStream.call(this, cfg);

	  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }

	  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary); } else { this._bparser = undefined; }

	  this._headerFirst = cfg.headerFirst;

	  this._dashes = 0;
	  this._parts = 0;
	  this._finished = false;
	  this._realFinish = false;
	  this._isPreamble = true;
	  this._justMatched = false;
	  this._firstWrite = true;
	  this._inHeader = true;
	  this._part = undefined;
	  this._cb = undefined;
	  this._ignoreData = false;
	  this._partOpts = { highWaterMark: cfg.partHwm };
	  this._pause = false;

	  const self = this;
	  this._hparser = new HeaderParser(cfg);
	  this._hparser.on('header', function (header) {
	    self._inHeader = false;
	    self._part.emit('header', header);
	  });
	}
	inherits(Dicer, WritableStream);

	Dicer.prototype.emit = function (ev) {
	  if (ev === 'finish' && !this._realFinish) {
	    if (!this._finished) {
	      const self = this;
	      process.nextTick(function () {
	        self.emit('error', new Error('Unexpected end of multipart data'));
	        if (self._part && !self._ignoreData) {
	          const type = (self._isPreamble ? 'Preamble' : 'Part');
	          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
	          self._part.push(null);
	          process.nextTick(function () {
	            self._realFinish = true;
	            self.emit('finish');
	            self._realFinish = false;
	          });
	          return
	        }
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      });
	    }
	  } else { WritableStream.prototype.emit.apply(this, arguments); }
	};

	Dicer.prototype._write = function (data, encoding, cb) {
	  // ignore unexpected data (e.g. extra trailer data after finished)
	  if (!this._hparser && !this._bparser) { return cb() }

	  if (this._headerFirst && this._isPreamble) {
	    if (!this._part) {
	      this._part = new PartStream(this._partOpts);
	      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part); } else { this._ignore(); }
	    }
	    const r = this._hparser.push(data);
	    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r); } else { return cb() }
	  }

	  // allows for "easier" testing
	  if (this._firstWrite) {
	    this._bparser.push(B_CRLF);
	    this._firstWrite = false;
	  }

	  this._bparser.push(data);

	  if (this._pause) { this._cb = cb; } else { cb(); }
	};

	Dicer.prototype.reset = function () {
	  this._part = undefined;
	  this._bparser = undefined;
	  this._hparser = undefined;
	};

	Dicer.prototype.setBoundary = function (boundary) {
	  const self = this;
	  this._bparser = new StreamSearch('\r\n--' + boundary);
	  this._bparser.on('info', function (isMatch, data, start, end) {
	    self._oninfo(isMatch, data, start, end);
	  });
	};

	Dicer.prototype._ignore = function () {
	  if (this._part && !this._ignoreData) {
	    this._ignoreData = true;
	    this._part.on('error', EMPTY_FN);
	    // we must perform some kind of read on the stream even though we are
	    // ignoring the data, otherwise node's Readable stream will not emit 'end'
	    // after pushing null to the stream
	    this._part.resume();
	  }
	};

	Dicer.prototype._oninfo = function (isMatch, data, start, end) {
	  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true;

	  if (!this._part && this._justMatched && data) {
	    while (this._dashes < 2 && (start + i) < end) {
	      if (data[start + i] === DASH) {
	        ++i;
	        ++this._dashes;
	      } else {
	        if (this._dashes) { buf = B_ONEDASH; }
	        this._dashes = 0;
	        break
	      }
	    }
	    if (this._dashes === 2) {
	      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)); }
	      this.reset();
	      this._finished = true;
	      // no more parts will be added
	      if (self._parts === 0) {
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      }
	    }
	    if (this._dashes) { return }
	  }
	  if (this._justMatched) { this._justMatched = false; }
	  if (!this._part) {
	    this._part = new PartStream(this._partOpts);
	    this._part._read = function (n) {
	      self._unpause();
	    };
	    if (this._isPreamble && this.listenerCount('preamble') !== 0) {
	      this.emit('preamble', this._part);
	    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {
	      this.emit('part', this._part);
	    } else {
	      this._ignore();
	    }
	    if (!this._isPreamble) { this._inHeader = true; }
	  }
	  if (data && start < end && !this._ignoreData) {
	    if (this._isPreamble || !this._inHeader) {
	      if (buf) { shouldWriteMore = this._part.push(buf); }
	      shouldWriteMore = this._part.push(data.slice(start, end));
	      if (!shouldWriteMore) { this._pause = true; }
	    } else if (!this._isPreamble && this._inHeader) {
	      if (buf) { this._hparser.push(buf); }
	      r = this._hparser.push(data.slice(start, end));
	      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end); }
	    }
	  }
	  if (isMatch) {
	    this._hparser.reset();
	    if (this._isPreamble) { this._isPreamble = false; } else {
	      if (start !== end) {
	        ++this._parts;
	        this._part.on('end', function () {
	          if (--self._parts === 0) {
	            if (self._finished) {
	              self._realFinish = true;
	              self.emit('finish');
	              self._realFinish = false;
	            } else {
	              self._unpause();
	            }
	          }
	        });
	      }
	    }
	    this._part.push(null);
	    this._part = undefined;
	    this._ignoreData = false;
	    this._justMatched = true;
	    this._dashes = 0;
	  }
	};

	Dicer.prototype._unpause = function () {
	  if (!this._pause) { return }

	  this._pause = false;
	  if (this._cb) {
	    const cb = this._cb;
	    this._cb = undefined;
	    cb();
	  }
	};

	Dicer_1 = Dicer;
	return Dicer_1;
}

var decodeText_1;
var hasRequiredDecodeText;

function requireDecodeText () {
	if (hasRequiredDecodeText) return decodeText_1;
	hasRequiredDecodeText = 1;

	// Node has always utf-8
	const utf8Decoder = new TextDecoder('utf-8');
	const textDecoders = new Map([
	  ['utf-8', utf8Decoder],
	  ['utf8', utf8Decoder]
	]);

	function getDecoder (charset) {
	  let lc;
	  while (true) {
	    switch (charset) {
	      case 'utf-8':
	      case 'utf8':
	        return decoders.utf8
	      case 'latin1':
	      case 'ascii': // TODO: Make these a separate, strict decoder?
	      case 'us-ascii':
	      case 'iso-8859-1':
	      case 'iso8859-1':
	      case 'iso88591':
	      case 'iso_8859-1':
	      case 'windows-1252':
	      case 'iso_8859-1:1987':
	      case 'cp1252':
	      case 'x-cp1252':
	        return decoders.latin1
	      case 'utf16le':
	      case 'utf-16le':
	      case 'ucs2':
	      case 'ucs-2':
	        return decoders.utf16le
	      case 'base64':
	        return decoders.base64
	      default:
	        if (lc === undefined) {
	          lc = true;
	          charset = charset.toLowerCase();
	          continue
	        }
	        return decoders.other.bind(charset)
	    }
	  }
	}

	const decoders = {
	  utf8: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.utf8Slice(0, data.length)
	  },

	  latin1: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      return data
	    }
	    return data.latin1Slice(0, data.length)
	  },

	  utf16le: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.ucs2Slice(0, data.length)
	  },

	  base64: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.base64Slice(0, data.length)
	  },

	  other: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }

	    if (textDecoders.has(this.toString())) {
	      try {
	        return textDecoders.get(this).decode(data)
	      } catch {}
	    }
	    return typeof data === 'string'
	      ? data
	      : data.toString()
	  }
	};

	function decodeText (text, sourceEncoding, destEncoding) {
	  if (text) {
	    return getDecoder(destEncoding)(text, sourceEncoding)
	  }
	  return text
	}

	decodeText_1 = decodeText;
	return decodeText_1;
}

/* eslint-disable object-property-newline */

var parseParams_1;
var hasRequiredParseParams;

function requireParseParams () {
	if (hasRequiredParseParams) return parseParams_1;
	hasRequiredParseParams = 1;

	const decodeText = /*@__PURE__*/ requireDecodeText();

	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;

	const EncodedLookup = {
	  '%00': '\x00', '%01': '\x01', '%02': '\x02', '%03': '\x03', '%04': '\x04',
	  '%05': '\x05', '%06': '\x06', '%07': '\x07', '%08': '\x08', '%09': '\x09',
	  '%0a': '\x0a', '%0A': '\x0a', '%0b': '\x0b', '%0B': '\x0b', '%0c': '\x0c',
	  '%0C': '\x0c', '%0d': '\x0d', '%0D': '\x0d', '%0e': '\x0e', '%0E': '\x0e',
	  '%0f': '\x0f', '%0F': '\x0f', '%10': '\x10', '%11': '\x11', '%12': '\x12',
	  '%13': '\x13', '%14': '\x14', '%15': '\x15', '%16': '\x16', '%17': '\x17',
	  '%18': '\x18', '%19': '\x19', '%1a': '\x1a', '%1A': '\x1a', '%1b': '\x1b',
	  '%1B': '\x1b', '%1c': '\x1c', '%1C': '\x1c', '%1d': '\x1d', '%1D': '\x1d',
	  '%1e': '\x1e', '%1E': '\x1e', '%1f': '\x1f', '%1F': '\x1f', '%20': '\x20',
	  '%21': '\x21', '%22': '\x22', '%23': '\x23', '%24': '\x24', '%25': '\x25',
	  '%26': '\x26', '%27': '\x27', '%28': '\x28', '%29': '\x29', '%2a': '\x2a',
	  '%2A': '\x2a', '%2b': '\x2b', '%2B': '\x2b', '%2c': '\x2c', '%2C': '\x2c',
	  '%2d': '\x2d', '%2D': '\x2d', '%2e': '\x2e', '%2E': '\x2e', '%2f': '\x2f',
	  '%2F': '\x2f', '%30': '\x30', '%31': '\x31', '%32': '\x32', '%33': '\x33',
	  '%34': '\x34', '%35': '\x35', '%36': '\x36', '%37': '\x37', '%38': '\x38',
	  '%39': '\x39', '%3a': '\x3a', '%3A': '\x3a', '%3b': '\x3b', '%3B': '\x3b',
	  '%3c': '\x3c', '%3C': '\x3c', '%3d': '\x3d', '%3D': '\x3d', '%3e': '\x3e',
	  '%3E': '\x3e', '%3f': '\x3f', '%3F': '\x3f', '%40': '\x40', '%41': '\x41',
	  '%42': '\x42', '%43': '\x43', '%44': '\x44', '%45': '\x45', '%46': '\x46',
	  '%47': '\x47', '%48': '\x48', '%49': '\x49', '%4a': '\x4a', '%4A': '\x4a',
	  '%4b': '\x4b', '%4B': '\x4b', '%4c': '\x4c', '%4C': '\x4c', '%4d': '\x4d',
	  '%4D': '\x4d', '%4e': '\x4e', '%4E': '\x4e', '%4f': '\x4f', '%4F': '\x4f',
	  '%50': '\x50', '%51': '\x51', '%52': '\x52', '%53': '\x53', '%54': '\x54',
	  '%55': '\x55', '%56': '\x56', '%57': '\x57', '%58': '\x58', '%59': '\x59',
	  '%5a': '\x5a', '%5A': '\x5a', '%5b': '\x5b', '%5B': '\x5b', '%5c': '\x5c',
	  '%5C': '\x5c', '%5d': '\x5d', '%5D': '\x5d', '%5e': '\x5e', '%5E': '\x5e',
	  '%5f': '\x5f', '%5F': '\x5f', '%60': '\x60', '%61': '\x61', '%62': '\x62',
	  '%63': '\x63', '%64': '\x64', '%65': '\x65', '%66': '\x66', '%67': '\x67',
	  '%68': '\x68', '%69': '\x69', '%6a': '\x6a', '%6A': '\x6a', '%6b': '\x6b',
	  '%6B': '\x6b', '%6c': '\x6c', '%6C': '\x6c', '%6d': '\x6d', '%6D': '\x6d',
	  '%6e': '\x6e', '%6E': '\x6e', '%6f': '\x6f', '%6F': '\x6f', '%70': '\x70',
	  '%71': '\x71', '%72': '\x72', '%73': '\x73', '%74': '\x74', '%75': '\x75',
	  '%76': '\x76', '%77': '\x77', '%78': '\x78', '%79': '\x79', '%7a': '\x7a',
	  '%7A': '\x7a', '%7b': '\x7b', '%7B': '\x7b', '%7c': '\x7c', '%7C': '\x7c',
	  '%7d': '\x7d', '%7D': '\x7d', '%7e': '\x7e', '%7E': '\x7e', '%7f': '\x7f',
	  '%7F': '\x7f', '%80': '\x80', '%81': '\x81', '%82': '\x82', '%83': '\x83',
	  '%84': '\x84', '%85': '\x85', '%86': '\x86', '%87': '\x87', '%88': '\x88',
	  '%89': '\x89', '%8a': '\x8a', '%8A': '\x8a', '%8b': '\x8b', '%8B': '\x8b',
	  '%8c': '\x8c', '%8C': '\x8c', '%8d': '\x8d', '%8D': '\x8d', '%8e': '\x8e',
	  '%8E': '\x8e', '%8f': '\x8f', '%8F': '\x8f', '%90': '\x90', '%91': '\x91',
	  '%92': '\x92', '%93': '\x93', '%94': '\x94', '%95': '\x95', '%96': '\x96',
	  '%97': '\x97', '%98': '\x98', '%99': '\x99', '%9a': '\x9a', '%9A': '\x9a',
	  '%9b': '\x9b', '%9B': '\x9b', '%9c': '\x9c', '%9C': '\x9c', '%9d': '\x9d',
	  '%9D': '\x9d', '%9e': '\x9e', '%9E': '\x9e', '%9f': '\x9f', '%9F': '\x9f',
	  '%a0': '\xa0', '%A0': '\xa0', '%a1': '\xa1', '%A1': '\xa1', '%a2': '\xa2',
	  '%A2': '\xa2', '%a3': '\xa3', '%A3': '\xa3', '%a4': '\xa4', '%A4': '\xa4',
	  '%a5': '\xa5', '%A5': '\xa5', '%a6': '\xa6', '%A6': '\xa6', '%a7': '\xa7',
	  '%A7': '\xa7', '%a8': '\xa8', '%A8': '\xa8', '%a9': '\xa9', '%A9': '\xa9',
	  '%aa': '\xaa', '%Aa': '\xaa', '%aA': '\xaa', '%AA': '\xaa', '%ab': '\xab',
	  '%Ab': '\xab', '%aB': '\xab', '%AB': '\xab', '%ac': '\xac', '%Ac': '\xac',
	  '%aC': '\xac', '%AC': '\xac', '%ad': '\xad', '%Ad': '\xad', '%aD': '\xad',
	  '%AD': '\xad', '%ae': '\xae', '%Ae': '\xae', '%aE': '\xae', '%AE': '\xae',
	  '%af': '\xaf', '%Af': '\xaf', '%aF': '\xaf', '%AF': '\xaf', '%b0': '\xb0',
	  '%B0': '\xb0', '%b1': '\xb1', '%B1': '\xb1', '%b2': '\xb2', '%B2': '\xb2',
	  '%b3': '\xb3', '%B3': '\xb3', '%b4': '\xb4', '%B4': '\xb4', '%b5': '\xb5',
	  '%B5': '\xb5', '%b6': '\xb6', '%B6': '\xb6', '%b7': '\xb7', '%B7': '\xb7',
	  '%b8': '\xb8', '%B8': '\xb8', '%b9': '\xb9', '%B9': '\xb9', '%ba': '\xba',
	  '%Ba': '\xba', '%bA': '\xba', '%BA': '\xba', '%bb': '\xbb', '%Bb': '\xbb',
	  '%bB': '\xbb', '%BB': '\xbb', '%bc': '\xbc', '%Bc': '\xbc', '%bC': '\xbc',
	  '%BC': '\xbc', '%bd': '\xbd', '%Bd': '\xbd', '%bD': '\xbd', '%BD': '\xbd',
	  '%be': '\xbe', '%Be': '\xbe', '%bE': '\xbe', '%BE': '\xbe', '%bf': '\xbf',
	  '%Bf': '\xbf', '%bF': '\xbf', '%BF': '\xbf', '%c0': '\xc0', '%C0': '\xc0',
	  '%c1': '\xc1', '%C1': '\xc1', '%c2': '\xc2', '%C2': '\xc2', '%c3': '\xc3',
	  '%C3': '\xc3', '%c4': '\xc4', '%C4': '\xc4', '%c5': '\xc5', '%C5': '\xc5',
	  '%c6': '\xc6', '%C6': '\xc6', '%c7': '\xc7', '%C7': '\xc7', '%c8': '\xc8',
	  '%C8': '\xc8', '%c9': '\xc9', '%C9': '\xc9', '%ca': '\xca', '%Ca': '\xca',
	  '%cA': '\xca', '%CA': '\xca', '%cb': '\xcb', '%Cb': '\xcb', '%cB': '\xcb',
	  '%CB': '\xcb', '%cc': '\xcc', '%Cc': '\xcc', '%cC': '\xcc', '%CC': '\xcc',
	  '%cd': '\xcd', '%Cd': '\xcd', '%cD': '\xcd', '%CD': '\xcd', '%ce': '\xce',
	  '%Ce': '\xce', '%cE': '\xce', '%CE': '\xce', '%cf': '\xcf', '%Cf': '\xcf',
	  '%cF': '\xcf', '%CF': '\xcf', '%d0': '\xd0', '%D0': '\xd0', '%d1': '\xd1',
	  '%D1': '\xd1', '%d2': '\xd2', '%D2': '\xd2', '%d3': '\xd3', '%D3': '\xd3',
	  '%d4': '\xd4', '%D4': '\xd4', '%d5': '\xd5', '%D5': '\xd5', '%d6': '\xd6',
	  '%D6': '\xd6', '%d7': '\xd7', '%D7': '\xd7', '%d8': '\xd8', '%D8': '\xd8',
	  '%d9': '\xd9', '%D9': '\xd9', '%da': '\xda', '%Da': '\xda', '%dA': '\xda',
	  '%DA': '\xda', '%db': '\xdb', '%Db': '\xdb', '%dB': '\xdb', '%DB': '\xdb',
	  '%dc': '\xdc', '%Dc': '\xdc', '%dC': '\xdc', '%DC': '\xdc', '%dd': '\xdd',
	  '%Dd': '\xdd', '%dD': '\xdd', '%DD': '\xdd', '%de': '\xde', '%De': '\xde',
	  '%dE': '\xde', '%DE': '\xde', '%df': '\xdf', '%Df': '\xdf', '%dF': '\xdf',
	  '%DF': '\xdf', '%e0': '\xe0', '%E0': '\xe0', '%e1': '\xe1', '%E1': '\xe1',
	  '%e2': '\xe2', '%E2': '\xe2', '%e3': '\xe3', '%E3': '\xe3', '%e4': '\xe4',
	  '%E4': '\xe4', '%e5': '\xe5', '%E5': '\xe5', '%e6': '\xe6', '%E6': '\xe6',
	  '%e7': '\xe7', '%E7': '\xe7', '%e8': '\xe8', '%E8': '\xe8', '%e9': '\xe9',
	  '%E9': '\xe9', '%ea': '\xea', '%Ea': '\xea', '%eA': '\xea', '%EA': '\xea',
	  '%eb': '\xeb', '%Eb': '\xeb', '%eB': '\xeb', '%EB': '\xeb', '%ec': '\xec',
	  '%Ec': '\xec', '%eC': '\xec', '%EC': '\xec', '%ed': '\xed', '%Ed': '\xed',
	  '%eD': '\xed', '%ED': '\xed', '%ee': '\xee', '%Ee': '\xee', '%eE': '\xee',
	  '%EE': '\xee', '%ef': '\xef', '%Ef': '\xef', '%eF': '\xef', '%EF': '\xef',
	  '%f0': '\xf0', '%F0': '\xf0', '%f1': '\xf1', '%F1': '\xf1', '%f2': '\xf2',
	  '%F2': '\xf2', '%f3': '\xf3', '%F3': '\xf3', '%f4': '\xf4', '%F4': '\xf4',
	  '%f5': '\xf5', '%F5': '\xf5', '%f6': '\xf6', '%F6': '\xf6', '%f7': '\xf7',
	  '%F7': '\xf7', '%f8': '\xf8', '%F8': '\xf8', '%f9': '\xf9', '%F9': '\xf9',
	  '%fa': '\xfa', '%Fa': '\xfa', '%fA': '\xfa', '%FA': '\xfa', '%fb': '\xfb',
	  '%Fb': '\xfb', '%fB': '\xfb', '%FB': '\xfb', '%fc': '\xfc', '%Fc': '\xfc',
	  '%fC': '\xfc', '%FC': '\xfc', '%fd': '\xfd', '%Fd': '\xfd', '%fD': '\xfd',
	  '%FD': '\xfd', '%fe': '\xfe', '%Fe': '\xfe', '%fE': '\xfe', '%FE': '\xfe',
	  '%ff': '\xff', '%Ff': '\xff', '%fF': '\xff', '%FF': '\xff'
	};

	function encodedReplacer (match) {
	  return EncodedLookup[match]
	}

	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;

	function parseParams (str) {
	  const res = [];
	  let state = STATE_KEY;
	  let charset = '';
	  let inquote = false;
	  let escaping = false;
	  let p = 0;
	  let tmp = '';
	  const len = str.length;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    const char = str[i];
	    if (char === '\\' && inquote) {
	      if (escaping) { escaping = false; } else {
	        escaping = true;
	        continue
	      }
	    } else if (char === '"') {
	      if (!escaping) {
	        if (inquote) {
	          inquote = false;
	          state = STATE_KEY;
	          // Skip any remaining characters until we hit a semicolon or end of string
	          // This ensures we don't include characters after the closing quote
	          while (i + 1 < len && str[i + 1] !== ';') {
	            ++i;
	          }
	        } else { inquote = true; }
	        continue
	      } else { escaping = false; }
	    } else {
	      if (escaping && inquote) { tmp += '\\'; }
	      escaping = false;
	      if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
	        if (state === STATE_CHARSET) {
	          state = STATE_LANG;
	          charset = tmp.substring(1);
	        } else { state = STATE_VALUE; }
	        tmp = '';
	        continue
	      } else if (state === STATE_KEY &&
	        (char === '*' || char === '=') &&
	        res.length) {
	        state = char === '*'
	          ? STATE_CHARSET
	          : STATE_VALUE;
	        res[p] = [tmp, undefined];
	        tmp = '';
	        continue
	      } else if (!inquote && char === ';') {
	        state = STATE_KEY;
	        if (charset) {
	          if (tmp.length) {
	            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	              'binary',
	              charset);
	          }
	          charset = '';
	        } else if (tmp.length) {
	          tmp = decodeText(tmp, 'binary', 'utf8');
	        }
	        if (res[p] === undefined) { res[p] = tmp; } else { res[p][1] = tmp; }
	        tmp = '';
	        ++p;
	        continue
	      } else if (!inquote && (char === ' ' || char === '\t')) { continue }
	    }
	    tmp += char;
	  }
	  if (charset && tmp.length) {
	    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	      'binary',
	      charset);
	  } else if (tmp) {
	    tmp = decodeText(tmp, 'binary', 'utf8');
	  }

	  if (res[p] === undefined) {
	    if (tmp) { res[p] = tmp; }
	  } else { res[p][1] = tmp; }

	  return res
	}

	parseParams_1 = parseParams;
	return parseParams_1;
}

var basename;
var hasRequiredBasename;

function requireBasename () {
	if (hasRequiredBasename) return basename;
	hasRequiredBasename = 1;

	basename = function basename (path) {
	  if (typeof path !== 'string') { return '' }
	  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var
	    switch (path.charCodeAt(i)) {
	      case 0x2F: // '/'
	      case 0x5C: // '\'
	        path = path.slice(i + 1);
	        return (path === '..' || path === '.' ? '' : path)
	    }
	  }
	  return (path === '..' || path === '.' ? '' : path)
	};
	return basename;
}

var multipart;
var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;

	// TODO:
	//  * support 1 nested multipart level
	//    (see second multipart example here:
	//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
	//  * support limits.fieldNameSize
	//     -- this will require modifications to utils.parseParams

	const { Readable } = require$$3$1;
	const { inherits } = require$$1$3;

	const Dicer = /*@__PURE__*/ requireDicer();

	const parseParams = /*@__PURE__*/ requireParseParams();
	const decodeText = /*@__PURE__*/ requireDecodeText();
	const basename = /*@__PURE__*/ requireBasename();
	const getLimit = /*@__PURE__*/ requireGetLimit();

	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;

	Multipart.detect = /^multipart\/form-data/i;
	function Multipart (boy, cfg) {
	  let i;
	  let len;
	  const self = this;
	  let boundary;
	  const limits = cfg.limits;
	  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined));
	  const parsedConType = cfg.parsedConType || [];
	  const defCharset = cfg.defCharset || 'utf8';
	  const preservePath = cfg.preservePath;
	  const fileOpts = { highWaterMark: cfg.fileHwm };

	  for (i = 0, len = parsedConType.length; i < len; ++i) {
	    if (Array.isArray(parsedConType[i]) &&
	      RE_BOUNDARY.test(parsedConType[i][0])) {
	      boundary = parsedConType[i][1];
	      break
	    }
	  }

	  function checkFinished () {
	    if (nends === 0 && finished && !boy._done) {
	      finished = false;
	      self.end();
	    }
	  }

	  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }

	  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);
	  const filesLimit = getLimit(limits, 'files', Infinity);
	  const fieldsLimit = getLimit(limits, 'fields', Infinity);
	  const partsLimit = getLimit(limits, 'parts', Infinity);
	  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);
	  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);

	  let nfiles = 0;
	  let nfields = 0;
	  let nends = 0;
	  let curFile;
	  let curField;
	  let finished = false;

	  this._needDrain = false;
	  this._pause = false;
	  this._cb = undefined;
	  this._nparts = 0;
	  this._boy = boy;

	  const parserCfg = {
	    boundary,
	    maxHeaderPairs: headerPairsLimit,
	    maxHeaderSize: headerSizeLimit,
	    partHwm: fileOpts.highWaterMark,
	    highWaterMark: cfg.highWaterMark
	  };

	  this.parser = new Dicer(parserCfg);
	  this.parser.on('drain', function () {
	    self._needDrain = false;
	    if (self._cb && !self._pause) {
	      const cb = self._cb;
	      self._cb = undefined;
	      cb();
	    }
	  }).on('part', function onPart (part) {
	    if (++self._nparts > partsLimit) {
	      self.parser.removeListener('part', onPart);
	      self.parser.on('part', skipPart);
	      boy.hitPartsLimit = true;
	      boy.emit('partsLimit');
	      return skipPart(part)
	    }

	    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
	    // us emit 'end' early since we know the part has ended if we are already
	    // seeing the next part
	    if (curField) {
	      const field = curField;
	      field.emit('end');
	      field.removeAllListeners('end');
	    }

	    part.on('header', function (header) {
	      let contype;
	      let fieldname;
	      let parsed;
	      let charset;
	      let encoding;
	      let filename;
	      let nsize = 0;

	      if (header['content-type']) {
	        parsed = parseParams(header['content-type'][0]);
	        if (parsed[0]) {
	          contype = parsed[0].toLowerCase();
	          for (i = 0, len = parsed.length; i < len; ++i) {
	            if (RE_CHARSET.test(parsed[i][0])) {
	              charset = parsed[i][1].toLowerCase();
	              break
	            }
	          }
	        }
	      }

	      if (contype === undefined) { contype = 'text/plain'; }
	      if (charset === undefined) { charset = defCharset; }

	      if (header['content-disposition']) {
	        parsed = parseParams(header['content-disposition'][0]);
	        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }
	        for (i = 0, len = parsed.length; i < len; ++i) {
	          if (RE_NAME.test(parsed[i][0])) {
	            fieldname = parsed[i][1];
	          } else if (RE_FILENAME.test(parsed[i][0])) {
	            filename = parsed[i][1];
	            if (!preservePath) { filename = basename(filename); }
	          }
	        }
	      } else { return skipPart(part) }

	      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase(); } else { encoding = '7bit'; }

	      let onData,
	        onEnd;

	      if (isPartAFile(fieldname, contype, filename)) {
	        // file/binary field
	        if (nfiles === filesLimit) {
	          if (!boy.hitFilesLimit) {
	            boy.hitFilesLimit = true;
	            boy.emit('filesLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfiles;

	        if (boy.listenerCount('file') === 0) {
	          self.parser._ignore();
	          return
	        }

	        ++nends;
	        const file = new FileStream(fileOpts);
	        curFile = file;
	        file.on('end', function () {
	          --nends;
	          self._pause = false;
	          checkFinished();
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        });
	        file._read = function (n) {
	          if (!self._pause) { return }
	          self._pause = false;
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        };
	        boy.emit('file', fieldname, file, filename, encoding, contype);

	        onData = function (data) {
	          if ((nsize += data.length) > fileSizeLimit) {
	            const extralen = fileSizeLimit - nsize + data.length;
	            if (extralen > 0) { file.push(data.slice(0, extralen)); }
	            file.truncated = true;
	            file.bytesRead = fileSizeLimit;
	            part.removeAllListeners('data');
	            file.emit('limit');
	            return
	          } else if (!file.push(data)) { self._pause = true; }

	          file.bytesRead = nsize;
	        };

	        onEnd = function () {
	          curFile = undefined;
	          file.push(null);
	        };
	      } else {
	        // non-file field
	        if (nfields === fieldsLimit) {
	          if (!boy.hitFieldsLimit) {
	            boy.hitFieldsLimit = true;
	            boy.emit('fieldsLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfields;
	        ++nends;
	        let buffer = '';
	        let truncated = false;
	        curField = part;

	        onData = function (data) {
	          if ((nsize += data.length) > fieldSizeLimit) {
	            const extralen = (fieldSizeLimit - (nsize - data.length));
	            buffer += data.toString('binary', 0, extralen);
	            truncated = true;
	            part.removeAllListeners('data');
	          } else { buffer += data.toString('binary'); }
	        };

	        onEnd = function () {
	          curField = undefined;
	          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset); }
	          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
	          --nends;
	          checkFinished();
	        };
	      }

	      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
	         broken. Streams2/streams3 is a huge black box of confusion, but
	         somehow overriding the sync state seems to fix things again (and still
	         seems to work for previous node versions).
	      */
	      part._readableState.sync = false;

	      part.on('data', onData);
	      part.on('end', onEnd);
	    }).on('error', function (err) {
	      if (curFile) { curFile.emit('error', err); }
	    });
	  }).on('error', function (err) {
	    boy.emit('error', err);
	  }).on('finish', function () {
	    finished = true;
	    checkFinished();
	  });
	}

	Multipart.prototype.write = function (chunk, cb) {
	  const r = this.parser.write(chunk);
	  if (r && !this._pause) {
	    cb();
	  } else {
	    this._needDrain = !r;
	    this._cb = cb;
	  }
	};

	Multipart.prototype.end = function () {
	  const self = this;

	  if (self.parser.writable) {
	    self.parser.end();
	  } else if (!self._boy._done) {
	    process.nextTick(function () {
	      self._boy._done = true;
	      self._boy.emit('finish');
	    });
	  }
	};

	function skipPart (part) {
	  part.resume();
	}

	function FileStream (opts) {
	  Readable.call(this, opts);

	  this.bytesRead = 0;

	  this.truncated = false;
	}

	inherits(FileStream, Readable);

	FileStream.prototype._read = function (n) {};

	multipart = Multipart;
	return multipart;
}

var Decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return Decoder_1;
	hasRequiredDecoder = 1;

	const RE_PLUS = /\+/g;

	const HEX = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	];

	function Decoder () {
	  this.buffer = undefined;
	}
	Decoder.prototype.write = function (str) {
	  // Replace '+' with ' ' before decoding
	  str = str.replace(RE_PLUS, ' ');
	  let res = '';
	  let i = 0; let p = 0; const len = str.length;
	  for (; i < len; ++i) {
	    if (this.buffer !== undefined) {
	      if (!HEX[str.charCodeAt(i)]) {
	        res += '%' + this.buffer;
	        this.buffer = undefined;
	        --i; // retry character
	      } else {
	        this.buffer += str[i];
	        ++p;
	        if (this.buffer.length === 2) {
	          res += String.fromCharCode(parseInt(this.buffer, 16));
	          this.buffer = undefined;
	        }
	      }
	    } else if (str[i] === '%') {
	      if (i > p) {
	        res += str.substring(p, i);
	        p = i;
	      }
	      this.buffer = '';
	      ++p;
	    }
	  }
	  if (p < len && this.buffer === undefined) { res += str.substring(p); }
	  return res
	};
	Decoder.prototype.reset = function () {
	  this.buffer = undefined;
	};

	Decoder_1 = Decoder;
	return Decoder_1;
}

var urlencoded;
var hasRequiredUrlencoded;

function requireUrlencoded () {
	if (hasRequiredUrlencoded) return urlencoded;
	hasRequiredUrlencoded = 1;

	const Decoder = /*@__PURE__*/ requireDecoder();
	const decodeText = /*@__PURE__*/ requireDecodeText();
	const getLimit = /*@__PURE__*/ requireGetLimit();

	const RE_CHARSET = /^charset$/i;

	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded (boy, cfg) {
	  const limits = cfg.limits;
	  const parsedConType = cfg.parsedConType;
	  this.boy = boy;

	  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
	  this.fieldsLimit = getLimit(limits, 'fields', Infinity);

	  let charset;
	  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var
	    if (Array.isArray(parsedConType[i]) &&
	        RE_CHARSET.test(parsedConType[i][0])) {
	      charset = parsedConType[i][1].toLowerCase();
	      break
	    }
	  }

	  if (charset === undefined) { charset = cfg.defCharset || 'utf8'; }

	  this.decoder = new Decoder();
	  this.charset = charset;
	  this._fields = 0;
	  this._state = 'key';
	  this._checkingBytes = true;
	  this._bytesKey = 0;
	  this._bytesVal = 0;
	  this._key = '';
	  this._val = '';
	  this._keyTrunc = false;
	  this._valTrunc = false;
	  this._hitLimit = false;
	}

	UrlEncoded.prototype.write = function (data, cb) {
	  if (this._fields === this.fieldsLimit) {
	    if (!this.boy.hitFieldsLimit) {
	      this.boy.hitFieldsLimit = true;
	      this.boy.emit('fieldsLimit');
	    }
	    return cb()
	  }

	  let idxeq; let idxamp; let i; let p = 0; const len = data.length;

	  while (p < len) {
	    if (this._state === 'key') {
	      idxeq = idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x3D/* = */) {
	          idxeq = i;
	          break
	        } else if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesKey; }
	      }

	      if (idxeq !== undefined) {
	        // key with assignment
	        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)); }
	        this._state = 'val';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._val = '';
	        this._bytesVal = 0;
	        this._valTrunc = false;
	        this.decoder.reset();

	        p = idxeq + 1;
	      } else if (idxamp !== undefined) {
	        // key with no assignment
	        ++this._fields;
	        let key; const keyTrunc = this._keyTrunc;
	        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))); } else { key = this._key; }

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        if (key.length) {
	          this.boy.emit('field', decodeText(key, 'binary', this.charset),
	            '',
	            keyTrunc,
	            false);
	        }

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._keyTrunc = true;
	        }
	      } else {
	        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    } else {
	      idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesVal; }
	      }

	      if (idxamp !== undefined) {
	        ++this._fields;
	        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)); }
	        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	          decodeText(this._val, 'binary', this.charset),
	          this._keyTrunc,
	          this._valTrunc);
	        this._state = 'key';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._val === '' && this.fieldSizeLimit === 0) ||
	            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._valTrunc = true;
	        }
	      } else {
	        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    }
	  }
	  cb();
	};

	UrlEncoded.prototype.end = function () {
	  if (this.boy._done) { return }

	  if (this._state === 'key' && this._key.length > 0) {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      '',
	      this._keyTrunc,
	      false);
	  } else if (this._state === 'val') {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      decodeText(this._val, 'binary', this.charset),
	      this._keyTrunc,
	      this._valTrunc);
	  }
	  this.boy._done = true;
	  this.boy.emit('finish');
	};

	urlencoded = UrlEncoded;
	return urlencoded;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main.exports;
	hasRequiredMain = 1;

	const WritableStream = require$$3$1.Writable;
	const { inherits } = require$$1$3;
	const Dicer = /*@__PURE__*/ requireDicer();

	const MultipartParser = /*@__PURE__*/ requireMultipart();
	const UrlencodedParser = /*@__PURE__*/ requireUrlencoded();
	const parseParams = /*@__PURE__*/ requireParseParams();

	function Busboy (opts) {
	  if (!(this instanceof Busboy)) { return new Busboy(opts) }

	  if (typeof opts !== 'object') {
	    throw new TypeError('Busboy expected an options-Object.')
	  }
	  if (typeof opts.headers !== 'object') {
	    throw new TypeError('Busboy expected an options-Object with headers-attribute.')
	  }
	  if (typeof opts.headers['content-type'] !== 'string') {
	    throw new TypeError('Missing Content-Type-header.')
	  }

	  const {
	    headers,
	    ...streamOptions
	  } = opts;

	  this.opts = {
	    autoDestroy: false,
	    ...streamOptions
	  };
	  WritableStream.call(this, this.opts);

	  this._done = false;
	  this._parser = this.getParserByHeaders(headers);
	  this._finished = false;
	}
	inherits(Busboy, WritableStream);

	Busboy.prototype.emit = function (ev) {
	  if (ev === 'finish') {
	    if (!this._done) {
	      this._parser?.end();
	      return
	    } else if (this._finished) {
	      return
	    }
	    this._finished = true;
	  }
	  WritableStream.prototype.emit.apply(this, arguments);
	};

	Busboy.prototype.getParserByHeaders = function (headers) {
	  const parsed = parseParams(headers['content-type']);

	  const cfg = {
	    defCharset: this.opts.defCharset,
	    fileHwm: this.opts.fileHwm,
	    headers,
	    highWaterMark: this.opts.highWaterMark,
	    isPartAFile: this.opts.isPartAFile,
	    limits: this.opts.limits,
	    parsedConType: parsed,
	    preservePath: this.opts.preservePath
	  };

	  if (MultipartParser.detect.test(parsed[0])) {
	    return new MultipartParser(this, cfg)
	  }
	  if (UrlencodedParser.detect.test(parsed[0])) {
	    return new UrlencodedParser(this, cfg)
	  }
	  throw new Error('Unsupported Content-Type.')
	};

	Busboy.prototype._write = function (chunk, encoding, cb) {
	  this._parser.write(chunk, cb);
	};

	main.exports = Busboy;
	main.exports.default = Busboy;
	main.exports.Busboy = Busboy;

	main.exports.Dicer = Dicer;
	return main.exports;
}

const require$$8 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(zlib);

/*! firebase-admin v12.7.0 */

var hasRequiredApiRequest;

function requireApiRequest () {
	if (hasRequiredApiRequest) return apiRequest;
	hasRequiredApiRequest = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(apiRequest, "__esModule", { value: true });
	apiRequest.Http2SessionHandler = apiRequest.ExponentialBackoffPoller = apiRequest.ApiSettings = apiRequest.AuthorizedHttp2Client = apiRequest.AuthorizedHttpClient = apiRequest.parseHttpResponse = apiRequest.Http2Client = apiRequest.HttpClient = apiRequest.RequestClient = apiRequest.defaultRetryConfig = apiRequest.RequestResponseError = void 0;
	const error_1 = error;
	const validator = validator$2;
	const http = require$$2$2;
	const https = require$$3$2;
	const http2 = require$$4$2;
	const url = require$$0$2;
	const events_1 = require$$6;
	class DefaultRequestResponse {
	    /**
	     * Constructs a new `RequestResponse` from the given `LowLevelResponse`.
	     */
	    constructor(resp) {
	        this.status = resp.status;
	        this.headers = resp.headers;
	        this.text = resp.data;
	        try {
	            if (!resp.data) {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');
	            }
	            this.parsedData = JSON.parse(resp.data);
	        }
	        catch (err) {
	            this.parsedData = undefined;
	            this.parseError = err;
	        }
	        this.request = `${resp.config.method} ${resp.config.url}`;
	    }
	    get data() {
	        if (this.isJson()) {
	            return this.parsedData;
	        }
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: "${this.parseError.toString()}". Raw server ` +
	            `response: "${this.text}". Status code: "${this.status}". Outgoing ` +
	            `request: "${this.request}."`);
	    }
	    isJson() {
	        return typeof this.parsedData !== 'undefined';
	    }
	}
	/**
	 * Represents a multipart HTTP or HTTP/2 response. Parts that constitute the response body can be accessed
	 * via the multipart getter. Getters for text and data throw errors.
	 */
	class MultipartRequestResponse {
	    constructor(resp) {
	        this.status = resp.status;
	        this.headers = resp.headers;
	        this.multipart = resp.multipart;
	    }
	    get text() {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');
	    }
	    get data() {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');
	    }
	    isJson() {
	        return false;
	    }
	}
	class RequestResponseError extends Error {
	    constructor(response) {
	        super(`Server responded with status ${response.status}.`);
	        this.response = response;
	        // Set the prototype so that instanceof checks will work correctly.
	        // See: https://github.com/Microsoft/TypeScript/issues/13965
	        Object.setPrototypeOf(this, RequestResponseError.prototype);
	    }
	}
	apiRequest.RequestResponseError = RequestResponseError;
	/**
	 * Default retry configuration for HTTP and HTTP/2 requests. Retries up to 4 times on connection reset and timeout
	 * errors as well as 503 errors. Exposed as a function to ensure that every `RequestClient` gets its own `RetryConfig`
	 * instance.
	 */
	function defaultRetryConfig() {
	    return {
	        maxRetries: 4,
	        statusCodes: [503],
	        ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],
	        backOffFactor: 0.5,
	        maxDelayInMillis: 60 * 1000,
	    };
	}
	apiRequest.defaultRetryConfig = defaultRetryConfig;
	/**
	 * Ensures that the given `RetryConfig` object is valid.
	 *
	 * @param retry - The configuration to be validated.
	 */
	function validateRetryConfig(retry) {
	    if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');
	    }
	    if (typeof retry.backOffFactor !== 'undefined') {
	        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');
	        }
	    }
	    if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');
	    }
	    if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');
	    }
	    if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');
	    }
	}
	class RequestClient {
	    constructor(retry = defaultRetryConfig()) {
	        if (retry) {
	            this.retry = retry;
	            validateRetryConfig(this.retry);
	        }
	    }
	    createRequestResponse(resp) {
	        if (resp.multipart) {
	            return new MultipartRequestResponse(resp);
	        }
	        return new DefaultRequestResponse(resp);
	    }
	    waitForRetry(delayMillis) {
	        if (delayMillis > 0) {
	            return new Promise((resolve) => {
	                setTimeout(resolve, delayMillis);
	            });
	        }
	        return Promise.resolve();
	    }
	    /**
	     * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating
	     * the retry.
	     *
	     * @param retryAttempts - Number of retries completed up to now.
	     * @param err - The last encountered error.
	     * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the
	     *     2nd element is a boolean indicating whether the request is eligible for a retry or not.
	     */
	    getRetryDelayMillis(retryAttempts, err) {
	        if (!this.isRetryEligible(retryAttempts, err)) {
	            return [0, false];
	        }
	        const response = err.response;
	        if (response && response.headers['retry-after']) {
	            const delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);
	            if (delayMillis > 0) {
	                return [delayMillis, true];
	            }
	        }
	        return [this.backOffDelayMillis(retryAttempts), true];
	    }
	    isRetryEligible(retryAttempts, err) {
	        if (!this.retry) {
	            return false;
	        }
	        if (retryAttempts >= this.retry.maxRetries) {
	            return false;
	        }
	        if (err.response) {
	            const statusCodes = this.retry.statusCodes || [];
	            return statusCodes.indexOf(err.response.status) !== -1;
	        }
	        if (err.code) {
	            const retryCodes = this.retry.ioErrorCodes || [];
	            return retryCodes.indexOf(err.code) !== -1;
	        }
	        return false;
	    }
	    /**???
	     * Parses the Retry-After header as a milliseconds value. Return value is negative if the Retry-After header
	     * contains an expired timestamp or otherwise malformed.
	     */
	    parseRetryAfterIntoMillis(retryAfter) {
	        const delaySeconds = parseInt(retryAfter, 10);
	        if (!isNaN(delaySeconds)) {
	            return delaySeconds * 1000;
	        }
	        const date = new Date(retryAfter);
	        if (!isNaN(date.getTime())) {
	            return date.getTime() - Date.now();
	        }
	        return -1;
	    }
	    backOffDelayMillis(retryAttempts) {
	        if (retryAttempts === 0) {
	            return 0;
	        }
	        if (!this.retry) {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');
	        }
	        const backOffFactor = this.retry.backOffFactor || 0;
	        const delayInSeconds = (2 ** retryAttempts) * backOffFactor;
	        return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);
	    }
	}
	apiRequest.RequestClient = RequestClient;
	class HttpClient extends RequestClient {
	    constructor(retry) {
	        super(retry);
	    }
	    /**
	     * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned
	     * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
	     * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
	     * If a request fails due to a low-level network error, the client transparently retries the request once before
	     * rejecting the promise.
	     *
	     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
	     * content-type header will also be automatically set in this case. For all other payload types, the content-type
	     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
	     * and pass as a string or a Buffer along with the appropriate content-type header.
	     *
	     * @param config - HTTP request to be sent.
	     * @returns A promise that resolves with the response details.
	     */
	    send(config) {
	        return this.sendWithRetry(config);
	    }
	    /**
	     * Sends an HTTP request. In the event of an error, retries the HTTP request according to the
	     * `RetryConfig` set on the `HttpClient`.
	     *
	     * @param config - HTTP request to be sent.
	     * @param retryAttempts - Number of retries performed up to now.
	     * @returns A promise that resolves with the response details.
	     */
	    sendWithRetry(config, retryAttempts = 0) {
	        return AsyncHttpCall.invoke(config)
	            .then((resp) => {
	            return this.createRequestResponse(resp);
	        })
	            .catch((err) => {
	            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
	            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
	                return this.waitForRetry(delayMillis).then(() => {
	                    return this.sendWithRetry(config, retryAttempts + 1);
	                });
	            }
	            if (err.response) {
	                throw new RequestResponseError(this.createRequestResponse(err.response));
	            }
	            if (err.code === 'ETIMEDOUT') {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
	            }
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
	        });
	    }
	}
	apiRequest.HttpClient = HttpClient;
	class Http2Client extends RequestClient {
	    constructor(retry = defaultRetryConfig()) {
	        super(retry);
	    }
	    /**
	     * Sends an HTTP/2 request to a remote server. If the server responds with a successful response (2xx), the returned
	     * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
	     * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
	     * If a request fails due to a low-level network error, the client transparently retries the request once before
	     * rejecting the promise.
	     *
	     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
	     * content-type header will also be automatically set in this case. For all other payload types, the content-type
	     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
	     * and pass as a string or a Buffer along with the appropriate content-type header.
	     *
	     * @param config - HTTP/2 request to be sent.
	     * @returns A promise that resolves with the response details.
	     */
	    send(config) {
	        return this.sendWithRetry(config);
	    }
	    /**
	     * Sends an HTTP/2 request. In the event of an error, retries the HTTP/2 request according to the
	     * `RetryConfig` set on the `Http2Client`.
	     *
	     * @param config - HTTP/2 request to be sent.
	     * @param retryAttempts - Number of retries performed up to now.
	     * @returns A promise that resolves with the response details.
	     */
	    sendWithRetry(config, retryAttempts = 0) {
	        return AsyncHttp2Call.invoke(config)
	            .then((resp) => {
	            return this.createRequestResponse(resp);
	        })
	            .catch((err) => {
	            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
	            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
	                return this.waitForRetry(delayMillis).then(() => {
	                    return this.sendWithRetry(config, retryAttempts + 1);
	                });
	            }
	            if (err.response) {
	                throw new RequestResponseError(this.createRequestResponse(err.response));
	            }
	            if (err.code === 'ETIMEDOUT') {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
	            }
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
	        });
	    }
	}
	apiRequest.Http2Client = Http2Client;
	/**
	 * Parses a full HTTP or HTTP/2 response message containing both a header and a body.
	 *
	 * @param response - The HTTP or HTTP/2 response to be parsed.
	 * @param config - The request configuration that resulted in the HTTP or HTTP/2 response.
	 * @returns An object containing the response's parsed status, headers and the body.
	 */
	function parseHttpResponse(response, config) {
	    const responseText = validator.isBuffer(response) ?
	        response.toString('utf-8') : response;
	    const endOfHeaderPos = responseText.indexOf('\r\n\r\n');
	    const headerLines = responseText.substring(0, endOfHeaderPos).split('\r\n');
	    const statusLine = headerLines[0];
	    const status = statusLine.trim().split(/\s/)[1];
	    const headers = {};
	    headerLines.slice(1).forEach((line) => {
	        const colonPos = line.indexOf(':');
	        const name = line.substring(0, colonPos).trim().toLowerCase();
	        const value = line.substring(colonPos + 1).trim();
	        headers[name] = value;
	    });
	    let data = responseText.substring(endOfHeaderPos + 4);
	    if (data.endsWith('\n')) {
	        data = data.slice(0, -1);
	    }
	    if (data.endsWith('\r')) {
	        data = data.slice(0, -1);
	    }
	    const lowLevelResponse = {
	        status: parseInt(status, 10),
	        headers,
	        data,
	        config,
	        request: null,
	    };
	    if (!validator.isNumber(lowLevelResponse.status)) {
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');
	    }
	    return new DefaultRequestResponse(lowLevelResponse);
	}
	apiRequest.parseHttpResponse = parseHttpResponse;
	/**
	 * A helper class for common functionality needed to send requests over the wire.
	 * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.
	 */
	class AsyncRequestCall {
	    constructor(configImpl) {
	        this.configImpl = configImpl;
	    }
	    /**
	     * Extracts multipart boundary from the HTTP header. The content-type header of a multipart
	     * response has the form 'multipart/subtype; boundary=string'.
	     *
	     * If the content-type header does not exist, or does not start with
	     * 'multipart/', then null will be returned.
	     */
	    getMultipartBoundary(headers) {
	        const contentType = headers['content-type'];
	        if (!contentType || !contentType.startsWith('multipart/')) {
	            return null;
	        }
	        const segments = contentType.split(';');
	        const emptyObject = {};
	        const headerParams = segments.slice(1)
	            .map((segment) => segment.trim().split('='))
	            .reduce((curr, params) => {
	            // Parse key=value pairs in the content-type header into properties of an object.
	            if (params.length === 2) {
	                const keyValuePair = {};
	                keyValuePair[params[0]] = params[1];
	                return Object.assign(curr, keyValuePair);
	            }
	            return curr;
	        }, emptyObject);
	        return headerParams.boundary;
	    }
	    handleMultipartResponse(response, respStream, boundary) {
	        const busboy = /*@__PURE__*/ requireMain(); // eslint-disable-line @typescript-eslint/no-var-requires
	        const multipartParser = new busboy.Dicer({ boundary });
	        const responseBuffer = [];
	        multipartParser.on('part', (part) => {
	            const tempBuffers = [];
	            part.on('data', (partData) => {
	                tempBuffers.push(partData);
	            });
	            part.on('end', () => {
	                responseBuffer.push(Buffer.concat(tempBuffers));
	            });
	        });
	        multipartParser.on('finish', () => {
	            response.data = undefined;
	            response.multipart = responseBuffer;
	            this.finalizeResponse(response);
	        });
	        respStream.pipe(multipartParser);
	    }
	    handleRegularResponse(response, respStream) {
	        const responseBuffer = [];
	        respStream.on('data', (chunk) => {
	            responseBuffer.push(chunk);
	        });
	        respStream.on('error', (err) => {
	            const req = response.request;
	            if (req && req.destroyed) {
	                return;
	            }
	            this.enhanceAndReject(err, null, req);
	        });
	        respStream.on('end', () => {
	            response.data = Buffer.concat(responseBuffer).toString();
	            this.finalizeResponse(response);
	        });
	    }
	    /**
	     * Finalizes the current request call in-flight by either resolving or rejecting the associated
	     * promise. In the event of an error, adds additional useful information to the returned error.
	     */
	    finalizeResponse(response) {
	        if (response.status >= 200 && response.status < 300) {
	            this.resolve(response);
	        }
	        else {
	            this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);
	        }
	    }
	    /**
	     * Creates a new error from the given message, and enhances it with other information available.
	     * Then the promise associated with this request call is rejected with the resulting error.
	     */
	    rejectWithError(message, code, request, response) {
	        const error = new Error(message);
	        this.enhanceAndReject(error, code, request, response);
	    }
	    enhanceAndReject(error, code, request, response) {
	        this.reject(this.enhanceError(error, code, request, response));
	    }
	    /**
	     * Enhances the given error by adding more information to it. Specifically, the request config,
	     * the underlying request and response will be attached to the error.
	     */
	    enhanceError(error, code, request, response) {
	        error.config = this.configImpl;
	        if (code) {
	            error.code = code;
	        }
	        error.request = request;
	        error.response = response;
	        return error;
	    }
	}
	/**
	 * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard
	 * http and https packages of Node.js, providing content processing, timeouts and error handling.
	 * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.
	 */
	class AsyncHttpCall extends AsyncRequestCall {
	    /**
	     * Sends an HTTP request based on the provided configuration.
	     */
	    static invoke(config) {
	        return new AsyncHttpCall(config).promise;
	    }
	    constructor(config) {
	        const httpConfigImpl = new HttpRequestConfigImpl(config);
	        super(httpConfigImpl);
	        try {
	            this.httpConfigImpl = httpConfigImpl;
	            this.options = this.httpConfigImpl.buildRequestOptions();
	            this.entity = this.httpConfigImpl.buildEntity(this.options.headers);
	            this.promise = new Promise((resolve, reject) => {
	                this.resolve = resolve;
	                this.reject = reject;
	                this.execute();
	            });
	        }
	        catch (err) {
	            this.promise = Promise.reject(this.enhanceError(err, null));
	        }
	    }
	    execute() {
	        const transport = this.options.protocol === 'https:' ? https : http;
	        const req = transport.request(this.options, (res) => {
	            this.handleResponse(res, req);
	        });
	        // Handle errors
	        req.on('error', (err) => {
	            if (req.aborted) {
	                return;
	            }
	            this.enhanceAndReject(err, null, req);
	        });
	        const timeout = this.httpConfigImpl.timeout;
	        const timeoutCallback = () => {
	            req.destroy();
	            this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);
	        };
	        if (timeout) {
	            // Listen to timeouts and throw an error.
	            req.setTimeout(timeout, timeoutCallback);
	        }
	        // Send the request
	        req.end(this.entity);
	    }
	    handleResponse(res, req) {
	        if (req.aborted) {
	            return;
	        }
	        if (!res.statusCode) {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');
	        }
	        const response = {
	            status: res.statusCode,
	            headers: res.headers,
	            request: req,
	            data: undefined,
	            config: this.httpConfigImpl,
	        };
	        const boundary = this.getMultipartBoundary(res.headers);
	        const respStream = this.uncompressResponse(res);
	        if (boundary) {
	            this.handleMultipartResponse(response, respStream, boundary);
	        }
	        else {
	            this.handleRegularResponse(response, respStream);
	        }
	    }
	    uncompressResponse(res) {
	        // Uncompress the response body transparently if required.
	        let respStream = res;
	        const encodings = ['gzip', 'compress', 'deflate'];
	        if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) {
	            // Add the unzipper to the body stream processing pipeline.
	            const zlib = require$$8; // eslint-disable-line @typescript-eslint/no-var-requires
	            respStream = respStream.pipe(zlib.createUnzip());
	            // Remove the content-encoding in order to not confuse downstream operations.
	            delete res.headers['content-encoding'];
	        }
	        return respStream;
	    }
	}
	class AsyncHttp2Call extends AsyncRequestCall {
	    /**
	     * Sends an HTTP2 request based on the provided configuration.
	     */
	    static invoke(config) {
	        return new AsyncHttp2Call(config).promise;
	    }
	    constructor(config) {
	        const http2ConfigImpl = new Http2RequestConfigImpl(config);
	        super(http2ConfigImpl);
	        try {
	            this.http2ConfigImpl = http2ConfigImpl;
	            this.options = this.http2ConfigImpl.buildRequestOptions();
	            this.entity = this.http2ConfigImpl.buildEntity(this.options.headers);
	            this.promise = new Promise((resolve, reject) => {
	                this.resolve = resolve;
	                this.reject = reject;
	                this.execute();
	            });
	        }
	        catch (err) {
	            this.promise = Promise.reject(this.enhanceError(err, null));
	        }
	    }
	    execute() {
	        const req = this.http2ConfigImpl.http2SessionHandler.session.request({
	            ':method': this.options.method,
	            ':scheme': this.options.protocol,
	            ':path': this.options.path,
	            ...this.options.headers
	        });
	        req.on('response', (headers) => {
	            this.handleHttp2Response(headers, req);
	        });
	        // Handle errors
	        req.on('error', (err) => {
	            if (req.aborted) {
	                return;
	            }
	            this.enhanceAndReject(err, null, req);
	        });
	        const timeout = this.http2ConfigImpl.timeout;
	        const timeoutCallback = () => {
	            req.destroy();
	            this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);
	        };
	        if (timeout) {
	            // Listen to timeouts and throw an error.
	            req.setTimeout(timeout, timeoutCallback);
	        }
	        req.end(this.entity);
	    }
	    handleHttp2Response(headers, stream) {
	        if (stream.aborted) {
	            return;
	        }
	        if (!headers[':status']) {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');
	        }
	        const response = {
	            status: headers[':status'],
	            headers: headers,
	            request: stream,
	            data: undefined,
	            config: this.http2ConfigImpl,
	        };
	        const boundary = this.getMultipartBoundary(headers);
	        const respStream = this.uncompressResponse(headers, stream);
	        if (boundary) {
	            this.handleMultipartResponse(response, respStream, boundary);
	        }
	        else {
	            this.handleRegularResponse(response, respStream);
	        }
	    }
	    uncompressResponse(headers, stream) {
	        // Uncompress the response body transparently if required.
	        let respStream = stream;
	        const encodings = ['gzip', 'compress', 'deflate'];
	        if (headers['content-encoding'] && encodings.indexOf(headers['content-encoding']) !== -1) {
	            // Add the unzipper to the body stream processing pipeline.
	            const zlib = require$$8; // eslint-disable-line @typescript-eslint/no-var-requires
	            respStream = respStream.pipe(zlib.createUnzip());
	            // Remove the content-encoding in order to not confuse downstream operations.
	            delete headers['content-encoding'];
	        }
	        return respStream;
	    }
	}
	/**
	 * An adapter class with common functionality needed to extract options and entity data from a `RequestConfig`.
	 */
	class BaseRequestConfigImpl {
	    constructor(config) {
	        this.config = config;
	        this.config = config;
	    }
	    get method() {
	        return this.config.method;
	    }
	    get url() {
	        return this.config.url;
	    }
	    get headers() {
	        return this.config.headers;
	    }
	    get data() {
	        return this.config.data;
	    }
	    get timeout() {
	        return this.config.timeout;
	    }
	    buildEntity(headers) {
	        let data;
	        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {
	            return data;
	        }
	        if (validator.isBuffer(this.data)) {
	            data = this.data;
	        }
	        else if (validator.isObject(this.data)) {
	            data = Buffer.from(JSON.stringify(this.data), 'utf-8');
	            if (typeof headers['content-type'] === 'undefined') {
	                headers['content-type'] = 'application/json;charset=utf-8';
	            }
	        }
	        else if (validator.isString(this.data)) {
	            data = Buffer.from(this.data, 'utf-8');
	        }
	        else {
	            throw new Error('Request data must be a string, a Buffer or a json serializable object');
	        }
	        // Add Content-Length header if data exists.
	        headers['Content-Length'] = data.length.toString();
	        return data;
	    }
	    buildUrl() {
	        const fullUrl = this.urlWithProtocol();
	        if (!this.hasEntity() || this.isEntityEnclosingRequest()) {
	            return url.parse(fullUrl);
	        }
	        if (!validator.isObject(this.data)) {
	            throw new Error(`${this.method} requests cannot have a body`);
	        }
	        // Parse URL and append data to query string.
	        const parsedUrl = new url.URL(fullUrl);
	        const dataObj = this.data;
	        for (const key in dataObj) {
	            if (Object.prototype.hasOwnProperty.call(dataObj, key)) {
	                parsedUrl.searchParams.append(key, dataObj[key]);
	            }
	        }
	        return url.parse(parsedUrl.toString());
	    }
	    urlWithProtocol() {
	        const fullUrl = this.url;
	        if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) {
	            return fullUrl;
	        }
	        return `https://${fullUrl}`;
	    }
	    hasEntity() {
	        return !!this.data;
	    }
	    isEntityEnclosingRequest() {
	        // GET and HEAD requests do not support entity (body) in request.
	        return this.method !== 'GET' && this.method !== 'HEAD';
	    }
	}
	/**
	 * An adapter class for extracting options and entity data from an `HttpRequestConfig`.
	 */
	class HttpRequestConfigImpl extends BaseRequestConfigImpl {
	    constructor(httpConfig) {
	        super(httpConfig);
	        this.httpConfig = httpConfig;
	    }
	    get httpAgent() {
	        return this.httpConfig.httpAgent;
	    }
	    buildRequestOptions() {
	        const parsed = this.buildUrl();
	        const protocol = parsed.protocol;
	        let port = parsed.port;
	        if (!port) {
	            const isHttps = protocol === 'https:';
	            port = isHttps ? '443' : '80';
	        }
	        return {
	            protocol,
	            hostname: parsed.hostname,
	            port,
	            path: parsed.path,
	            method: this.method,
	            agent: this.httpAgent,
	            headers: Object.assign({}, this.headers),
	        };
	    }
	}
	/**
	 * An adapter class for extracting options and entity data from an `Http2RequestConfig`.
	 */
	class Http2RequestConfigImpl extends BaseRequestConfigImpl {
	    constructor(http2Config) {
	        super(http2Config);
	        this.http2Config = http2Config;
	    }
	    get http2SessionHandler() {
	        return this.http2Config.http2SessionHandler;
	    }
	    buildRequestOptions() {
	        const parsed = this.buildUrl();
	        const protocol = parsed.protocol;
	        return {
	            protocol,
	            path: parsed.path,
	            method: this.method,
	            headers: Object.assign({}, this.headers),
	        };
	    }
	}
	class AuthorizedHttpClient extends HttpClient {
	    constructor(app) {
	        super();
	        this.app = app;
	    }
	    send(request) {
	        return this.getToken().then((token) => {
	            const requestCopy = Object.assign({}, request);
	            requestCopy.headers = Object.assign({}, request.headers);
	            const authHeader = 'Authorization';
	            requestCopy.headers[authHeader] = `Bearer ${token}`;
	            // Fix issue where firebase-admin does not specify quota project that is
	            // necessary for use when utilizing human account with ADC (RSDF)
	            if (!requestCopy.headers['x-goog-user-project'] && this.app.options.projectId) {
	                requestCopy.headers['x-goog-user-project'] = this.app.options.projectId;
	            }
	            if (!requestCopy.httpAgent && this.app.options.httpAgent) {
	                requestCopy.httpAgent = this.app.options.httpAgent;
	            }
	            return super.send(requestCopy);
	        });
	    }
	    getToken() {
	        return this.app.INTERNAL.getToken()
	            .then((accessTokenObj) => accessTokenObj.accessToken);
	    }
	}
	apiRequest.AuthorizedHttpClient = AuthorizedHttpClient;
	class AuthorizedHttp2Client extends Http2Client {
	    constructor(app) {
	        super();
	        this.app = app;
	    }
	    send(request) {
	        return this.getToken().then((token) => {
	            const requestCopy = Object.assign({}, request);
	            requestCopy.headers = Object.assign({}, request.headers);
	            const authHeader = 'Authorization';
	            requestCopy.headers[authHeader] = `Bearer ${token}`;
	            return super.send(requestCopy);
	        });
	    }
	    getToken() {
	        return this.app.INTERNAL.getToken()
	            .then((accessTokenObj) => accessTokenObj.accessToken);
	    }
	}
	apiRequest.AuthorizedHttp2Client = AuthorizedHttp2Client;
	/**
	 * Class that defines all the settings for the backend API endpoint.
	 *
	 * @param endpoint - The Firebase Auth backend endpoint.
	 * @param httpMethod - The HTTP method for that endpoint.
	 * @constructor
	 */
	class ApiSettings {
	    constructor(endpoint, httpMethod = 'POST') {
	        this.endpoint = endpoint;
	        this.httpMethod = httpMethod;
	        this.setRequestValidator(null)
	            .setResponseValidator(null);
	    }
	    /** @returns The backend API endpoint. */
	    getEndpoint() {
	        return this.endpoint;
	    }
	    /** @returns The request HTTP method. */
	    getHttpMethod() {
	        return this.httpMethod;
	    }
	    /**
	     * @param requestValidator - The request validator.
	     * @returns The current API settings instance.
	     */
	    setRequestValidator(requestValidator) {
	        const nullFunction = () => undefined;
	        this.requestValidator = requestValidator || nullFunction;
	        return this;
	    }
	    /** @returns The request validator. */
	    getRequestValidator() {
	        return this.requestValidator;
	    }
	    /**
	     * @param responseValidator - The response validator.
	     * @returns The current API settings instance.
	     */
	    setResponseValidator(responseValidator) {
	        const nullFunction = () => undefined;
	        this.responseValidator = responseValidator || nullFunction;
	        return this;
	    }
	    /** @returns The response validator. */
	    getResponseValidator() {
	        return this.responseValidator;
	    }
	}
	apiRequest.ApiSettings = ApiSettings;
	/**
	 * Class used for polling an endpoint with exponential backoff.
	 *
	 * Example usage:
	 * ```
	 * const poller = new ExponentialBackoffPoller();
	 * poller
	 *     .poll(() => {
	 *       return myRequestToPoll()
	 *           .then((responseData: any) => {
	 *             if (!isValid(responseData)) {
	 *               // Continue polling.
	 *               return null;
	 *             }
	 *
	 *             // Polling complete. Resolve promise with final response data.
	 *             return responseData;
	 *           });
	 *     })
	 *     .then((responseData: any) => {
	 *       console.log(`Final response: ${responseData}`);
	 *     });
	 * ```
	 */
	class ExponentialBackoffPoller extends events_1.EventEmitter {
	    constructor(initialPollingDelayMillis = 1000, maxPollingDelayMillis = 10000, masterTimeoutMillis = 60000) {
	        super();
	        this.initialPollingDelayMillis = initialPollingDelayMillis;
	        this.maxPollingDelayMillis = maxPollingDelayMillis;
	        this.masterTimeoutMillis = masterTimeoutMillis;
	        this.numTries = 0;
	        this.completed = false;
	    }
	    /**
	     * Poll the provided callback with exponential backoff.
	     *
	     * @param callback - The callback to be called for each poll. If the
	     *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy
	     *     resolution will be used to resolve the promise returned by this method.
	     * @returns A Promise which resolves to the truthy value returned by the provided
	     *     callback when polling is complete.
	     */
	    poll(callback) {
	        if (this.pollCallback) {
	            throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');
	        }
	        this.pollCallback = callback;
	        this.on('poll', this.repoll);
	        this.masterTimer = setTimeout(() => {
	            if (this.completed) {
	                return;
	            }
	            this.markCompleted();
	            this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));
	        }, this.masterTimeoutMillis);
	        return new Promise((resolve, reject) => {
	            this.resolve = resolve;
	            this.reject = reject;
	            this.repoll();
	        });
	    }
	    repoll() {
	        this.pollCallback()
	            .then((result) => {
	            if (this.completed) {
	                return;
	            }
	            if (!result) {
	                this.repollTimer =
	                    setTimeout(() => this.emit('poll'), this.getPollingDelayMillis());
	                this.numTries++;
	                return;
	            }
	            this.markCompleted();
	            this.resolve(result);
	        })
	            .catch((err) => {
	            if (this.completed) {
	                return;
	            }
	            this.markCompleted();
	            this.reject(err);
	        });
	    }
	    getPollingDelayMillis() {
	        const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;
	        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);
	    }
	    markCompleted() {
	        this.completed = true;
	        if (this.masterTimer) {
	            clearTimeout(this.masterTimer);
	        }
	        if (this.repollTimer) {
	            clearTimeout(this.repollTimer);
	        }
	    }
	}
	apiRequest.ExponentialBackoffPoller = ExponentialBackoffPoller;
	class Http2SessionHandler {
	    constructor(url) {
	        this.http2Session = this.createSession(url);
	    }
	    createSession(url) {
	        if (!this.http2Session || this.isClosed) {
	            const opts = {
	                // Set local max concurrent stream limit to respect backend limit
	                peerMaxConcurrentStreams: 100,
	                ALPNProtocols: ['h2']
	            };
	            const http2Session = http2.connect(url, opts);
	            http2Session.on('goaway', (errorCode, _, opaqueData) => {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: GOAWAY - ${opaqueData.toString()}, Error code: ${errorCode}`);
	            });
	            http2Session.on('error', (error) => {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: ${error}`);
	            });
	            return http2Session;
	        }
	        return this.http2Session;
	    }
	    get session() {
	        return this.http2Session;
	    }
	    get isClosed() {
	        return this.http2Session.closed;
	    }
	    close() {
	        this.http2Session.close();
	    }
	}
	apiRequest.Http2SessionHandler = Http2SessionHandler;
	return apiRequest;
}

const require$$1$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(jsonwebtoken);

const require$$7$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(nodeForge);

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(credentialInternal, "__esModule", { value: true });
credentialInternal.getApplicationDefault = credentialInternal.isApplicationDefault = credentialInternal.ImpersonatedServiceAccountCredential = credentialInternal.RefreshTokenCredential = credentialInternal.ComputeEngineCredential = credentialInternal.ServiceAccountCredential = void 0;
const fs = require$$0$3;
const os = require$$1$5;
const path = require$$1$4;
const error_1$1 = error;
const api_request_1 = /*@__PURE__*/ requireApiRequest();
const util = validator$2;
const GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';
const GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';
const GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';
// NOTE: the Google Metadata Service uses HTTP over a vlan
const GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';
const GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';
const GOOGLE_METADATA_SERVICE_IDENTITY_PATH = '/computeMetadata/v1/instance/service-accounts/default/identity';
const GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';
const GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH = '/computeMetadata/v1/instance/service-accounts/default/email';
const configDir = (() => {
    // Windows has a dedicated low-rights location for apps at ~/Application Data
    const sys = os.platform();
    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {
        return process.env.APPDATA;
    }
    // On *nix the gcloud cli creates a . dir.
    return process.env.HOME && path.resolve(process.env.HOME, '.config');
})();
const GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';
const GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);
const REFRESH_TOKEN_HOST = 'www.googleapis.com';
const REFRESH_TOKEN_PATH = '/oauth2/v4/token';
const ONE_HOUR_IN_SECONDS = 60 * 60;
const JWT_ALGORITHM = 'RS256';
/**
 * Implementation of Credential that uses a service account.
 */
class ServiceAccountCredential {
    /**
     * Creates a new ServiceAccountCredential from the given parameters.
     *
     * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.
     * @param httpAgent - Optional http.Agent to use when calling the remote token server.
     * @param implicit - An optinal boolean indicating whether this credential was implicitly discovered from the
     *   environment, as opposed to being explicitly specified by the developer.
     *
     * @constructor
     */
    constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        const serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?
            ServiceAccount.fromPath(serviceAccountPathOrObject)
            : new ServiceAccount(serviceAccountPathOrObject);
        this.projectId = serviceAccount.projectId;
        this.privateKey = serviceAccount.privateKey;
        this.clientEmail = serviceAccount.clientEmail;
        this.httpClient = new api_request_1.HttpClient();
    }
    getAccessToken() {
        const token = this.createAuthJwt_();
        const postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +
            'grant-type%3Ajwt-bearer&assertion=' + token;
        const request = {
            method: 'POST',
            url: `https://${GOOGLE_AUTH_TOKEN_HOST}${GOOGLE_AUTH_TOKEN_PATH}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: postData,
            httpAgent: this.httpAgent,
        };
        return requestAccessToken(this.httpClient, request);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    createAuthJwt_() {
        const claims = {
            scope: [
                'https://www.googleapis.com/auth/cloud-platform',
                'https://www.googleapis.com/auth/firebase.database',
                'https://www.googleapis.com/auth/firebase.messaging',
                'https://www.googleapis.com/auth/identitytoolkit',
                'https://www.googleapis.com/auth/userinfo.email',
            ].join(' '),
        };
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const jwt = require$$1$2;
        // This method is actually synchronous so we can capture and return the buffer.
        return jwt.sign(claims, this.privateKey, {
            audience: GOOGLE_TOKEN_AUDIENCE,
            expiresIn: ONE_HOUR_IN_SECONDS,
            issuer: this.clientEmail,
            algorithm: JWT_ALGORITHM,
        });
    }
}
credentialInternal.ServiceAccountCredential = ServiceAccountCredential;
/**
 * A struct containing the properties necessary to use service account JSON credentials.
 */
class ServiceAccount {
    static fromPath(filePath) {
        try {
            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));
        }
        catch (error) {
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);
        }
    }
    constructor(json) {
        if (!util.isNonNullObject(json)) {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');
        }
        copyAttr(this, json, 'projectId', 'project_id');
        copyAttr(this, json, 'privateKey', 'private_key');
        copyAttr(this, json, 'clientEmail', 'client_email');
        let errorMessage;
        if (!util.isNonEmptyString(this.projectId)) {
            errorMessage = 'Service account object must contain a string "project_id" property.';
        }
        else if (!util.isNonEmptyString(this.privateKey)) {
            errorMessage = 'Service account object must contain a string "private_key" property.';
        }
        else if (!util.isNonEmptyString(this.clientEmail)) {
            errorMessage = 'Service account object must contain a string "client_email" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const forge = require$$7$1;
        try {
            forge.pki.privateKeyFromPem(this.privateKey);
        }
        catch (error) {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);
        }
    }
}
/**
 * Implementation of Credential that gets access tokens from the metadata service available
 * in the Google Cloud Platform. This authenticates the process as the default service account
 * of an App Engine instance or Google Compute Engine machine.
 */
class ComputeEngineCredential {
    constructor(httpAgent) {
        this.httpClient = new api_request_1.HttpClient();
        this.httpAgent = httpAgent;
    }
    getAccessToken() {
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);
        return requestAccessToken(this.httpClient, request);
    }
    /**
     * getIDToken returns a OIDC token from the compute metadata service
     * that can be used to make authenticated calls to audience
     * @param audience the URL the returned ID token will be used to call.
    */
    getIDToken(audience) {
        const request = this.buildRequest(`${GOOGLE_METADATA_SERVICE_IDENTITY_PATH}?audience=${audience}`);
        return requestIDToken(this.httpClient, request);
    }
    getProjectId() {
        if (this.projectId) {
            return Promise.resolve(this.projectId);
        }
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);
        return this.httpClient.send(request)
            .then((resp) => {
            this.projectId = resp.text;
            return this.projectId;
        })
            .catch((err) => {
            const detail = (err instanceof api_request_1.RequestResponseError) ? getDetailFromResponse(err.response) : err.message;
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine project ID: ${detail}`);
        });
    }
    getServiceAccountEmail() {
        if (this.accountId) {
            return Promise.resolve(this.accountId);
        }
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH);
        return this.httpClient.send(request)
            .then((resp) => {
            this.accountId = resp.text;
            return this.accountId;
        })
            .catch((err) => {
            const detail = (err instanceof api_request_1.RequestResponseError) ? getDetailFromResponse(err.response) : err.message;
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine service account email: ${detail}`);
        });
    }
    buildRequest(urlPath) {
        return {
            method: 'GET',
            url: `http://${GOOGLE_METADATA_SERVICE_HOST}${urlPath}`,
            headers: {
                'Metadata-Flavor': 'Google',
            },
            httpAgent: this.httpAgent,
        };
    }
}
credentialInternal.ComputeEngineCredential = ComputeEngineCredential;
/**
 * Implementation of Credential that gets access tokens from refresh tokens.
 */
class RefreshTokenCredential {
    /**
     * Creates a new RefreshTokenCredential from the given parameters.
     *
     * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token
     *   (user credentials) json file.
     * @param httpAgent - Optional http.Agent to use when calling the remote token server.
     * @param implicit - An optinal boolean indicating whether this credential was implicitly
     *   discovered from the environment, as opposed to being explicitly specified by the developer.
     *
     * @constructor
     */
    constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?
            RefreshToken.fromPath(refreshTokenPathOrObject)
            : new RefreshToken(refreshTokenPathOrObject);
        this.httpClient = new api_request_1.HttpClient();
    }
    getAccessToken() {
        const postData = 'client_id=' + this.refreshToken.clientId + '&' +
            'client_secret=' + this.refreshToken.clientSecret + '&' +
            'refresh_token=' + this.refreshToken.refreshToken + '&' +
            'grant_type=refresh_token';
        const request = {
            method: 'POST',
            url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: postData,
            httpAgent: this.httpAgent,
        };
        return requestAccessToken(this.httpClient, request);
    }
}
credentialInternal.RefreshTokenCredential = RefreshTokenCredential;
class RefreshToken {
    /*
     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the
     * data at the path is invalid.
     */
    static fromPath(filePath) {
        try {
            return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));
        }
        catch (error) {
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);
        }
    }
    constructor(json) {
        copyAttr(this, json, 'clientId', 'client_id');
        copyAttr(this, json, 'clientSecret', 'client_secret');
        copyAttr(this, json, 'refreshToken', 'refresh_token');
        copyAttr(this, json, 'type', 'type');
        let errorMessage;
        if (!util.isNonEmptyString(this.clientId)) {
            errorMessage = 'Refresh token must contain a "client_id" property.';
        }
        else if (!util.isNonEmptyString(this.clientSecret)) {
            errorMessage = 'Refresh token must contain a "client_secret" property.';
        }
        else if (!util.isNonEmptyString(this.refreshToken)) {
            errorMessage = 'Refresh token must contain a "refresh_token" property.';
        }
        else if (!util.isNonEmptyString(this.type)) {
            errorMessage = 'Refresh token must contain a "type" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
    }
}
/**
 * Implementation of Credential that uses impersonated service account.
 */
class ImpersonatedServiceAccountCredential {
    /**
     * Creates a new ImpersonatedServiceAccountCredential from the given parameters.
     *
     * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or
     * path to a service account json file.
     * @param httpAgent - Optional http.Agent to use when calling the remote token server.
     * @param implicit - An optional boolean indicating whether this credential was implicitly
     *   discovered from the environment, as opposed to being explicitly specified by the developer.
     *
     * @constructor
     */
    constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        this.impersonatedServiceAccount = (typeof impersonatedServiceAccountPathOrObject === 'string') ?
            ImpersonatedServiceAccount.fromPath(impersonatedServiceAccountPathOrObject)
            : new ImpersonatedServiceAccount(impersonatedServiceAccountPathOrObject);
        this.httpClient = new api_request_1.HttpClient();
    }
    getAccessToken() {
        const postData = 'client_id=' + this.impersonatedServiceAccount.clientId + '&' +
            'client_secret=' + this.impersonatedServiceAccount.clientSecret + '&' +
            'refresh_token=' + this.impersonatedServiceAccount.refreshToken + '&' +
            'grant_type=refresh_token';
        const request = {
            method: 'POST',
            url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: postData,
            httpAgent: this.httpAgent,
        };
        return requestAccessToken(this.httpClient, request);
    }
}
credentialInternal.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;
/**
 * A struct containing the properties necessary to use impersonated service account JSON credentials.
 */
class ImpersonatedServiceAccount {
    /*
     * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the
     * data at the path is invalid.
     */
    static fromPath(filePath) {
        try {
            return new ImpersonatedServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));
        }
        catch (error) {
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse impersonated service account file: ' + error);
        }
    }
    constructor(json) {
        const sourceCredentials = json['source_credentials'];
        if (sourceCredentials) {
            copyAttr(this, sourceCredentials, 'clientId', 'client_id');
            copyAttr(this, sourceCredentials, 'clientSecret', 'client_secret');
            copyAttr(this, sourceCredentials, 'refreshToken', 'refresh_token');
            copyAttr(this, sourceCredentials, 'type', 'type');
        }
        let errorMessage;
        if (!util.isNonEmptyString(this.clientId)) {
            errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_id" property.';
        }
        else if (!util.isNonEmptyString(this.clientSecret)) {
            errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_secret" property.';
        }
        else if (!util.isNonEmptyString(this.refreshToken)) {
            errorMessage = 'Impersonated Service Account must contain a "source_credentials.refresh_token" property.';
        }
        else if (!util.isNonEmptyString(this.type)) {
            errorMessage = 'Impersonated Service Account must contain a "source_credentials.type" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
    }
}
/**
 * Checks if the given credential was loaded via the application default credentials mechanism. This
 * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential
 * instances that were loaded from well-known files or environment variables, rather than being explicitly
 * instantiated.
 *
 * @param credential - The credential instance to check.
 */
function isApplicationDefault(credential) {
    return credential instanceof ComputeEngineCredential ||
        (credential instanceof ServiceAccountCredential && credential.implicit) ||
        (credential instanceof RefreshTokenCredential && credential.implicit) ||
        (credential instanceof ImpersonatedServiceAccountCredential && credential.implicit);
}
credentialInternal.isApplicationDefault = isApplicationDefault;
function getApplicationDefault(httpAgent) {
    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {
        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent, false);
    }
    // It is OK to not have this file. If it is present, it must be valid.
    if (GCLOUD_CREDENTIAL_PATH) {
        const credential = credentialFromFile(GCLOUD_CREDENTIAL_PATH, httpAgent, true);
        if (credential)
            return credential;
    }
    return new ComputeEngineCredential(httpAgent);
}
credentialInternal.getApplicationDefault = getApplicationDefault;
/**
 * Copies the specified property from one object to another.
 *
 * If no property exists by the given "key", looks for a property identified by "alt", and copies it instead.
 * This can be used to implement behaviors such as "copy property myKey or my_key".
 *
 * @param to - Target object to copy the property into.
 * @param from - Source object to copy the property from.
 * @param key - Name of the property to copy.
 * @param alt - Alternative name of the property to copy.
 */
function copyAttr(to, from, key, alt) {
    const tmp = from[key] || from[alt];
    if (typeof tmp !== 'undefined') {
        to[key] = tmp;
    }
}
/**
 * Obtain a new OAuth2 token by making a remote service call.
 */
function requestAccessToken(client, request) {
    return client.send(request).then((resp) => {
        const json = resp.data;
        if (!json.access_token || !json.expires_in) {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, `Unexpected response while fetching access token: ${JSON.stringify(json)}`);
        }
        return json;
    }).catch((err) => {
        throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));
    });
}
/**
 * Obtain a new OIDC token by making a remote service call.
 */
function requestIDToken(client, request) {
    return client.send(request).then((resp) => {
        if (!resp.text) {
            throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Unexpected response while fetching id token: response.text is undefined');
        }
        return resp.text;
    }).catch((err) => {
        throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));
    });
}
/**
 * Constructs a human-readable error message from the given Error.
 */
function getErrorMessage(err) {
    const detail = (err instanceof api_request_1.RequestResponseError) ? getDetailFromResponse(err.response) : err.message;
    return `Error fetching access token: ${detail}`;
}
/**
 * Extracts details from the given HTTP error response, and returns a human-readable description. If
 * the response is JSON-formatted, looks up the error and error_description fields sent by the
 * Google Auth servers. Otherwise returns the entire response payload as the error detail.
 */
function getDetailFromResponse(response) {
    if (response.isJson() && response.data.error) {
        const json = response.data;
        let detail = json.error;
        if (json.error_description) {
            detail += ' (' + json.error_description + ')';
        }
        return detail;
    }
    return response.text || 'Missing error payload';
}
function credentialFromFile(filePath, httpAgent, ignoreMissing) {
    const credentialsFile = readCredentialFile(filePath, ignoreMissing);
    if (typeof credentialsFile !== 'object' || credentialsFile === null) {
        if (ignoreMissing) {
            return null;
        }
        throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');
    }
    if (credentialsFile.type === 'service_account') {
        return new ServiceAccountCredential(credentialsFile, httpAgent, true);
    }
    if (credentialsFile.type === 'authorized_user') {
        return new RefreshTokenCredential(credentialsFile, httpAgent, true);
    }
    if (credentialsFile.type === 'impersonated_service_account') {
        return new ImpersonatedServiceAccountCredential(credentialsFile, httpAgent, true);
    }
    throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');
}
function readCredentialFile(filePath, ignoreMissing) {
    let fileText;
    try {
        fileText = fs.readFileSync(filePath, 'utf8');
    }
    catch (error) {
        if (ignoreMissing) {
            return null;
        }
        throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to read credentials from file ${filePath}: ` + error);
    }
    try {
        return JSON.parse(fileText);
    }
    catch (error) {
        throw new error_1$1.FirebaseAppError(error_1$1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);
    }
}

var firebaseApp = {};

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(firebaseApp, "__esModule", { value: true });
firebaseApp.FirebaseApp = firebaseApp.FirebaseAppInternals = void 0;
const credential_internal_1$2 = credentialInternal;
const validator$1 = validator$2;
const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
const error_1 = error;
const TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1000;
/**
 * Internals of a FirebaseApp instance.
 */
class FirebaseAppInternals {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    constructor(credential_) {
        this.credential_ = credential_;
        this.tokenListeners_ = [];
        this.isRefreshing = false;
    }
    getToken(forceRefresh = false) {
        if (forceRefresh || this.shouldRefresh()) {
            this.promiseToCachedToken_ = this.refreshToken();
        }
        return this.promiseToCachedToken_;
    }
    getCachedToken() {
        return this.cachedToken_ || null;
    }
    refreshToken() {
        this.isRefreshing = true;
        return Promise.resolve(this.credential_.getAccessToken())
            .then((result) => {
            // Since the developer can provide the credential implementation, we want to weakly verify
            // the return type until the type is properly exported.
            if (!validator$1.isNonNullObject(result) ||
                typeof result.expires_in !== 'number' ||
                typeof result.access_token !== 'string') {
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: "${JSON.stringify(result)}". Valid access ` +
                    'tokens must be an object with the "expires_in" (number) and "access_token" ' +
                    '(string) properties.');
            }
            const token = {
                accessToken: result.access_token,
                expirationTime: Date.now() + (result.expires_in * 1000),
            };
            if (!this.cachedToken_
                || this.cachedToken_.accessToken !== token.accessToken
                || this.cachedToken_.expirationTime !== token.expirationTime) {
                // Update the cache before firing listeners. Listeners may directly query the
                // cached token state.
                this.cachedToken_ = token;
                this.tokenListeners_.forEach((listener) => {
                    listener(token.accessToken);
                });
            }
            return token;
        })
            .catch((error) => {
            let errorMessage = (typeof error === 'string') ? error : error.message;
            errorMessage = 'Credential implementation provided to initializeApp() via the ' +
                '"credential" property failed to fetch a valid Google OAuth2 access token with the ' +
                `following error: "${errorMessage}".`;
            if (errorMessage.indexOf('invalid_grant') !== -1) {
                errorMessage += ' There are two likely causes: (1) your server time is not properly ' +
                    'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' +
                    'time on your server. To solve (2), make sure the key ID for your key file is still ' +
                    'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' +
                    'not, generate a new key file at ' +
                    'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';
            }
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        })
            .finally(() => {
            this.isRefreshing = false;
        });
    }
    shouldRefresh() {
        return (!this.cachedToken_ || (this.cachedToken_.expirationTime - Date.now()) <= TOKEN_EXPIRY_THRESHOLD_MILLIS)
            && !this.isRefreshing;
    }
    /**
     * Adds a listener that is called each time a token changes.
     *
     * @param listener - The listener that will be called with each new token.
     */
    addAuthTokenListener(listener) {
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) {
            listener(this.cachedToken_.accessToken);
        }
    }
    /**
     * Removes a token listener.
     *
     * @param listener - The listener to remove.
     */
    removeAuthTokenListener(listener) {
        this.tokenListeners_ = this.tokenListeners_.filter((other) => other !== listener);
    }
}
firebaseApp.FirebaseAppInternals = FirebaseAppInternals;
/**
 * Global context object for a collection of services using a shared authentication state.
 *
 * @internal
 */
class FirebaseApp {
    constructor(options, name, appStore) {
        this.appStore = appStore;
        this.services_ = {};
        this.isDeleted_ = false;
        this.name_ = name;
        this.options_ = (0, deep_copy_1.deepCopy)(options);
        if (!validator$1.isNonNullObject(this.options_)) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +
                `app named "${this.name_}". Options must be a non-null object.`);
        }
        const hasCredential = ('credential' in this.options_);
        if (!hasCredential) {
            this.options_.credential = (0, credential_internal_1$2.getApplicationDefault)(this.options_.httpAgent);
        }
        const credential = this.options_.credential;
        if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +
                `app named "${this.name_}". The "credential" property must be an object which implements ` +
                'the Credential interface.');
        }
        this.INTERNAL = new FirebaseAppInternals(credential);
    }
    /**
     * Returns the name of the FirebaseApp instance.
     *
     * @returns The name of the FirebaseApp instance.
     */
    get name() {
        this.checkDestroyed_();
        return this.name_;
    }
    /**
     * Returns the options for the FirebaseApp instance.
     *
     * @returns The options for the FirebaseApp instance.
     */
    get options() {
        this.checkDestroyed_();
        return (0, deep_copy_1.deepCopy)(this.options_);
    }
    /**
     * @internal
     */
    getOrInitService(name, init) {
        return this.ensureService_(name, () => init(this));
    }
    /**
     * Deletes the FirebaseApp instance.
     *
     * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.
     */
    delete() {
        this.checkDestroyed_();
        // Also remove the instance from the AppStore. This is needed to support the existing
        // app.delete() use case. In the future we can remove this API, and deleteApp() will
        // become the only way to tear down an App.
        this.appStore?.removeApp(this.name);
        return Promise.all(Object.keys(this.services_).map((serviceName) => {
            const service = this.services_[serviceName];
            if (isStateful(service)) {
                return service.delete();
            }
            return Promise.resolve();
        })).then(() => {
            this.services_ = {};
            this.isDeleted_ = true;
        });
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ensureService_(serviceName, initializer) {
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) {
            this.services_[serviceName] = initializer();
        }
        return this.services_[serviceName];
    }
    /**
     * Throws an Error if the FirebaseApp instance has already been deleted.
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    checkDestroyed_() {
        if (this.isDeleted_) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named "${this.name_}" has already been deleted.`);
        }
    }
}
firebaseApp.FirebaseApp = FirebaseApp;
function isStateful(service) {
    return typeof service.delete === 'function';
}

/*! firebase-admin v12.7.0 */

(function (exports) {
	/*!
	 * @license
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FIREBASE_CONFIG_VAR = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = exports.defaultAppStore = exports.AppStore = void 0;
	const fs = require$$0$3;
	const validator = validator$2;
	const error_1 = error;
	const credential_internal_1 = credentialInternal;
	const firebase_app_1 = firebaseApp;
	const DEFAULT_APP_NAME = '[DEFAULT]';
	class AppStore {
	    constructor() {
	        this.appStore = new Map();
	    }
	    initializeApp(options, appName = DEFAULT_APP_NAME) {
	        if (typeof options === 'undefined') {
	            options = loadOptionsFromEnvVar();
	            options.credential = (0, credential_internal_1.getApplicationDefault)();
	        }
	        if (typeof appName !== 'string' || appName === '') {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
	        }
	        else if (this.appStore.has(appName)) {
	            if (appName === DEFAULT_APP_NAME) {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' +
	                    'more than once without providing an app name as the second argument. In most cases ' +
	                    'you only need to call initializeApp() once. But if you do want to initialize ' +
	                    'multiple apps, pass a second argument to initializeApp() to give each app a unique ' +
	                    'name.');
	            }
	            else {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named "${appName}" already exists. This means you called initializeApp() ` +
	                    'more than once with the same app name as the second argument. Make sure you provide a ' +
	                    'unique name every time you call initializeApp().');
	            }
	        }
	        const app = new firebase_app_1.FirebaseApp(options, appName, this);
	        this.appStore.set(app.name, app);
	        return app;
	    }
	    getApp(appName = DEFAULT_APP_NAME) {
	        if (typeof appName !== 'string' || appName === '') {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
	        }
	        else if (!this.appStore.has(appName)) {
	            let errorMessage = (appName === DEFAULT_APP_NAME)
	                ? 'The default Firebase app does not exist. ' : `Firebase app named "${appName}" does not exist. `;
	            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);
	        }
	        return this.appStore.get(appName);
	    }
	    getApps() {
	        // Return a copy so the caller cannot mutate the array
	        return Array.from(this.appStore.values());
	    }
	    deleteApp(app) {
	        if (typeof app !== 'object' || app === null || !('options' in app)) {
	            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');
	        }
	        // Make sure the given app already exists.
	        const existingApp = getApp(app.name);
	        // Delegate delete operation to the App instance itself. That will also remove the App
	        // instance from the AppStore.
	        return existingApp.delete();
	    }
	    clearAllApps() {
	        const promises = [];
	        this.getApps().forEach((app) => {
	            promises.push(this.deleteApp(app));
	        });
	        return Promise.all(promises).then();
	    }
	    /**
	     * Removes the specified App instance from the store. This is currently called by the
	     * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled
	     * entirely by the {@link deleteApp} top-level function.
	     */
	    removeApp(appName) {
	        this.appStore.delete(appName);
	    }
	}
	exports.AppStore = AppStore;
	exports.defaultAppStore = new AppStore();
	function initializeApp(options, appName = DEFAULT_APP_NAME) {
	    return exports.defaultAppStore.initializeApp(options, appName);
	}
	exports.initializeApp = initializeApp;
	function getApp(appName = DEFAULT_APP_NAME) {
	    return exports.defaultAppStore.getApp(appName);
	}
	exports.getApp = getApp;
	function getApps() {
	    return exports.defaultAppStore.getApps();
	}
	exports.getApps = getApps;
	/**
	 * Renders this given `App` unusable and frees the resources of
	 * all associated services (though it does *not* clean up any backend
	 * resources). When running the SDK locally, this method
	 * must be called to ensure graceful termination of the process.
	 *
	 * @example
	 * ```javascript
	 * deleteApp(app)
	 *   .then(function() {
	 *     console.log("App deleted successfully");
	 *   })
	 *   .catch(function(error) {
	 *     console.log("Error deleting app:", error);
	 *   });
	 * ```
	 */
	function deleteApp(app) {
	    return exports.defaultAppStore.deleteApp(app);
	}
	exports.deleteApp = deleteApp;
	/**
	 * Constant holding the environment variable name with the default config.
	 * If the environment variable contains a string that starts with '{' it will be parsed as JSON,
	 * otherwise it will be assumed to be pointing to a file.
	 */
	exports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';
	/**
	 * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.
	 * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.
	 * If the environment variable contains a string that starts with '{' it will be parsed as JSON,
	 * otherwise it will be assumed to be pointing to a file.
	 */
	function loadOptionsFromEnvVar() {
	    const config = process.env[exports.FIREBASE_CONFIG_VAR];
	    if (!validator.isNonEmptyString(config)) {
	        return {};
	    }
	    try {
	        const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');
	        return JSON.parse(contents);
	    }
	    catch (error) {
	        // Throw a nicely formed error message if the file contents cannot be parsed
	        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);
	    }
	} 
} (lifecycle));

var credentialFactory = {};

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(credentialFactory, "__esModule", { value: true });
credentialFactory.clearGlobalAppDefaultCred = credentialFactory.refreshToken = credentialFactory.cert = credentialFactory.applicationDefault = void 0;
const credential_internal_1$1 = credentialInternal;
let globalAppDefaultCred;
const globalCertCreds = {};
const globalRefreshTokenCreds = {};
/**
 * Returns a credential created from the
 * {@link https://developers.google.com/identity/protocols/application-default-credentials |
 * Google Application Default Credentials}
 * that grants admin access to Firebase services. This credential can be used
 * in the call to {@link firebase-admin.app#initializeApp}.
 *
 * Google Application Default Credentials are available on any Google
 * infrastructure, such as Google App Engine and Google Compute Engine.
 *
 * See
 * {@link https://firebase.google.com/docs/admin/setup#initialize_the_sdk | Initialize the SDK}
 * for more details.
 *
 * @example
 * ```javascript
 * initializeApp({
 *   credential: applicationDefault(),
 *   databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
 * });
 * ```
 *
 * @param httpAgent - Optional {@link https://nodejs.org/api/http.html#http_class_http_agent | HTTP Agent}
 *   to be used when retrieving access tokens from Google token servers.
 *
 * @returns A credential authenticated via Google
 *   Application Default Credentials that can be used to initialize an app.
 */
function applicationDefault(httpAgent) {
    if (typeof globalAppDefaultCred === 'undefined') {
        globalAppDefaultCred = (0, credential_internal_1$1.getApplicationDefault)(httpAgent);
    }
    return globalAppDefaultCred;
}
credentialFactory.applicationDefault = applicationDefault;
/**
 * Returns a credential created from the provided service account that grants
 * admin access to Firebase services. This credential can be used in the call
 * to {@link firebase-admin.app#initializeApp}.
 *
 * See
 * {@link https://firebase.google.com/docs/admin/setup#initialize_the_sdk | Initialize the SDK}
 * for more details.
 *
 * @example
 * ```javascript
 * // Providing a path to a service account key JSON file
 * const serviceAccount = require("path/to/serviceAccountKey.json");
 * initializeApp({
 *   credential: cert(serviceAccount),
 *   databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
 * });
 * ```
 *
 * @example
 * ```javascript
 * // Providing a service account object inline
 * initializeApp({
 *   credential: cert({
 *     projectId: "<PROJECT_ID>",
 *     clientEmail: "foo@<PROJECT_ID>.iam.gserviceaccount.com",
 *     privateKey: "-----BEGIN PRIVATE KEY-----<KEY>-----END PRIVATE KEY-----\n"
 *   }),
 *   databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
 * });
 * ```
 *
 * @param serviceAccountPathOrObject - The path to a service
 *   account key JSON file or an object representing a service account key.
 * @param httpAgent - Optional {@link https://nodejs.org/api/http.html#http_class_http_agent | HTTP Agent}
 *   to be used when retrieving access tokens from Google token servers.
 *
 * @returns A credential authenticated via the
 *   provided service account that can be used to initialize an app.
 */
function cert(serviceAccountPathOrObject, httpAgent) {
    const stringifiedServiceAccount = JSON.stringify(serviceAccountPathOrObject);
    if (!(stringifiedServiceAccount in globalCertCreds)) {
        globalCertCreds[stringifiedServiceAccount] = new credential_internal_1$1.ServiceAccountCredential(serviceAccountPathOrObject, httpAgent);
    }
    return globalCertCreds[stringifiedServiceAccount];
}
credentialFactory.cert = cert;
/**
 * Returns a credential created from the provided refresh token that grants
 * admin access to Firebase services. This credential can be used in the call
 * to {@link firebase-admin.app#initializeApp}.
 *
 * See
 * {@link https://firebase.google.com/docs/admin/setup#initialize_the_sdk | Initialize the SDK}
 * for more details.
 *
 * @example
 * ```javascript
 * // Providing a path to a refresh token JSON file
 * const refreshToken = require("path/to/refreshToken.json");
 * initializeApp({
 *   credential: refreshToken(refreshToken),
 *   databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
 * });
 * ```
 *
 * @param refreshTokenPathOrObject - The path to a Google
 *   OAuth2 refresh token JSON file or an object representing a Google OAuth2
 *   refresh token.
 * @param httpAgent - Optional {@link https://nodejs.org/api/http.html#http_class_http_agent | HTTP Agent}
 *   to be used when retrieving access tokens from Google token servers.
 *
 * @returns A credential authenticated via the
 *   provided service account that can be used to initialize an app.
 */
function refreshToken(refreshTokenPathOrObject, httpAgent) {
    const stringifiedRefreshToken = JSON.stringify(refreshTokenPathOrObject);
    if (!(stringifiedRefreshToken in globalRefreshTokenCreds)) {
        globalRefreshTokenCreds[stringifiedRefreshToken] = new credential_internal_1$1.RefreshTokenCredential(refreshTokenPathOrObject, httpAgent);
    }
    return globalRefreshTokenCreds[stringifiedRefreshToken];
}
credentialFactory.refreshToken = refreshToken;
/**
 * Clears the global ADC cache. Exported for testing.
 */
function clearGlobalAppDefaultCred() {
    globalAppDefaultCred = undefined;
}
credentialFactory.clearGlobalAppDefaultCred = clearGlobalAppDefaultCred;

var utils$1 = {};

var version = "12.7.0";
const require$$4$1 = {
	version: version};

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(utils$1, "__esModule", { value: true });
utils$1.parseResourceName = utils$1.transformMillisecondsToSecondsString = utils$1.generateUpdateMask = utils$1.formatString = utils$1.toWebSafeBase64 = utils$1.findServiceAccountEmail = utils$1.getExplicitServiceAccountEmail = utils$1.findProjectId = utils$1.getExplicitProjectId = utils$1.addReadonlyGetter = utils$1.renameProperties = utils$1.getSdkVersion = void 0;
const credential_internal_1 = credentialInternal;
const validator = validator$2;
let sdkVersion;
// TODO: Move to firebase-admin/app as an internal member.
function getSdkVersion() {
    if (!sdkVersion) {
        const { version } = require$$4$1; // eslint-disable-line @typescript-eslint/no-var-requires
        sdkVersion = version;
    }
    return sdkVersion;
}
utils$1.getSdkVersion = getSdkVersion;
/**
 * Renames properties on an object given a mapping from old to new property names.
 *
 * For example, this can be used to map underscore_cased properties to camelCase.
 *
 * @param obj - The object whose properties to rename.
 * @param keyMap - The mapping from old to new property names.
 */
function renameProperties(obj, keyMap) {
    Object.keys(keyMap).forEach((oldKey) => {
        if (oldKey in obj) {
            const newKey = keyMap[oldKey];
            // The old key's value takes precedence over the new key's value.
            obj[newKey] = obj[oldKey];
            delete obj[oldKey];
        }
    });
}
utils$1.renameProperties = renameProperties;
/**
 * Defines a new read-only property directly on an object and returns the object.
 *
 * @param obj - The object on which to define the property.
 * @param prop - The name of the property to be defined or modified.
 * @param value - The value associated with the property.
 */
function addReadonlyGetter(obj, prop, value) {
    Object.defineProperty(obj, prop, {
        value,
        // Make this property read-only.
        writable: false,
        // Include this property during enumeration of obj's properties.
        enumerable: true,
    });
}
utils$1.addReadonlyGetter = addReadonlyGetter;
/**
 * Returns the Google Cloud project ID associated with a Firebase app, if it's explicitly
 * specified in either the Firebase app options, credentials or the local environment.
 * Otherwise returns null.
 *
 * @param app - A Firebase app to get the project ID from.
 *
 * @returns A project ID string or null.
 */
function getExplicitProjectId(app) {
    const options = app.options;
    if (validator.isNonEmptyString(options.projectId)) {
        return options.projectId;
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.projectId;
    }
    const projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;
    if (validator.isNonEmptyString(projectId)) {
        return projectId;
    }
    return null;
}
utils$1.getExplicitProjectId = getExplicitProjectId;
/**
 * Determines the Google Cloud project ID associated with a Firebase app. This method
 * first checks if a project ID is explicitly specified in either the Firebase app options,
 * credentials or the local environment in that order. If no explicit project ID is
 * configured, but the SDK has been initialized with ComputeEngineCredentials, this
 * method attempts to discover the project ID from the local metadata service.
 *
 * @param app - A Firebase app to get the project ID from.
 *
 * @returns A project ID string or null.
 */
function findProjectId(app) {
    const projectId = getExplicitProjectId(app);
    if (projectId) {
        return Promise.resolve(projectId);
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ComputeEngineCredential) {
        return credential.getProjectId();
    }
    return Promise.resolve(null);
}
utils$1.findProjectId = findProjectId;
/**
 * Returns the service account email associated with a Firebase app, if it's explicitly
 * specified in either the Firebase app options, credentials or the local environment.
 * Otherwise returns null.
 *
 * @param app - A Firebase app to get the service account email from.
 *
 * @returns A service account email string or null.
 */
function getExplicitServiceAccountEmail(app) {
    const options = app.options;
    if (validator.isNonEmptyString(options.serviceAccountId)) {
        return options.serviceAccountId;
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.clientEmail;
    }
    return null;
}
utils$1.getExplicitServiceAccountEmail = getExplicitServiceAccountEmail;
/**
 * Determines the service account email associated with a Firebase app. This method first
 * checks if a service account email is explicitly specified in either the Firebase app options,
 * credentials or the local environment in that order. If no explicit service account email is
 * configured, but the SDK has been initialized with ComputeEngineCredentials, this
 * method attempts to discover the service account email from the local metadata service.
 *
 * @param app - A Firebase app to get the service account email from.
 *
 * @returns A service account email ID string or null.
 */
function findServiceAccountEmail(app) {
    const accountId = getExplicitServiceAccountEmail(app);
    if (accountId) {
        return Promise.resolve(accountId);
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ComputeEngineCredential) {
        return credential.getServiceAccountEmail();
    }
    return Promise.resolve(null);
}
utils$1.findServiceAccountEmail = findServiceAccountEmail;
/**
 * Encodes data using web-safe-base64.
 *
 * @param data - The raw data byte input.
 * @returns The base64-encoded result.
 */
function toWebSafeBase64(data) {
    return data.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
}
utils$1.toWebSafeBase64 = toWebSafeBase64;
/**
 * Formats a string of form 'project/{projectId}/{api}' and replaces
 * with corresponding arguments {projectId: '1234', api: 'resource'}
 * and returns output: 'project/1234/resource'.
 *
 * @param str - The original string where the param need to be
 *     replaced.
 * @param params - The optional parameters to replace in the
 *     string.
 * @returns The resulting formatted string.
 */
function formatString(str, params) {
    let formatted = str;
    Object.keys(params || {}).forEach((key) => {
        formatted = formatted.replace(new RegExp('{' + key + '}', 'g'), params[key]);
    });
    return formatted;
}
utils$1.formatString = formatString;
/**
 * Generates the update mask for the provided object.
 * Note this will ignore the last key with value undefined.
 *
 * @param obj - The object to generate the update mask for.
 * @param terminalPaths - The optional map of keys for maximum paths to traverse.
 *      Nested objects beyond that path will be ignored. This is useful for
 *      keys with variable object values.
 * @param root - The path so far.
 * @returns The computed update mask list.
 */
function generateUpdateMask(obj, terminalPaths = [], root = '') {
    const updateMask = [];
    if (!validator.isNonNullObject(obj)) {
        return updateMask;
    }
    for (const key in obj) {
        if (typeof obj[key] !== 'undefined') {
            const nextPath = root ? `${root}.${key}` : key;
            // We hit maximum path.
            // Consider switching to Set<string> if the list grows too large.
            if (terminalPaths.indexOf(nextPath) !== -1) {
                // Add key and stop traversing this branch.
                updateMask.push(key);
            }
            else {
                const maskList = generateUpdateMask(obj[key], terminalPaths, nextPath);
                if (maskList.length > 0) {
                    maskList.forEach((mask) => {
                        updateMask.push(`${key}.${mask}`);
                    });
                }
                else {
                    updateMask.push(key);
                }
            }
        }
    }
    return updateMask;
}
utils$1.generateUpdateMask = generateUpdateMask;
/**
 * Transforms milliseconds to a protobuf Duration type string.
 * Returns the duration in seconds with up to nine fractional
 * digits, terminated by 's'. Example: "3 seconds 0 nano seconds as 3s,
 * 3 seconds 1 nano seconds as 3.000000001s".
 *
 * @param milliseconds - The duration in milliseconds.
 * @returns The resulting formatted string in seconds with up to nine fractional
 * digits, terminated by 's'.
 */
function transformMillisecondsToSecondsString(milliseconds) {
    let duration;
    const seconds = Math.floor(milliseconds / 1000);
    const nanos = Math.floor((milliseconds - seconds * 1000) * 1000000);
    if (nanos > 0) {
        let nanoString = nanos.toString();
        while (nanoString.length < 9) {
            nanoString = '0' + nanoString;
        }
        duration = `${seconds}.${nanoString}s`;
    }
    else {
        duration = `${seconds}s`;
    }
    return duration;
}
utils$1.transformMillisecondsToSecondsString = transformMillisecondsToSecondsString;
/**
 * Parses the top level resources of a given resource name.
 * Supports both full and partial resources names, example:
 * `locations/{location}/functions/{functionName}`,
 * `projects/{project}/locations/{location}/functions/{functionName}`, or {functionName}
 * Does not support deeply nested resource names.
 *
 * @param resourceName - The resource name string.
 * @param resourceIdKey - The key of the resource name to be parsed.
 * @returns A parsed resource name object.
 */
function parseResourceName(resourceName, resourceIdKey) {
    if (!resourceName.includes('/')) {
        return { resourceId: resourceName };
    }
    const CHANNEL_NAME_REGEX = new RegExp(`^(projects/([^/]+)/)?locations/([^/]+)/${resourceIdKey}/([^/]+)$`);
    const match = CHANNEL_NAME_REGEX.exec(resourceName);
    if (match === null) {
        throw new Error('Invalid resource name format.');
    }
    const projectId = match[2];
    const locationId = match[3];
    const resourceId = match[4];
    return { projectId, locationId, resourceId };
}
utils$1.parseResourceName = parseResourceName;

var auth$1 = {};

var authApiRequest = {};

var userImportBuilder = {};

/*! firebase-admin v12.7.0 */

var hasRequiredUserImportBuilder;

function requireUserImportBuilder () {
	if (hasRequiredUserImportBuilder) return userImportBuilder;
	hasRequiredUserImportBuilder = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(userImportBuilder, "__esModule", { value: true });
	userImportBuilder.UserImportBuilder = userImportBuilder.convertMultiFactorInfoToServerFormat = void 0;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const utils = utils$1;
	const validator = validator$2;
	const error_1 = error;
	/**
	 * Converts a client format second factor object to server format.
	 * @param multiFactorInfo - The client format second factor.
	 * @returns The corresponding AuthFactorInfo server request format.
	 */
	function convertMultiFactorInfoToServerFormat(multiFactorInfo) {
	    let enrolledAt;
	    if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {
	        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {
	            // Convert from UTC date string (client side format) to ISO date string (server side format).
	            enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();
	        }
	        else {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${multiFactorInfo.uid}" must be a valid ` +
	                'UTC date string.');
	        }
	    }
	    // Currently only phone second factors are supported.
	    if (isPhoneFactor(multiFactorInfo)) {
	        // If any required field is missing or invalid, validation will still fail later.
	        const authFactorInfo = {
	            mfaEnrollmentId: multiFactorInfo.uid,
	            displayName: multiFactorInfo.displayName,
	            // Required for all phone second factors.
	            phoneInfo: multiFactorInfo.phoneNumber,
	            enrolledAt,
	        };
	        for (const objKey in authFactorInfo) {
	            if (typeof authFactorInfo[objKey] === 'undefined') {
	                delete authFactorInfo[objKey];
	            }
	        }
	        return authFactorInfo;
	    }
	    else {
	        // Unsupported second factor.
	        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor "${JSON.stringify(multiFactorInfo)}" provided.`);
	    }
	}
	userImportBuilder.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;
	function isPhoneFactor(multiFactorInfo) {
	    return multiFactorInfo.factorId === 'phone';
	}
	/**
	 * @param {any} obj The object to check for number field within.
	 * @param {string} key The entry key.
	 * @returns {number} The corresponding number if available. Otherwise, NaN.
	 */
	function getNumberField(obj, key) {
	    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {
	        return parseInt(obj[key].toString(), 10);
	    }
	    return NaN;
	}
	/**
	 * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid
	 * fields are provided.
	 * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.
	 * @param {ValidatorFunction=} userValidator The user validator function.
	 * @returns {UploadAccountUser} The corresponding UploadAccountUser to return.
	 */
	function populateUploadAccountUser(user, userValidator) {
	    const result = {
	        localId: user.uid,
	        email: user.email,
	        emailVerified: user.emailVerified,
	        displayName: user.displayName,
	        disabled: user.disabled,
	        photoUrl: user.photoURL,
	        phoneNumber: user.phoneNumber,
	        providerUserInfo: [],
	        mfaInfo: [],
	        tenantId: user.tenantId,
	        customAttributes: user.customClaims && JSON.stringify(user.customClaims),
	    };
	    if (typeof user.passwordHash !== 'undefined') {
	        if (!validator.isBuffer(user.passwordHash)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
	        }
	        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);
	    }
	    if (typeof user.passwordSalt !== 'undefined') {
	        if (!validator.isBuffer(user.passwordSalt)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
	        }
	        result.salt = utils.toWebSafeBase64(user.passwordSalt);
	    }
	    if (validator.isNonNullObject(user.metadata)) {
	        if (validator.isNonEmptyString(user.metadata.creationTime)) {
	            result.createdAt = new Date(user.metadata.creationTime).getTime();
	        }
	        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {
	            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();
	        }
	    }
	    if (validator.isArray(user.providerData)) {
	        user.providerData.forEach((providerData) => {
	            result.providerUserInfo.push({
	                providerId: providerData.providerId,
	                rawId: providerData.uid,
	                email: providerData.email,
	                displayName: providerData.displayName,
	                photoUrl: providerData.photoURL,
	            });
	        });
	    }
	    // Convert user.multiFactor.enrolledFactors to server format.
	    if (validator.isNonNullObject(user.multiFactor) &&
	        validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {
	        user.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
	            result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));
	        });
	    }
	    // Remove blank fields.
	    let key;
	    for (key in result) {
	        if (typeof result[key] === 'undefined') {
	            delete result[key];
	        }
	    }
	    if (result.providerUserInfo.length === 0) {
	        delete result.providerUserInfo;
	    }
	    if (result.mfaInfo.length === 0) {
	        delete result.mfaInfo;
	    }
	    // Validate the constructured user individual request. This will throw if an error
	    // is detected.
	    if (typeof userValidator === 'function') {
	        userValidator(result);
	    }
	    return result;
	}
	/**
	 * Class that provides a helper for building/validating uploadAccount requests and
	 * UserImportResult responses.
	 */
	class UserImportBuilder {
	    /**
	     * @param {UserImportRecord[]} users The list of user records to import.
	     * @param {UserImportOptions=} options The import options which includes hashing
	     *     algorithm details.
	     * @param {ValidatorFunction=} userRequestValidator The user request validator function.
	     * @constructor
	     */
	    constructor(users, options, userRequestValidator) {
	        this.requiresHashOptions = false;
	        this.validatedUsers = [];
	        this.userImportResultErrors = [];
	        this.indexMap = {};
	        this.validatedUsers = this.populateUsers(users, userRequestValidator);
	        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);
	    }
	    /**
	     * Returns the corresponding constructed uploadAccount request.
	     * @returns {UploadAccountRequest} The constructed uploadAccount request.
	     */
	    buildRequest() {
	        const users = this.validatedUsers.map((user) => {
	            return (0, deep_copy_1.deepCopy)(user);
	        });
	        return (0, deep_copy_1.deepExtend)({ users }, (0, deep_copy_1.deepCopy)(this.validatedOptions));
	    }
	    /**
	     * Populates the UserImportResult using the client side detected errors and the server
	     * side returned errors.
	     * @returns {UserImportResult} The user import result based on the returned failed
	     *     uploadAccount response.
	     */
	    buildResponse(failedUploads) {
	        // Initialize user import result.
	        const importResult = {
	            successCount: this.validatedUsers.length,
	            failureCount: this.userImportResultErrors.length,
	            errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors),
	        };
	        importResult.failureCount += failedUploads.length;
	        importResult.successCount -= failedUploads.length;
	        failedUploads.forEach((failedUpload) => {
	            importResult.errors.push({
	                // Map backend request index to original developer provided array index.
	                index: this.indexMap[failedUpload.index],
	                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),
	            });
	        });
	        // Sort errors by index.
	        importResult.errors.sort((a, b) => {
	            return a.index - b.index;
	        });
	        // Return sorted result.
	        return importResult;
	    }
	    /**
	     * Validates and returns the hashing options of the uploadAccount request.
	     * Throws an error whenever an invalid or missing options is detected.
	     * @param {UserImportOptions} options The UserImportOptions.
	     * @param {boolean} requiresHashOptions Whether to require hash options.
	     * @returns {UploadAccountOptions} The populated UploadAccount options.
	     */
	    populateOptions(options, requiresHashOptions) {
	        let populatedOptions;
	        if (!requiresHashOptions) {
	            return {};
	        }
	        if (!validator.isNonNullObject(options)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UserImportOptions" are required when importing users with passwords.');
	        }
	        if (!validator.isNonNullObject(options.hash)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '"hash.algorithm" is missing from the provided "UserImportOptions".');
	        }
	        if (typeof options.hash.algorithm === 'undefined' ||
	            !validator.isNonEmptyString(options.hash.algorithm)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '"hash.algorithm" must be a string matching the list of supported algorithms.');
	        }
	        let rounds;
	        switch (options.hash.algorithm) {
	            case 'HMAC_SHA512':
	            case 'HMAC_SHA256':
	            case 'HMAC_SHA1':
	            case 'HMAC_MD5':
	                if (!validator.isBuffer(options.hash.key)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty "hash.key" byte buffer must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                    signerKey: utils.toWebSafeBase64(options.hash.key),
	                };
	                break;
	            case 'MD5':
	            case 'SHA1':
	            case 'SHA256':
	            case 'SHA512': {
	                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]
	                rounds = getNumberField(options.hash, 'rounds');
	                const minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;
	                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between ${minRounds} and 8192 must be provided for ` +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                    rounds,
	                };
	                break;
	            }
	            case 'PBKDF_SHA1':
	            case 'PBKDF2_SHA256':
	                rounds = getNumberField(options.hash, 'rounds');
	                if (isNaN(rounds) || rounds < 0 || rounds > 120000) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid "hash.rounds" number between 0 and 120000 must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                    rounds,
	                };
	                break;
	            case 'SCRYPT': {
	                if (!validator.isBuffer(options.hash.key)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A "hash.key" byte buffer must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                rounds = getNumberField(options.hash, 'rounds');
	                if (isNaN(rounds) || rounds <= 0 || rounds > 8) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid "hash.rounds" number between 1 and 8 must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                const memoryCost = getNumberField(options.hash, 'memoryCost');
	                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid "hash.memoryCost" number between 1 and 14 must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                if (typeof options.hash.saltSeparator !== 'undefined' &&
	                    !validator.isBuffer(options.hash.saltSeparator)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '"hash.saltSeparator" must be a byte buffer.');
	                }
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                    signerKey: utils.toWebSafeBase64(options.hash.key),
	                    rounds,
	                    memoryCost,
	                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),
	                };
	                break;
	            }
	            case 'BCRYPT':
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                };
	                break;
	            case 'STANDARD_SCRYPT': {
	                const cpuMemCost = getNumberField(options.hash, 'memoryCost');
	                if (isNaN(cpuMemCost)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid "hash.memoryCost" number must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                const parallelization = getNumberField(options.hash, 'parallelization');
	                if (isNaN(parallelization)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid "hash.parallelization" number must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                const blockSize = getNumberField(options.hash, 'blockSize');
	                if (isNaN(blockSize)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid "hash.blockSize" number must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                const dkLen = getNumberField(options.hash, 'derivedKeyLength');
	                if (isNaN(dkLen)) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid "hash.derivedKeyLength" number must be provided for ' +
	                        `hash algorithm ${options.hash.algorithm}.`);
	                }
	                populatedOptions = {
	                    hashAlgorithm: options.hash.algorithm,
	                    cpuMemCost,
	                    parallelization,
	                    blockSize,
	                    dkLen,
	                };
	                break;
	            }
	            default:
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider "${options.hash.algorithm}".`);
	        }
	        return populatedOptions;
	    }
	    /**
	     * Validates and returns the users list of the uploadAccount request.
	     * Whenever a user with an error is detected, the error is cached and will later be
	     * merged into the user import result. This allows the processing of valid users without
	     * failing early on the first error detected.
	     * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser
	     *     objects.
	     * @param {ValidatorFunction=} userValidator The user validator function.
	     * @returns {UploadAccountUser[]} The populated uploadAccount users.
	     */
	    populateUsers(users, userValidator) {
	        const populatedUsers = [];
	        users.forEach((user, index) => {
	            try {
	                const result = populateUploadAccountUser(user, userValidator);
	                if (typeof result.passwordHash !== 'undefined') {
	                    this.requiresHashOptions = true;
	                }
	                // Only users that pass client screening will be passed to backend for processing.
	                populatedUsers.push(result);
	                // Map user's index (the one to be sent to backend) to original developer provided array.
	                this.indexMap[populatedUsers.length - 1] = index;
	            }
	            catch (error) {
	                // Save the client side error with respect to the developer provided array.
	                this.userImportResultErrors.push({
	                    index,
	                    error,
	                });
	            }
	        });
	        return populatedUsers;
	    }
	}
	userImportBuilder.UserImportBuilder = UserImportBuilder;
	return userImportBuilder;
}

var actionCodeSettingsBuilder = {};

/*! firebase-admin v12.7.0 */

var hasRequiredActionCodeSettingsBuilder;

function requireActionCodeSettingsBuilder () {
	if (hasRequiredActionCodeSettingsBuilder) return actionCodeSettingsBuilder;
	hasRequiredActionCodeSettingsBuilder = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(actionCodeSettingsBuilder, "__esModule", { value: true });
	actionCodeSettingsBuilder.ActionCodeSettingsBuilder = void 0;
	const validator = validator$2;
	const error_1 = error;
	/**
	 * Defines the ActionCodeSettings builder class used to convert the
	 * ActionCodeSettings object to its corresponding server request.
	 *
	 * @internal
	 */
	class ActionCodeSettingsBuilder {
	    /**
	     * ActionCodeSettingsBuilder constructor.
	     *
	     * @param {ActionCodeSettings} actionCodeSettings The ActionCodeSettings
	     *     object used to initiliaze this server request builder.
	     * @constructor
	     */
	    constructor(actionCodeSettings) {
	        if (!validator.isNonNullObject(actionCodeSettings)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings" must be a non-null object.');
	        }
	        if (typeof actionCodeSettings.url === 'undefined') {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_CONTINUE_URI);
	        }
	        else if (!validator.isURL(actionCodeSettings.url)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONTINUE_URI);
	        }
	        this.continueUrl = actionCodeSettings.url;
	        if (typeof actionCodeSettings.handleCodeInApp !== 'undefined' &&
	            !validator.isBoolean(actionCodeSettings.handleCodeInApp)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.handleCodeInApp" must be a boolean.');
	        }
	        this.canHandleCodeInApp = actionCodeSettings.handleCodeInApp || false;
	        if (typeof actionCodeSettings.dynamicLinkDomain !== 'undefined' &&
	            !validator.isNonEmptyString(actionCodeSettings.dynamicLinkDomain)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN);
	        }
	        this.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
	        if (typeof actionCodeSettings.iOS !== 'undefined') {
	            if (!validator.isNonNullObject(actionCodeSettings.iOS)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS" must be a valid non-null object.');
	            }
	            else if (typeof actionCodeSettings.iOS.bundleId === 'undefined') {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_IOS_BUNDLE_ID);
	            }
	            else if (!validator.isNonEmptyString(actionCodeSettings.iOS.bundleId)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS.bundleId" must be a valid non-empty string.');
	            }
	            this.ibi = actionCodeSettings.iOS.bundleId;
	        }
	        if (typeof actionCodeSettings.android !== 'undefined') {
	            if (!validator.isNonNullObject(actionCodeSettings.android)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android" must be a valid non-null object.');
	            }
	            else if (typeof actionCodeSettings.android.packageName === 'undefined') {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME);
	            }
	            else if (!validator.isNonEmptyString(actionCodeSettings.android.packageName)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.packageName" must be a valid non-empty string.');
	            }
	            else if (typeof actionCodeSettings.android.minimumVersion !== 'undefined' &&
	                !validator.isNonEmptyString(actionCodeSettings.android.minimumVersion)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.minimumVersion" must be a valid non-empty string.');
	            }
	            else if (typeof actionCodeSettings.android.installApp !== 'undefined' &&
	                !validator.isBoolean(actionCodeSettings.android.installApp)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.installApp" must be a valid boolean.');
	            }
	            this.apn = actionCodeSettings.android.packageName;
	            this.amv = actionCodeSettings.android.minimumVersion;
	            this.installApp = actionCodeSettings.android.installApp || false;
	        }
	    }
	    /**
	     * Returns the corresponding constructed server request corresponding to the
	     * current ActionCodeSettings.
	     *
	     * @returns The constructed EmailActionCodeRequest request.
	     */
	    buildRequest() {
	        const request = {
	            continueUrl: this.continueUrl,
	            canHandleCodeInApp: this.canHandleCodeInApp,
	            dynamicLinkDomain: this.dynamicLinkDomain,
	            androidPackageName: this.apn,
	            androidMinimumVersion: this.amv,
	            androidInstallApp: this.installApp,
	            iOSBundleId: this.ibi,
	        };
	        // Remove all null and undefined fields from request.
	        for (const key in request) {
	            if (Object.prototype.hasOwnProperty.call(request, key)) {
	                if (typeof request[key] === 'undefined' || request[key] === null) {
	                    delete request[key];
	                }
	            }
	        }
	        return request;
	    }
	}
	actionCodeSettingsBuilder.ActionCodeSettingsBuilder = ActionCodeSettingsBuilder;
	return actionCodeSettingsBuilder;
}

var tenant = {};

var authConfig = {};

/*! firebase-admin v12.7.0 */

var hasRequiredAuthConfig;

function requireAuthConfig () {
	if (hasRequiredAuthConfig) return authConfig;
	hasRequiredAuthConfig = 1;
	(function (exports) {
		/*!
		 * Copyright 2018 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.EmailPrivacyAuthConfig = exports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;
		const validator = validator$2;
		const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
		const error_1 = error;
		/** A maximum of 10 test phone number / code pairs can be configured. */
		exports.MAXIMUM_TEST_PHONE_NUMBERS = 10;
		/** Client Auth factor type to server auth factor type mapping. */
		const AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {
		    phone: 'PHONE_SMS',
		};
		/** Server Auth factor type to client auth factor type mapping. */
		const AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)
		    .reduce((res, key) => {
		    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;
		    return res;
		}, {});
		/**
		 * Defines the multi-factor config class used to convert client side MultiFactorConfig
		 * to a format that is understood by the Auth server.
		 *
		 * @internal
		 */
		class MultiFactorAuthConfig {
		    /**
		     * Static method to convert a client side request to a MultiFactorAuthServerConfig.
		     * Throws an error if validation fails.
		     *
		     * @param options - The options object to convert to a server request.
		     * @returns The resulting server request.
		     * @internal
		     */
		    static buildServerRequest(options) {
		        const request = {};
		        MultiFactorAuthConfig.validate(options);
		        if (Object.prototype.hasOwnProperty.call(options, 'state')) {
		            request.state = options.state;
		        }
		        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {
		            (options.factorIds || []).forEach((factorId) => {
		                if (typeof request.enabledProviders === 'undefined') {
		                    request.enabledProviders = [];
		                }
		                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);
		            });
		            // In case an empty array is passed. Ensure it gets populated so the array is cleared.
		            if (options.factorIds && options.factorIds.length === 0) {
		                request.enabledProviders = [];
		            }
		        }
		        if (Object.prototype.hasOwnProperty.call(options, 'providerConfigs')) {
		            request.providerConfigs = options.providerConfigs;
		        }
		        return request;
		    }
		    /**
		     * Validates the MultiFactorConfig options object. Throws an error on failure.
		     *
		     * @param options - The options object to validate.
		     */
		    static validate(options) {
		        const validKeys = {
		            state: true,
		            factorIds: true,
		            providerConfigs: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig" must be a non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid MultiFactorConfig parameter.`);
		            }
		        }
		        // Validate content.
		        if (typeof options.state !== 'undefined' &&
		            options.state !== 'ENABLED' &&
		            options.state !== 'DISABLED') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.state" must be either "ENABLED" or "DISABLED".');
		        }
		        if (typeof options.factorIds !== 'undefined') {
		            if (!validator.isArray(options.factorIds)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.factorIds" must be an array of valid "AuthFactorTypes".');
		            }
		            // Validate content of array.
		            options.factorIds.forEach((factorId) => {
		                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${factorId}" is not a valid "AuthFactorType".`);
		                }
		            });
		        }
		        if (typeof options.providerConfigs !== 'undefined') {
		            if (!validator.isArray(options.providerConfigs)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs" must be an array of valid "MultiFactorProviderConfig."');
		            }
		            //Validate content of array.
		            options.providerConfigs.forEach((multiFactorProviderConfig) => {
		                if (typeof multiFactorProviderConfig === 'undefined' || !validator.isObject(multiFactorProviderConfig)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${multiFactorProviderConfig}" is not a valid "MultiFactorProviderConfig" type.`);
		                }
		                const validProviderConfigKeys = {
		                    state: true,
		                    totpProviderConfig: true,
		                };
		                for (const key in multiFactorProviderConfig) {
		                    if (!(key in validProviderConfigKeys)) {
		                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid ProviderConfig parameter.`);
		                    }
		                }
		                if (typeof multiFactorProviderConfig.state === 'undefined' ||
		                    (multiFactorProviderConfig.state !== 'ENABLED' &&
		                        multiFactorProviderConfig.state !== 'DISABLED')) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.state" must be either "ENABLED" or "DISABLED".');
		                }
		                // Since TOTP is the only provider config available right now, not defining it will lead into an error
		                if (typeof multiFactorProviderConfig.totpProviderConfig === 'undefined') {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.totpProviderConfig" must be defined.');
		                }
		                const validTotpProviderConfigKeys = {
		                    adjacentIntervals: true,
		                };
		                for (const key in multiFactorProviderConfig.totpProviderConfig) {
		                    if (!(key in validTotpProviderConfigKeys)) {
		                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid TotpProviderConfig parameter.`);
		                    }
		                }
		                const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;
		                if (typeof adjIntervals !== 'undefined' &&
		                    (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals" must' +
		                        ' be a valid number between 0 and 10 (both inclusive).');
		                }
		            });
		        }
		    }
		    /**
		     * The MultiFactorAuthConfig constructor.
		     *
		     * @param response - The server side response used to initialize the
		     *     MultiFactorAuthConfig object.
		     * @constructor
		     * @internal
		     */
		    constructor(response) {
		        if (typeof response.state === 'undefined') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');
		        }
		        this.state = response.state;
		        this.factorIds = [];
		        (response.enabledProviders || []).forEach((enabledProvider) => {
		            // Ignore unsupported types. It is possible the current admin SDK version is
		            // not up to date and newer backend types are supported.
		            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {
		                this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);
		            }
		        });
		        this.providerConfigs = [];
		        (response.providerConfigs || []).forEach((providerConfig) => {
		            if (typeof providerConfig !== 'undefined') {
		                if (typeof providerConfig.state === 'undefined' ||
		                    typeof providerConfig.totpProviderConfig === 'undefined' ||
		                    (typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'undefined' &&
		                        typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'number')) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');
		                }
		                this.providerConfigs.push(providerConfig);
		            }
		        });
		    }
		    /** Converts MultiFactorConfig to JSON object
		     * @returns The plain object representation of the multi-factor config instance. */
		    toJSON() {
		        return {
		            state: this.state,
		            factorIds: this.factorIds,
		            providerConfigs: this.providerConfigs,
		        };
		    }
		}
		exports.MultiFactorAuthConfig = MultiFactorAuthConfig;
		/**
		 * Validates the provided map of test phone number / code pairs.
		 * @param testPhoneNumbers - The phone number / code pairs to validate.
		 */
		function validateTestPhoneNumbers(testPhoneNumbers) {
		    if (!validator.isObject(testPhoneNumbers)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"testPhoneNumbers" must be a map of phone number / code pairs.');
		    }
		    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);
		    }
		    for (const phoneNumber in testPhoneNumbers) {
		        // Validate phone number.
		        if (!validator.isPhoneNumber(phoneNumber)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${phoneNumber}" is not a valid E.164 standard compliant phone number.`);
		        }
		        // Validate code.
		        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||
		            !/^[\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${testPhoneNumbers[phoneNumber]}" is not a valid 6 digit code string.`);
		        }
		    }
		}
		exports.validateTestPhoneNumbers = validateTestPhoneNumbers;
		/**
		 * Defines the email sign-in config class used to convert client side EmailSignInConfig
		 * to a format that is understood by the Auth server.
		 *
		 * @internal
		 */
		class EmailSignInConfig {
		    /**
		     * Static method to convert a client side request to a EmailSignInConfigServerRequest.
		     * Throws an error if validation fails.
		     *
		     * @param options - The options object to convert to a server request.
		     * @returns The resulting server request.
		     * @internal
		     */
		    static buildServerRequest(options) {
		        const request = {};
		        EmailSignInConfig.validate(options);
		        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {
		            request.allowPasswordSignup = options.enabled;
		        }
		        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {
		            request.enableEmailLinkSignin = !options.passwordRequired;
		        }
		        return request;
		    }
		    /**
		     * Validates the EmailSignInConfig options object. Throws an error on failure.
		     *
		     * @param options - The options object to validate.
		     */
		    static validate(options) {
		        // TODO: Validate the request.
		        const validKeys = {
		            enabled: true,
		            passwordRequired: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig" must be a non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid EmailSignInConfig parameter.`);
		            }
		        }
		        // Validate content.
		        if (typeof options.enabled !== 'undefined' &&
		            !validator.isBoolean(options.enabled)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.enabled" must be a boolean.');
		        }
		        if (typeof options.passwordRequired !== 'undefined' &&
		            !validator.isBoolean(options.passwordRequired)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.passwordRequired" must be a boolean.');
		        }
		    }
		    /**
		     * The EmailSignInConfig constructor.
		     *
		     * @param response - The server side response used to initialize the
		     *     EmailSignInConfig object.
		     * @constructor
		     */
		    constructor(response) {
		        if (typeof response.allowPasswordSignup === 'undefined') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');
		        }
		        this.enabled = response.allowPasswordSignup;
		        this.passwordRequired = !response.enableEmailLinkSignin;
		    }
		    /** @returns The plain object representation of the email sign-in config. */
		    toJSON() {
		        return {
		            enabled: this.enabled,
		            passwordRequired: this.passwordRequired,
		        };
		    }
		}
		exports.EmailSignInConfig = EmailSignInConfig;
		/**
		 * Defines the SAMLConfig class used to convert a client side configuration to its
		 * server side representation.
		 *
		 * @internal
		 */
		class SAMLConfig {
		    /**
		     * Converts a client side request to a SAMLConfigServerRequest which is the format
		     * accepted by the backend server.
		     * Throws an error if validation fails. If the request is not a SAMLConfig request,
		     * returns null.
		     *
		     * @param options - The options object to convert to a server request.
		     * @param ignoreMissingFields - Whether to ignore missing fields.
		     * @returns The resulting server request or null if not valid.
		     */
		    static buildServerRequest(options, ignoreMissingFields = false) {
		        const makeRequest = validator.isNonNullObject(options) &&
		            (options.providerId || ignoreMissingFields);
		        if (!makeRequest) {
		            return null;
		        }
		        const request = {};
		        // Validate options.
		        SAMLConfig.validate(options, ignoreMissingFields);
		        request.enabled = options.enabled;
		        request.displayName = options.displayName;
		        // IdP config.
		        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {
		            request.idpConfig = {
		                idpEntityId: options.idpEntityId,
		                ssoUrl: options.ssoURL,
		                signRequest: options.enableRequestSigning,
		                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],
		            };
		            if (options.x509Certificates) {
		                for (const cert of (options.x509Certificates || [])) {
		                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });
		                }
		            }
		        }
		        // RP config.
		        if (options.callbackURL || options.rpEntityId) {
		            request.spConfig = {
		                spEntityId: options.rpEntityId,
		                callbackUri: options.callbackURL,
		            };
		        }
		        return request;
		    }
		    /**
		     * Returns the provider ID corresponding to the resource name if available.
		     *
		     * @param resourceName - The server side resource name.
		     * @returns The provider ID corresponding to the resource, null otherwise.
		     */
		    static getProviderIdFromResourceName(resourceName) {
		        // name is of form projects/project1/inboundSamlConfigs/providerId1
		        const matchProviderRes = resourceName.match(/\/inboundSamlConfigs\/(saml\..*)$/);
		        if (!matchProviderRes || matchProviderRes.length < 2) {
		            return null;
		        }
		        return matchProviderRes[1];
		    }
		    /**
		     * @param providerId - The provider ID to check.
		     * @returns Whether the provider ID corresponds to a SAML provider.
		     */
		    static isProviderId(providerId) {
		        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;
		    }
		    /**
		     * Validates the SAMLConfig options object. Throws an error on failure.
		     *
		     * @param options - The options object to validate.
		     * @param ignoreMissingFields - Whether to ignore missing fields.
		     */
		    static validate(options, ignoreMissingFields = false) {
		        const validKeys = {
		            enabled: true,
		            displayName: true,
		            providerId: true,
		            idpEntityId: true,
		            ssoURL: true,
		            x509Certificates: true,
		            rpEntityId: true,
		            callbackURL: true,
		            enableRequestSigning: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig" must be a valid non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SAML config parameter.`);
		            }
		        }
		        // Required fields.
		        if (validator.isNonEmptyString(options.providerId)) {
		            if (options.providerId.indexOf('saml.') !== 0) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
		            }
		        }
		        else if (!ignoreMissingFields) {
		            // providerId is required and not provided correctly.
		            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
		        }
		        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&
		            !validator.isNonEmptyString(options.idpEntityId)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.idpEntityId" must be a valid non-empty string.');
		        }
		        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&
		            !validator.isURL(options.ssoURL)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.ssoURL" must be a valid URL string.');
		        }
		        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&
		            !validator.isNonEmptyString(options.rpEntityId)) {
		            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :
		                error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.rpEntityId" must be a valid non-empty string.');
		        }
		        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&
		            !validator.isURL(options.callbackURL)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.callbackURL" must be a valid URL string.');
		        }
		        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&
		            !validator.isArray(options.x509Certificates)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
		        }
		        (options.x509Certificates || []).forEach((cert) => {
		            if (!validator.isNonEmptyString(cert)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
		            }
		        });
		        if (typeof options.enableRequestSigning !== 'undefined' &&
		            !validator.isBoolean(options.enableRequestSigning)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enableRequestSigning" must be a boolean.');
		        }
		        if (typeof options.enabled !== 'undefined' &&
		            !validator.isBoolean(options.enabled)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enabled" must be a boolean.');
		        }
		        if (typeof options.displayName !== 'undefined' &&
		            !validator.isString(options.displayName)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.displayName" must be a valid string.');
		        }
		    }
		    /**
		     * The SAMLConfig constructor.
		     *
		     * @param response - The server side response used to initialize the SAMLConfig object.
		     * @constructor
		     */
		    constructor(response) {
		        if (!response ||
		            !response.idpConfig ||
		            !response.idpConfig.idpEntityId ||
		            !response.idpConfig.ssoUrl ||
		            !response.spConfig ||
		            !response.spConfig.spEntityId ||
		            !response.name ||
		            !(validator.isString(response.name) &&
		                SAMLConfig.getProviderIdFromResourceName(response.name))) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
		        }
		        const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);
		        if (!providerId) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
		        }
		        this.providerId = providerId;
		        // RP config.
		        this.rpEntityId = response.spConfig.spEntityId;
		        this.callbackURL = response.spConfig.callbackUri;
		        // IdP config.
		        this.idpEntityId = response.idpConfig.idpEntityId;
		        this.ssoURL = response.idpConfig.ssoUrl;
		        this.enableRequestSigning = !!response.idpConfig.signRequest;
		        const x509Certificates = [];
		        for (const cert of (response.idpConfig.idpCertificates || [])) {
		            if (cert.x509Certificate) {
		                x509Certificates.push(cert.x509Certificate);
		            }
		        }
		        this.x509Certificates = x509Certificates;
		        // When enabled is undefined, it takes its default value of false.
		        this.enabled = !!response.enabled;
		        this.displayName = response.displayName;
		    }
		    /** @returns The plain object representation of the SAMLConfig. */
		    toJSON() {
		        return {
		            enabled: this.enabled,
		            displayName: this.displayName,
		            providerId: this.providerId,
		            idpEntityId: this.idpEntityId,
		            ssoURL: this.ssoURL,
		            x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),
		            rpEntityId: this.rpEntityId,
		            callbackURL: this.callbackURL,
		            enableRequestSigning: this.enableRequestSigning,
		        };
		    }
		}
		exports.SAMLConfig = SAMLConfig;
		/**
		 * Defines the OIDCConfig class used to convert a client side configuration to its
		 * server side representation.
		 *
		 * @internal
		 */
		class OIDCConfig {
		    /**
		     * Converts a client side request to a OIDCConfigServerRequest which is the format
		     * accepted by the backend server.
		     * Throws an error if validation fails. If the request is not a OIDCConfig request,
		     * returns null.
		     *
		     * @param options - The options object to convert to a server request.
		     * @param ignoreMissingFields - Whether to ignore missing fields.
		     * @returns The resulting server request or null if not valid.
		     */
		    static buildServerRequest(options, ignoreMissingFields = false) {
		        const makeRequest = validator.isNonNullObject(options) &&
		            (options.providerId || ignoreMissingFields);
		        if (!makeRequest) {
		            return null;
		        }
		        const request = {};
		        // Validate options.
		        OIDCConfig.validate(options, ignoreMissingFields);
		        request.enabled = options.enabled;
		        request.displayName = options.displayName;
		        request.issuer = options.issuer;
		        request.clientId = options.clientId;
		        if (typeof options.clientSecret !== 'undefined') {
		            request.clientSecret = options.clientSecret;
		        }
		        if (typeof options.responseType !== 'undefined') {
		            request.responseType = options.responseType;
		        }
		        return request;
		    }
		    /**
		     * Returns the provider ID corresponding to the resource name if available.
		     *
		     * @param resourceName - The server side resource name
		     * @returns The provider ID corresponding to the resource, null otherwise.
		     */
		    static getProviderIdFromResourceName(resourceName) {
		        // name is of form projects/project1/oauthIdpConfigs/providerId1
		        const matchProviderRes = resourceName.match(/\/oauthIdpConfigs\/(oidc\..*)$/);
		        if (!matchProviderRes || matchProviderRes.length < 2) {
		            return null;
		        }
		        return matchProviderRes[1];
		    }
		    /**
		     * @param providerId - The provider ID to check.
		     * @returns Whether the provider ID corresponds to an OIDC provider.
		     */
		    static isProviderId(providerId) {
		        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;
		    }
		    /**
		     * Validates the OIDCConfig options object. Throws an error on failure.
		     *
		     * @param options - The options object to validate.
		     * @param ignoreMissingFields - Whether to ignore missing fields.
		     */
		    static validate(options, ignoreMissingFields = false) {
		        const validKeys = {
		            enabled: true,
		            displayName: true,
		            providerId: true,
		            clientId: true,
		            issuer: true,
		            clientSecret: true,
		            responseType: true,
		        };
		        const validResponseTypes = {
		            idToken: true,
		            code: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig" must be a valid non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OIDC config parameter.`);
		            }
		        }
		        // Required fields.
		        if (validator.isNonEmptyString(options.providerId)) {
		            if (options.providerId.indexOf('oidc.') !== 0) {
		                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
		            }
		        }
		        else if (!ignoreMissingFields) {
		            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
		        }
		        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&
		            !validator.isNonEmptyString(options.clientId)) {
		            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '"OIDCAuthProviderConfig.clientId" must be a valid non-empty string.');
		        }
		        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&
		            !validator.isURL(options.issuer)) {
		            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.issuer" must be a valid URL string.');
		        }
		        if (typeof options.enabled !== 'undefined' &&
		            !validator.isBoolean(options.enabled)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.enabled" must be a boolean.');
		        }
		        if (typeof options.displayName !== 'undefined' &&
		            !validator.isString(options.displayName)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.displayName" must be a valid string.');
		        }
		        if (typeof options.clientSecret !== 'undefined' &&
		            !validator.isNonEmptyString(options.clientSecret)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.clientSecret" must be a valid string.');
		        }
		        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {
		            Object.keys(options.responseType).forEach((key) => {
		                if (!(key in validResponseTypes)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OAuthResponseType parameter.`);
		                }
		            });
		            const idToken = options.responseType.idToken;
		            if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.idToken" must be a boolean.');
		            }
		            const code = options.responseType.code;
		            if (typeof code !== 'undefined') {
		                if (!validator.isBoolean(code)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.code" must be a boolean.');
		                }
		                // If code flow is enabled, client secret must be provided.
		                if (code && typeof options.clientSecret === 'undefined') {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');
		                }
		            }
		            const allKeys = Object.keys(options.responseType).length;
		            const enabledCount = Object.values(options.responseType).filter(Boolean).length;
		            // Only one of OAuth response types can be set to true.
		            if (allKeys > 1 && enabledCount !== 1) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');
		            }
		        }
		    }
		    /**
		     * The OIDCConfig constructor.
		     *
		     * @param response - The server side response used to initialize the OIDCConfig object.
		     * @constructor
		     */
		    constructor(response) {
		        if (!response ||
		            !response.issuer ||
		            !response.clientId ||
		            !response.name ||
		            !(validator.isString(response.name) &&
		                OIDCConfig.getProviderIdFromResourceName(response.name))) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');
		        }
		        const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);
		        if (!providerId) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
		        }
		        this.providerId = providerId;
		        this.clientId = response.clientId;
		        this.issuer = response.issuer;
		        // When enabled is undefined, it takes its default value of false.
		        this.enabled = !!response.enabled;
		        this.displayName = response.displayName;
		        if (typeof response.clientSecret !== 'undefined') {
		            this.clientSecret = response.clientSecret;
		        }
		        if (typeof response.responseType !== 'undefined') {
		            this.responseType = response.responseType;
		        }
		    }
		    /** @returns The plain object representation of the OIDCConfig. */
		    toJSON() {
		        return {
		            enabled: this.enabled,
		            displayName: this.displayName,
		            providerId: this.providerId,
		            issuer: this.issuer,
		            clientId: this.clientId,
		            clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),
		            responseType: (0, deep_copy_1.deepCopy)(this.responseType),
		        };
		    }
		}
		exports.OIDCConfig = OIDCConfig;
		/**
		 * Defines the SMSRegionConfig class used for validation.
		 *
		 * @internal
		 */
		class SmsRegionsAuthConfig {
		    static validate(options) {
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig" must be a non-null object.');
		        }
		        const validKeys = {
		            allowlistOnly: true,
		            allowByDefault: true,
		        };
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig parameter.`);
		            }
		        }
		        // validate mutual exclusiveness of allowByDefault and allowlistOnly
		        if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both "allowByDefault" and "allowlistOnly" parameters.');
		        }
		        // validation for allowByDefault type
		        if (typeof options.allowByDefault !== 'undefined') {
		            const allowByDefaultValidKeys = {
		                disallowedRegions: true,
		            };
		            for (const key in options.allowByDefault) {
		                if (!(key in allowByDefaultValidKeys)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowByDefault parameter.`);
		                }
		            }
		            // disallowedRegion can be empty.
		            if (typeof options.allowByDefault.disallowedRegions !== 'undefined'
		                && !validator.isArray(options.allowByDefault.disallowedRegions)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowByDefault.disallowedRegions" must be a valid string array.');
		            }
		        }
		        if (typeof options.allowlistOnly !== 'undefined') {
		            const allowListOnlyValidKeys = {
		                allowedRegions: true,
		            };
		            for (const key in options.allowlistOnly) {
		                if (!(key in allowListOnlyValidKeys)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowlistOnly parameter.`);
		                }
		            }
		            // allowedRegions can be empty
		            if (typeof options.allowlistOnly.allowedRegions !== 'undefined'
		                && !validator.isArray(options.allowlistOnly.allowedRegions)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowlistOnly.allowedRegions" must be a valid string array.');
		            }
		        }
		    }
		}
		exports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;
		/**
		 * Defines the recaptcha config class used to convert client side RecaptchaConfig
		 * to a format that is understood by the Auth server.
		 *
		 * @internal
		 */
		class RecaptchaAuthConfig {
		    /**
		     * The RecaptchaAuthConfig constructor.
		     *
		     * @param response - The server side response used to initialize the
		     *     RecaptchaAuthConfig object.
		     * @constructor
		     * @internal
		     */
		    constructor(response) {
		        const filteredResponse = Object.fromEntries(Object.entries(response).filter(([, value]) => value !== undefined));
		        // Explicitly map the 'tollFraudManagedRules' to 'smsTollFraudManagedRules'
		        if (filteredResponse.tollFraudManagedRules !== undefined) {
		            this.smsTollFraudManagedRules = filteredResponse.tollFraudManagedRules;
		            delete filteredResponse.tollFraudManagedRules; // Remove it if necessary
		        }
		        // Assign the remaining properties directly
		        Object.assign(this, filteredResponse);
		    }
		    /**
		     * Builds a server request object from the client-side RecaptchaConfig.
		     * Converts client-side fields to their server-side equivalents.
		     *
		     * @param options - The client-side RecaptchaConfig object.
		     * @returns The server-side RecaptchaAuthServerConfig object.
		     */
		    static buildServerRequest(options) {
		        RecaptchaAuthConfig.validate(options); // Validate options before building request
		        const request = {};
		        if (typeof options.emailPasswordEnforcementState !== 'undefined') {
		            request.emailPasswordEnforcementState = options.emailPasswordEnforcementState;
		        }
		        if (typeof options.phoneEnforcementState !== 'undefined') {
		            request.phoneEnforcementState = options.phoneEnforcementState;
		        }
		        if (typeof options.managedRules !== 'undefined') {
		            request.managedRules = options.managedRules;
		        }
		        if (typeof options.recaptchaKeys !== 'undefined') {
		            request.recaptchaKeys = options.recaptchaKeys;
		        }
		        if (typeof options.useAccountDefender !== 'undefined') {
		            request.useAccountDefender = options.useAccountDefender;
		        }
		        if (typeof options.useSmsBotScore !== 'undefined') {
		            request.useSmsBotScore = options.useSmsBotScore;
		        }
		        if (typeof options.useSmsTollFraudProtection !== 'undefined') {
		            request.useSmsTollFraudProtection = options.useSmsTollFraudProtection;
		        }
		        if (typeof options.smsTollFraudManagedRules !== 'undefined') {
		            request.tollFraudManagedRules = options.smsTollFraudManagedRules; // Map client-side field to server-side
		        }
		        return request;
		    }
		    /**
		     * Validates the RecaptchaConfig options object. Throws an error on failure.
		     * @param options - The options object to validate.
		     */
		    static validate(options) {
		        const validKeys = {
		            emailPasswordEnforcementState: true,
		            phoneEnforcementState: true,
		            managedRules: true,
		            recaptchaKeys: true,
		            useAccountDefender: true,
		            useSmsBotScore: true,
		            useSmsTollFraudProtection: true,
		            smsTollFraudManagedRules: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig" must be a non-null object.');
		        }
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaConfig parameter.`);
		            }
		        }
		        // Validation
		        if (typeof options.emailPasswordEnforcementState !== 'undefined') {
		            if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.emailPasswordEnforcementState" must be a valid non-empty string.');
		            }
		            if (options.emailPasswordEnforcementState !== 'OFF' &&
		                options.emailPasswordEnforcementState !== 'AUDIT' &&
		                options.emailPasswordEnforcementState !== 'ENFORCE') {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.emailPasswordEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
		            }
		        }
		        if (typeof options.phoneEnforcementState !== 'undefined') {
		            if (!validator.isNonEmptyString(options.phoneEnforcementState)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.phoneEnforcementState" must be a valid non-empty string.');
		            }
		            if (options.phoneEnforcementState !== 'OFF' &&
		                options.phoneEnforcementState !== 'AUDIT' &&
		                options.phoneEnforcementState !== 'ENFORCE') {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.phoneEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
		            }
		        }
		        if (typeof options.managedRules !== 'undefined') {
		            // Validate array
		            if (!validator.isArray(options.managedRules)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.managedRules" must be an array of valid "RecaptchaManagedRule".');
		            }
		            // Validate each rule of the array
		            options.managedRules.forEach((managedRule) => {
		                RecaptchaAuthConfig.validateManagedRule(managedRule);
		            });
		        }
		        if (typeof options.useAccountDefender !== 'undefined') {
		            if (!validator.isBoolean(options.useAccountDefender)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useAccountDefender" must be a boolean value".');
		            }
		        }
		        if (typeof options.useSmsBotScore !== 'undefined') {
		            if (!validator.isBoolean(options.useSmsBotScore)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsBotScore" must be a boolean value".');
		            }
		        }
		        if (typeof options.useSmsTollFraudProtection !== 'undefined') {
		            if (!validator.isBoolean(options.useSmsTollFraudProtection)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsTollFraudProtection" must be a boolean value".');
		            }
		        }
		        if (typeof options.smsTollFraudManagedRules !== 'undefined') {
		            // Validate array
		            if (!validator.isArray(options.smsTollFraudManagedRules)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.smsTollFraudManagedRules" must be an array of valid "RecaptchaTollFraudManagedRule".');
		            }
		            // Validate each rule of the array
		            options.smsTollFraudManagedRules.forEach((tollFraudManagedRule) => {
		                RecaptchaAuthConfig.validateTollFraudManagedRule(tollFraudManagedRule);
		            });
		        }
		    }
		    /**
		     * Validate each element in ManagedRule array
		     * @param options - The options object to validate.
		     */
		    static validateManagedRule(options) {
		        const validKeys = {
		            endScore: true,
		            action: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule" must be a non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaManagedRule parameter.`);
		            }
		        }
		        // Validate content.
		        if (typeof options.action !== 'undefined' &&
		            options.action !== 'BLOCK') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule.action" must be "BLOCK".');
		        }
		    }
		    /**
		     * Validate each element in TollFraudManagedRule array
		     * @param options - The options object to validate.
		     */
		    static validateTollFraudManagedRule(options) {
		        const validKeys = {
		            startScore: true,
		            action: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule" must be a non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaTollFraudManagedRule parameter.`);
		            }
		        }
		        // Validate content.
		        if (typeof options.action !== 'undefined' &&
		            options.action !== 'BLOCK') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule.action" must be "BLOCK".');
		        }
		    }
		}
		exports.RecaptchaAuthConfig = RecaptchaAuthConfig;
		/**
		 * Defines the password policy config class used to convert client side PasswordPolicyConfig
		 * to a format that is understood by the Auth server.
		 *
		 * @internal
		 */
		class PasswordPolicyAuthConfig {
		    /**
		     * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.
		     * Throws an error if validation fails.
		     *
		     * @param options - The options object to convert to a server request.
		     * @returns The resulting server request.
		     * @internal
		     */
		    static buildServerRequest(options) {
		        const request = {};
		        PasswordPolicyAuthConfig.validate(options);
		        if (Object.prototype.hasOwnProperty.call(options, 'enforcementState')) {
		            request.passwordPolicyEnforcementState = options.enforcementState;
		        }
		        request.forceUpgradeOnSignin = false;
		        if (Object.prototype.hasOwnProperty.call(options, 'forceUpgradeOnSignin')) {
		            request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;
		        }
		        const constraintsRequest = {
		            containsUppercaseCharacter: false,
		            containsLowercaseCharacter: false,
		            containsNonAlphanumericCharacter: false,
		            containsNumericCharacter: false,
		            minPasswordLength: 6,
		            maxPasswordLength: 4096,
		        };
		        request.passwordPolicyVersions = [];
		        if (Object.prototype.hasOwnProperty.call(options, 'constraints')) {
		            if (options) {
		                if (options.constraints?.requireUppercase !== undefined) {
		                    constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;
		                }
		                if (options.constraints?.requireLowercase !== undefined) {
		                    constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;
		                }
		                if (options.constraints?.requireNonAlphanumeric !== undefined) {
		                    constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;
		                }
		                if (options.constraints?.requireNumeric !== undefined) {
		                    constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;
		                }
		                if (options.constraints?.minLength !== undefined) {
		                    constraintsRequest.minPasswordLength = options.constraints.minLength;
		                }
		                if (options.constraints?.maxLength !== undefined) {
		                    constraintsRequest.maxPasswordLength = options.constraints.maxLength;
		                }
		            }
		        }
		        request.passwordPolicyVersions.push({ customStrengthOptions: constraintsRequest });
		        return request;
		    }
		    /**
		     * Validates the PasswordPolicyConfig options object. Throws an error on failure.
		     *
		     * @param options - The options object to validate.
		     * @internal
		     */
		    static validate(options) {
		        const validKeys = {
		            enforcementState: true,
		            forceUpgradeOnSignin: true,
		            constraints: true,
		        };
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig" must be a non-null object.');
		        }
		        // Check for unsupported top level attributes.
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig parameter.`);
		            }
		        }
		        // Validate content.
		        if (typeof options.enforcementState === 'undefined' ||
		            !(options.enforcementState === 'ENFORCE' ||
		                options.enforcementState === 'OFF')) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.enforcementState" must be either "ENFORCE" or "OFF".');
		        }
		        if (typeof options.forceUpgradeOnSignin !== 'undefined') {
		            if (!validator.isBoolean(options.forceUpgradeOnSignin)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.forceUpgradeOnSignin" must be a boolean.');
		            }
		        }
		        if (typeof options.constraints !== 'undefined') {
		            if (options.enforcementState === 'ENFORCE' && !validator.isNonNullObject(options.constraints)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be a non-empty object.');
		            }
		            const validCharKeys = {
		                requireUppercase: true,
		                requireLowercase: true,
		                requireNumeric: true,
		                requireNonAlphanumeric: true,
		                minLength: true,
		                maxLength: true,
		            };
		            // Check for unsupported  attributes.
		            for (const key in options.constraints) {
		                if (!(key in validCharKeys)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig.constraints parameter.`);
		                }
		            }
		            if (typeof options.constraints.requireUppercase !== 'undefined' &&
		                !validator.isBoolean(options.constraints.requireUppercase)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireUppercase" must be a boolean.');
		            }
		            if (typeof options.constraints.requireLowercase !== 'undefined' &&
		                !validator.isBoolean(options.constraints.requireLowercase)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireLowercase" must be a boolean.');
		            }
		            if (typeof options.constraints.requireNonAlphanumeric !== 'undefined' &&
		                !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNonAlphanumeric"' +
		                    ' must be a boolean.');
		            }
		            if (typeof options.constraints.requireNumeric !== 'undefined' &&
		                !validator.isBoolean(options.constraints.requireNumeric)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNumeric" must be a boolean.');
		            }
		            if (typeof options.constraints.minLength === 'undefined') {
		                options.constraints.minLength = 6;
		            }
		            else if (!validator.isNumber(options.constraints.minLength)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be a number.');
		            }
		            else {
		                if (!(options.constraints.minLength >= 6
		                    && options.constraints.minLength <= 30)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength"' +
		                        ' must be an integer between 6 and 30, inclusive.');
		                }
		            }
		            if (typeof options.constraints.maxLength === 'undefined') {
		                options.constraints.maxLength = 4096;
		            }
		            else if (!validator.isNumber(options.constraints.maxLength)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be a number.');
		            }
		            else {
		                if (!(options.constraints.maxLength >= options.constraints.minLength &&
		                    options.constraints.maxLength <= 4096)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength"' +
		                        ' must be greater than or equal to minLength and at max 4096.');
		                }
		            }
		        }
		        else {
		            if (options.enforcementState === 'ENFORCE') {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be defined.');
		            }
		        }
		    }
		    /**
		     * The PasswordPolicyAuthConfig constructor.
		     *
		     * @param response - The server side response used to initialize the
		     *     PasswordPolicyAuthConfig object.
		     * @constructor
		     * @internal
		     */
		    constructor(response) {
		        if (typeof response.passwordPolicyEnforcementState === 'undefined') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid password policy configuration response');
		        }
		        this.enforcementState = response.passwordPolicyEnforcementState;
		        let constraintsResponse = {};
		        if (typeof response.passwordPolicyVersions !== 'undefined') {
		            (response.passwordPolicyVersions || []).forEach((policyVersion) => {
		                constraintsResponse = {
		                    requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,
		                    requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,
		                    requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,
		                    requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,
		                    minLength: policyVersion.customStrengthOptions?.minPasswordLength,
		                    maxLength: policyVersion.customStrengthOptions?.maxPasswordLength,
		                };
		            });
		        }
		        this.constraints = constraintsResponse;
		        this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;
		    }
		}
		exports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;
		/**
		 * Defines the EmailPrivacyAuthConfig class used for validation.
		 *
		 * @internal
		 */
		class EmailPrivacyAuthConfig {
		    static validate(options) {
		        if (!validator.isNonNullObject(options)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig" must be a non-null object.');
		        }
		        const validKeys = {
		            enableImprovedEmailPrivacy: true,
		        };
		        for (const key in options) {
		            if (!(key in validKeys)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid "EmailPrivacyConfig" parameter.`);
		            }
		        }
		        if (typeof options.enableImprovedEmailPrivacy !== 'undefined'
		            && !validator.isBoolean(options.enableImprovedEmailPrivacy)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig.enableImprovedEmailPrivacy" must be a valid boolean value.');
		        }
		    }
		}
		exports.EmailPrivacyAuthConfig = EmailPrivacyAuthConfig; 
	} (authConfig));
	return authConfig;
}

/*! firebase-admin v12.7.0 */

var hasRequiredTenant;

function requireTenant () {
	if (hasRequiredTenant) return tenant;
	hasRequiredTenant = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tenant, "__esModule", { value: true });
	tenant.Tenant = void 0;
	const validator = validator$2;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const error_1 = error;
	const auth_config_1 = /*@__PURE__*/ requireAuthConfig();
	/**
	 * Represents a tenant configuration.
	 *
	 * Multi-tenancy support requires Google Cloud's Identity Platform
	 * (GCIP). To learn more about GCIP, including pricing and features,
	 * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	 *
	 * Before multi-tenancy can be used on a Google Cloud Identity Platform project,
	 * tenants must be allowed on that project via the Cloud Console UI.
	 *
	 * A tenant configuration provides information such as the display name, tenant
	 * identifier and email authentication configuration.
	 * For OIDC/SAML provider configuration management, `TenantAwareAuth` instances should
	 * be used instead of a `Tenant` to retrieve the list of configured IdPs on a tenant.
	 * When configuring these providers, note that tenants will inherit
	 * whitelisted domains and authenticated redirect URIs of their parent project.
	 *
	 * All other settings of a tenant will also be inherited. These will need to be managed
	 * from the Cloud Console UI.
	 */
	class Tenant {
	    /**
	     * Builds the corresponding server request for a TenantOptions object.
	     *
	     * @param tenantOptions - The properties to convert to a server request.
	     * @param createRequest - Whether this is a create request.
	     * @returns The equivalent server request.
	     *
	     * @internal
	     */
	    static buildServerRequest(tenantOptions, createRequest) {
	        Tenant.validate(tenantOptions, createRequest);
	        let request = {};
	        if (typeof tenantOptions.emailSignInConfig !== 'undefined') {
	            request = auth_config_1.EmailSignInConfig.buildServerRequest(tenantOptions.emailSignInConfig);
	        }
	        if (typeof tenantOptions.displayName !== 'undefined') {
	            request.displayName = tenantOptions.displayName;
	        }
	        if (typeof tenantOptions.anonymousSignInEnabled !== 'undefined') {
	            request.enableAnonymousUser = tenantOptions.anonymousSignInEnabled;
	        }
	        if (typeof tenantOptions.multiFactorConfig !== 'undefined') {
	            request.mfaConfig = auth_config_1.MultiFactorAuthConfig.buildServerRequest(tenantOptions.multiFactorConfig);
	        }
	        if (typeof tenantOptions.testPhoneNumbers !== 'undefined') {
	            // null will clear existing test phone numbers. Translate to empty object.
	            request.testPhoneNumbers = tenantOptions.testPhoneNumbers ?? {};
	        }
	        if (typeof tenantOptions.smsRegionConfig !== 'undefined') {
	            request.smsRegionConfig = tenantOptions.smsRegionConfig;
	        }
	        if (typeof tenantOptions.recaptchaConfig !== 'undefined') {
	            request.recaptchaConfig = auth_config_1.RecaptchaAuthConfig.buildServerRequest(tenantOptions.recaptchaConfig);
	        }
	        if (typeof tenantOptions.passwordPolicyConfig !== 'undefined') {
	            request.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(tenantOptions.passwordPolicyConfig);
	        }
	        if (typeof tenantOptions.emailPrivacyConfig !== 'undefined') {
	            request.emailPrivacyConfig = tenantOptions.emailPrivacyConfig;
	        }
	        return request;
	    }
	    /**
	     * Returns the tenant ID corresponding to the resource name if available.
	     *
	     * @param resourceName - The server side resource name
	     * @returns The tenant ID corresponding to the resource, null otherwise.
	     *
	     * @internal
	     */
	    static getTenantIdFromResourceName(resourceName) {
	        // name is of form projects/project1/tenants/tenant1
	        const matchTenantRes = resourceName.match(/\/tenants\/(.*)$/);
	        if (!matchTenantRes || matchTenantRes.length < 2) {
	            return null;
	        }
	        return matchTenantRes[1];
	    }
	    /**
	     * Validates a tenant options object. Throws an error on failure.
	     *
	     * @param request - The tenant options object to validate.
	     * @param createRequest - Whether this is a create request.
	     */
	    static validate(request, createRequest) {
	        const validKeys = {
	            displayName: true,
	            emailSignInConfig: true,
	            anonymousSignInEnabled: true,
	            multiFactorConfig: true,
	            testPhoneNumbers: true,
	            smsRegionConfig: true,
	            recaptchaConfig: true,
	            passwordPolicyConfig: true,
	            emailPrivacyConfig: true,
	        };
	        const label = createRequest ? 'CreateTenantRequest' : 'UpdateTenantRequest';
	        if (!validator.isNonNullObject(request)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}" must be a valid non-null object.`);
	        }
	        // Check for unsupported top level attributes.
	        for (const key in request) {
	            if (!(key in validKeys)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid ${label} parameter.`);
	            }
	        }
	        // Validate displayName type if provided.
	        if (typeof request.displayName !== 'undefined' &&
	            !validator.isNonEmptyString(request.displayName)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.displayName" must be a valid non-empty string.`);
	        }
	        // Validate emailSignInConfig type if provided.
	        if (typeof request.emailSignInConfig !== 'undefined') {
	            // This will throw an error if invalid.
	            auth_config_1.EmailSignInConfig.buildServerRequest(request.emailSignInConfig);
	        }
	        // Validate test phone numbers if provided.
	        if (typeof request.testPhoneNumbers !== 'undefined' &&
	            request.testPhoneNumbers !== null) {
	            (0, auth_config_1.validateTestPhoneNumbers)(request.testPhoneNumbers);
	        }
	        else if (request.testPhoneNumbers === null && createRequest) {
	            // null allowed only for update operations.
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.testPhoneNumbers" must be a non-null object.`);
	        }
	        // Validate multiFactorConfig type if provided.
	        if (typeof request.multiFactorConfig !== 'undefined') {
	            // This will throw an error if invalid.
	            auth_config_1.MultiFactorAuthConfig.buildServerRequest(request.multiFactorConfig);
	        }
	        // Validate SMS Regions Config if provided.
	        if (typeof request.smsRegionConfig !== 'undefined') {
	            auth_config_1.SmsRegionsAuthConfig.validate(request.smsRegionConfig);
	        }
	        // Validate reCAPTCHAConfig type if provided.
	        if (typeof request.recaptchaConfig !== 'undefined') {
	            auth_config_1.RecaptchaAuthConfig.buildServerRequest(request.recaptchaConfig);
	        }
	        // Validate passwordPolicyConfig type if provided.
	        if (typeof request.passwordPolicyConfig !== 'undefined') {
	            // This will throw an error if invalid.
	            auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(request.passwordPolicyConfig);
	        }
	        // Validate Email Privacy Config if provided.
	        if (typeof request.emailPrivacyConfig !== 'undefined') {
	            auth_config_1.EmailPrivacyAuthConfig.validate(request.emailPrivacyConfig);
	        }
	    }
	    /**
	     * The Tenant object constructor.
	     *
	     * @param response - The server side response used to initialize the Tenant object.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        const tenantId = Tenant.getTenantIdFromResourceName(response.name);
	        if (!tenantId) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid tenant response');
	        }
	        this.tenantId = tenantId;
	        this.displayName = response.displayName;
	        try {
	            this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig(response);
	        }
	        catch (e) {
	            // If allowPasswordSignup is undefined, it is disabled by default.
	            this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig({
	                allowPasswordSignup: false,
	            });
	        }
	        this.anonymousSignInEnabled = !!response.enableAnonymousUser;
	        if (typeof response.mfaConfig !== 'undefined') {
	            this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfaConfig);
	        }
	        if (typeof response.testPhoneNumbers !== 'undefined') {
	            this.testPhoneNumbers = (0, deep_copy_1.deepCopy)(response.testPhoneNumbers || {});
	        }
	        if (typeof response.smsRegionConfig !== 'undefined') {
	            this.smsRegionConfig = (0, deep_copy_1.deepCopy)(response.smsRegionConfig);
	        }
	        if (typeof response.recaptchaConfig !== 'undefined') {
	            this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
	        }
	        if (typeof response.passwordPolicyConfig !== 'undefined') {
	            this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
	        }
	        if (typeof response.emailPrivacyConfig !== 'undefined') {
	            this.emailPrivacyConfig = (0, deep_copy_1.deepCopy)(response.emailPrivacyConfig);
	        }
	    }
	    /**
	     * The email sign in provider configuration.
	     */
	    get emailSignInConfig() {
	        return this.emailSignInConfig_;
	    }
	    /**
	     * The multi-factor auth configuration on the current tenant.
	     */
	    get multiFactorConfig() {
	        return this.multiFactorConfig_;
	    }
	    /**
	     * The recaptcha config auth configuration of the current tenant.
	     */
	    get recaptchaConfig() {
	        return this.recaptchaConfig_;
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        const json = {
	            tenantId: this.tenantId,
	            displayName: this.displayName,
	            emailSignInConfig: this.emailSignInConfig_?.toJSON(),
	            multiFactorConfig: this.multiFactorConfig_?.toJSON(),
	            anonymousSignInEnabled: this.anonymousSignInEnabled,
	            testPhoneNumbers: this.testPhoneNumbers,
	            smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
	            recaptchaConfig: (0, deep_copy_1.deepCopy)(this.recaptchaConfig),
	            passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
	            emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig),
	        };
	        if (typeof json.multiFactorConfig === 'undefined') {
	            delete json.multiFactorConfig;
	        }
	        if (typeof json.testPhoneNumbers === 'undefined') {
	            delete json.testPhoneNumbers;
	        }
	        if (typeof json.smsRegionConfig === 'undefined') {
	            delete json.smsRegionConfig;
	        }
	        if (typeof json.recaptchaConfig === 'undefined') {
	            delete json.recaptchaConfig;
	        }
	        if (typeof json.passwordPolicyConfig === 'undefined') {
	            delete json.passwordPolicyConfig;
	        }
	        if (typeof json.emailPrivacyConfig === 'undefined') {
	            delete json.emailPrivacyConfig;
	        }
	        return json;
	    }
	}
	tenant.Tenant = Tenant;
	return tenant;
}

var identifier = {};

/*! firebase-admin v12.7.0 */

var hasRequiredIdentifier;

function requireIdentifier () {
	if (hasRequiredIdentifier) return identifier;
	hasRequiredIdentifier = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(identifier, "__esModule", { value: true });
	identifier.isProviderIdentifier = identifier.isPhoneIdentifier = identifier.isEmailIdentifier = identifier.isUidIdentifier = void 0;
	/*
	 * User defined type guards. See
	 * https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards
	 */
	function isUidIdentifier(id) {
	    return id.uid !== undefined;
	}
	identifier.isUidIdentifier = isUidIdentifier;
	function isEmailIdentifier(id) {
	    return id.email !== undefined;
	}
	identifier.isEmailIdentifier = isEmailIdentifier;
	function isPhoneIdentifier(id) {
	    return id.phoneNumber !== undefined;
	}
	identifier.isPhoneIdentifier = isPhoneIdentifier;
	function isProviderIdentifier(id) {
	    const pid = id;
	    return pid.providerId !== undefined && pid.providerUid !== undefined;
	}
	identifier.isProviderIdentifier = isProviderIdentifier;
	return identifier;
}

var projectConfig = {};

/*! firebase-admin v12.7.0 */

var hasRequiredProjectConfig;

function requireProjectConfig () {
	if (hasRequiredProjectConfig) return projectConfig;
	hasRequiredProjectConfig = 1;
	Object.defineProperty(projectConfig, "__esModule", { value: true });
	projectConfig.ProjectConfig = void 0;
	/*!
	 * Copyright 2022 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	const validator = validator$2;
	const error_1 = error;
	const auth_config_1 = /*@__PURE__*/ requireAuthConfig();
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	/**
	* Represents a project configuration.
	*/
	class ProjectConfig {
	    /**
	     * The multi-factor auth configuration.
	     */
	    get multiFactorConfig() {
	        return this.multiFactorConfig_;
	    }
	    /**
	     * The reCAPTCHA configuration.
	     */
	    get recaptchaConfig() {
	        return this.recaptchaConfig_;
	    }
	    /**
	     * Validates a project config options object. Throws an error on failure.
	     *
	     * @param request - The project config options object to validate.
	     */
	    static validate(request) {
	        if (!validator.isNonNullObject(request)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UpdateProjectConfigRequest" must be a valid non-null object.');
	        }
	        const validKeys = {
	            smsRegionConfig: true,
	            multiFactorConfig: true,
	            recaptchaConfig: true,
	            passwordPolicyConfig: true,
	            emailPrivacyConfig: true,
	        };
	        // Check for unsupported top level attributes.
	        for (const key in request) {
	            if (!(key in validKeys)) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid UpdateProjectConfigRequest parameter.`);
	            }
	        }
	        // Validate SMS Regions Config if provided.
	        if (typeof request.smsRegionConfig !== 'undefined') {
	            auth_config_1.SmsRegionsAuthConfig.validate(request.smsRegionConfig);
	        }
	        // Validate Multi Factor Config if provided
	        if (typeof request.multiFactorConfig !== 'undefined') {
	            auth_config_1.MultiFactorAuthConfig.validate(request.multiFactorConfig);
	        }
	        // Validate reCAPTCHA config attribute.
	        if (typeof request.recaptchaConfig !== 'undefined') {
	            auth_config_1.RecaptchaAuthConfig.validate(request.recaptchaConfig);
	        }
	        // Validate Password policy Config if provided
	        if (typeof request.passwordPolicyConfig !== 'undefined') {
	            auth_config_1.PasswordPolicyAuthConfig.validate(request.passwordPolicyConfig);
	        }
	        // Validate Email Privacy Config if provided.
	        if (typeof request.emailPrivacyConfig !== 'undefined') {
	            auth_config_1.EmailPrivacyAuthConfig.validate(request.emailPrivacyConfig);
	        }
	    }
	    /**
	     * Build the corresponding server request for a UpdateProjectConfigRequest object.
	     * @param configOptions - The properties to convert to a server request.
	     * @returns  The equivalent server request.
	     *
	     * @internal
	     */
	    static buildServerRequest(configOptions) {
	        ProjectConfig.validate(configOptions);
	        const request = {};
	        if (typeof configOptions.smsRegionConfig !== 'undefined') {
	            request.smsRegionConfig = configOptions.smsRegionConfig;
	        }
	        if (typeof configOptions.multiFactorConfig !== 'undefined') {
	            request.mfa = auth_config_1.MultiFactorAuthConfig.buildServerRequest(configOptions.multiFactorConfig);
	        }
	        if (typeof configOptions.recaptchaConfig !== 'undefined') {
	            request.recaptchaConfig = auth_config_1.RecaptchaAuthConfig.buildServerRequest(configOptions.recaptchaConfig);
	        }
	        if (typeof configOptions.passwordPolicyConfig !== 'undefined') {
	            request.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(configOptions.passwordPolicyConfig);
	        }
	        if (typeof configOptions.emailPrivacyConfig !== 'undefined') {
	            request.emailPrivacyConfig = configOptions.emailPrivacyConfig;
	        }
	        return request;
	    }
	    /**
	     * The Project Config object constructor.
	     *
	     * @param response - The server side response used to initialize the Project Config object.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        if (typeof response.smsRegionConfig !== 'undefined') {
	            this.smsRegionConfig = response.smsRegionConfig;
	        }
	        //Backend API returns "mfa" in case of project config and "mfaConfig" in case of tenant config. 
	        //The SDK exposes it as multiFactorConfig always.
	        if (typeof response.mfa !== 'undefined') {
	            this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfa);
	        }
	        if (typeof response.recaptchaConfig !== 'undefined') {
	            this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
	        }
	        if (typeof response.passwordPolicyConfig !== 'undefined') {
	            this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
	        }
	        if (typeof response.emailPrivacyConfig !== 'undefined') {
	            this.emailPrivacyConfig = response.emailPrivacyConfig;
	        }
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        // JSON serialization
	        const json = {
	            smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
	            multiFactorConfig: (0, deep_copy_1.deepCopy)(this.multiFactorConfig),
	            recaptchaConfig: (0, deep_copy_1.deepCopy)(this.recaptchaConfig),
	            passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
	            emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig),
	        };
	        if (typeof json.smsRegionConfig === 'undefined') {
	            delete json.smsRegionConfig;
	        }
	        if (typeof json.multiFactorConfig === 'undefined') {
	            delete json.multiFactorConfig;
	        }
	        if (typeof json.recaptchaConfig === 'undefined') {
	            delete json.recaptchaConfig;
	        }
	        if (typeof json.passwordPolicyConfig === 'undefined') {
	            delete json.passwordPolicyConfig;
	        }
	        if (typeof json.emailPrivacyConfig === 'undefined') {
	            delete json.emailPrivacyConfig;
	        }
	        return json;
	    }
	}
	projectConfig.ProjectConfig = ProjectConfig;
	return projectConfig;
}

/*! firebase-admin v12.7.0 */

var hasRequiredAuthApiRequest;

function requireAuthApiRequest () {
	if (hasRequiredAuthApiRequest) return authApiRequest;
	hasRequiredAuthApiRequest = 1;
	(function (exports) {
		/*!
		 * @license
		 * Copyright 2017 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.useEmulator = exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;
		const validator = validator$2;
		const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
		const error_1 = error;
		const api_request_1 = /*@__PURE__*/ requireApiRequest();
		const utils = utils$1;
		const user_import_builder_1 = /*@__PURE__*/ requireUserImportBuilder();
		const action_code_settings_builder_1 = /*@__PURE__*/ requireActionCodeSettingsBuilder();
		const tenant_1 = /*@__PURE__*/ requireTenant();
		const identifier_1 = /*@__PURE__*/ requireIdentifier();
		const auth_config_1 = /*@__PURE__*/ requireAuthConfig();
		const project_config_1 = /*@__PURE__*/ requireProjectConfig();
		/** Firebase Auth request header. */
		const FIREBASE_AUTH_HEADERS = {
		    'X-Client-Version': `Node/Admin/${utils.getSdkVersion()}`,
		    'X-Goog-Api-Client': `gl-node/${process.versions.node} fire-admin/${utils.getSdkVersion()}`
		};
		/** Firebase Auth request timeout duration in milliseconds. */
		const FIREBASE_AUTH_TIMEOUT = 25000;
		/** List of reserved claims which cannot be provided when creating a custom token. */
		exports.RESERVED_CLAIMS = [
		    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',
		    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',
		];
		/** List of supported email action request types. */
		exports.EMAIL_ACTION_REQUEST_TYPES = [
		    'PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN', 'VERIFY_AND_CHANGE_EMAIL',
		];
		/** Maximum allowed number of characters in the custom claims payload. */
		const MAX_CLAIMS_PAYLOAD_SIZE = 1000;
		/** Maximum allowed number of users to batch download at one time. */
		const MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;
		/** Maximum allowed number of users to batch upload at one time. */
		const MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;
		/** Maximum allowed number of users to batch get at one time. */
		const MAX_GET_ACCOUNTS_BATCH_SIZE = 100;
		/** Maximum allowed number of users to batch delete at one time. */
		const MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;
		/** Minimum allowed session cookie duration in seconds (5 minutes). */
		const MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;
		/** Maximum allowed session cookie duration in seconds (2 weeks). */
		const MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;
		/** Maximum allowed number of provider configurations to batch download at one time. */
		const MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;
		/** The Firebase Auth backend base URL format. */
		const FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';
		/** Firebase Auth base URlLformat when using the auth emultor. */
		const FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';
		/** The Firebase Auth backend multi-tenancy base URL format. */
		const FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');
		/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */
		const FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');
		/** Maximum allowed number of tenants to download at one time. */
		const MAX_LIST_TENANT_PAGE_SIZE = 1000;
		/**
		 * Enum for the user write operation type.
		 */
		var WriteOperationType;
		(function (WriteOperationType) {
		    WriteOperationType["Create"] = "create";
		    WriteOperationType["Update"] = "update";
		    WriteOperationType["Upload"] = "upload";
		})(WriteOperationType || (WriteOperationType = {}));
		/** Defines a base utility to help with resource URL construction. */
		class AuthResourceUrlBuilder {
		    /**
		     * The resource URL builder constructor.
		     *
		     * @param projectId - The resource project ID.
		     * @param version - The endpoint API version.
		     * @constructor
		     */
		    constructor(app, version = 'v1') {
		        this.app = app;
		        this.version = version;
		        if (useEmulator()) {
		            this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {
		                host: emulatorHost()
		            });
		        }
		        else {
		            this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;
		        }
		    }
		    /**
		     * Returns the resource URL corresponding to the provided parameters.
		     *
		     * @param api - The backend API name.
		     * @param params - The optional additional parameters to substitute in the
		     *     URL path.
		     * @returns The corresponding resource URL.
		     */
		    getUrl(api, params) {
		        return this.getProjectId()
		            .then((projectId) => {
		            const baseParams = {
		                version: this.version,
		                projectId,
		                api: api || '',
		            };
		            const baseUrl = utils.formatString(this.urlFormat, baseParams);
		            // Substitute additional api related parameters.
		            return utils.formatString(baseUrl, params || {});
		        });
		    }
		    getProjectId() {
		        if (this.projectId) {
		            return Promise.resolve(this.projectId);
		        }
		        return utils.findProjectId(this.app)
		            .then((projectId) => {
		            if (!validator.isNonEmptyString(projectId)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the '
		                    + 'SDK with service account credentials or set project ID as an app option. '
		                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');
		            }
		            this.projectId = projectId;
		            return projectId;
		        });
		    }
		}
		/** Tenant aware resource builder utility. */
		class TenantAwareAuthResourceUrlBuilder extends AuthResourceUrlBuilder {
		    /**
		     * The tenant aware resource URL builder constructor.
		     *
		     * @param projectId - The resource project ID.
		     * @param version - The endpoint API version.
		     * @param tenantId - The tenant ID.
		     * @constructor
		     */
		    constructor(app, version, tenantId) {
		        super(app, version);
		        this.app = app;
		        this.version = version;
		        this.tenantId = tenantId;
		        if (useEmulator()) {
		            this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {
		                host: emulatorHost()
		            });
		        }
		        else {
		            this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;
		        }
		    }
		    /**
		     * Returns the resource URL corresponding to the provided parameters.
		     *
		     * @param api - The backend API name.
		     * @param params - The optional additional parameters to substitute in the
		     *     URL path.
		     * @returns The corresponding resource URL.
		     */
		    getUrl(api, params) {
		        return super.getUrl(api, params)
		            .then((url) => {
		            return utils.formatString(url, { tenantId: this.tenantId });
		        });
		    }
		}
		/**
		 * Auth-specific HTTP client which uses the special "owner" token
		 * when communicating with the Auth Emulator.
		 */
		class AuthHttpClient extends api_request_1.AuthorizedHttpClient {
		    getToken() {
		        if (useEmulator()) {
		            return Promise.resolve('owner');
		        }
		        return super.getToken();
		    }
		}
		/**
		 * Validates an AuthFactorInfo object. All unsupported parameters
		 * are removed from the original request. If an invalid field is passed
		 * an error is thrown.
		 *
		 * @param request - The AuthFactorInfo request object.
		 */
		function validateAuthFactorInfo(request) {
		    const validKeys = {
		        mfaEnrollmentId: true,
		        displayName: true,
		        phoneInfo: true,
		        enrolledAt: true,
		    };
		    // Remove unsupported keys from the original request.
		    for (const key in request) {
		        if (!(key in validKeys)) {
		            delete request[key];
		        }
		    }
		    // No enrollment ID is available for signupNewUser. Use another identifier.
		    const authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);
		    // Enrollment uid may or may not be specified for update operations.
		    if (typeof request.mfaEnrollmentId !== 'undefined' &&
		        !validator.isNonEmptyString(request.mfaEnrollmentId)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor "uid" must be a valid non-empty string.');
		    }
		    if (typeof request.displayName !== 'undefined' &&
		        !validator.isString(request.displayName)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor "displayName" for "${authFactorInfoIdentifier}" must be a valid string.`);
		    }
		    // enrolledAt must be a valid UTC date string.
		    if (typeof request.enrolledAt !== 'undefined' &&
		        !validator.isISODateString(request.enrolledAt)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${authFactorInfoIdentifier}" must be a valid ` +
		            'UTC date string.');
		    }
		    // Validate required fields depending on second factor type.
		    if (typeof request.phoneInfo !== 'undefined') {
		        // phoneNumber should be a string and a valid phone number.
		        if (!validator.isPhoneNumber(request.phoneInfo)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor "phoneNumber" for "${authFactorInfoIdentifier}" must be a non-empty ` +
		                'E.164 standard compliant identifier string.');
		        }
		    }
		    else {
		        // Invalid second factor. For example, a phone second factor may have been provided without
		        // a phone number. A TOTP based second factor may require a secret key, etc.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');
		    }
		}
		/**
		 * Validates a providerUserInfo object. All unsupported parameters
		 * are removed from the original request. If an invalid field is passed
		 * an error is thrown.
		 *
		 * @param request - The providerUserInfo request object.
		 */
		function validateProviderUserInfo(request) {
		    const validKeys = {
		        rawId: true,
		        providerId: true,
		        email: true,
		        displayName: true,
		        photoUrl: true,
		    };
		    // Remove invalid keys from original request.
		    for (const key in request) {
		        if (!(key in validKeys)) {
		            delete request[key];
		        }
		    }
		    if (!validator.isNonEmptyString(request.providerId)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
		    }
		    if (typeof request.displayName !== 'undefined' &&
		        typeof request.displayName !== 'string') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider "displayName" for "${request.providerId}" must be a valid string.`);
		    }
		    if (!validator.isNonEmptyString(request.rawId)) {
		        // This is called localId on the backend but the developer specifies this as
		        // uid externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, `The provider "uid" for "${request.providerId}" must be a valid non-empty string.`);
		    }
		    // email should be a string and a valid email.
		    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, `The provider "email" for "${request.providerId}" must be a valid email string.`);
		    }
		    // photoUrl should be a URL.
		    if (typeof request.photoUrl !== 'undefined' &&
		        !validator.isURL(request.photoUrl)) {
		        // This is called photoUrl on the backend but the developer specifies this as
		        // photoURL externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider "photoURL" for "${request.providerId}" must be a valid URL string.`);
		    }
		}
		/**
		 * Validates a create/edit request object. All unsupported parameters
		 * are removed from the original request. If an invalid field is passed
		 * an error is thrown.
		 *
		 * @param request - The create/edit request object.
		 * @param writeOperationType - The write operation type.
		 */
		function validateCreateEditRequest(request, writeOperationType) {
		    const uploadAccountRequest = writeOperationType === WriteOperationType.Upload;
		    // Hash set of whitelisted parameters.
		    const validKeys = {
		        displayName: true,
		        localId: true,
		        email: true,
		        password: true,
		        rawPassword: true,
		        emailVerified: true,
		        photoUrl: true,
		        disabled: true,
		        disableUser: true,
		        deleteAttribute: true,
		        deleteProvider: true,
		        sanityCheck: true,
		        phoneNumber: true,
		        customAttributes: true,
		        validSince: true,
		        // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)
		        linkProviderUserInfo: !uploadAccountRequest,
		        // Pass tenantId only for uploadAccount requests.
		        tenantId: uploadAccountRequest,
		        passwordHash: uploadAccountRequest,
		        salt: uploadAccountRequest,
		        createdAt: uploadAccountRequest,
		        lastLoginAt: uploadAccountRequest,
		        providerUserInfo: uploadAccountRequest,
		        mfaInfo: uploadAccountRequest,
		        // Only for non-uploadAccount requests.
		        mfa: !uploadAccountRequest,
		    };
		    // Remove invalid keys from original request.
		    for (const key in request) {
		        if (!(key in validKeys)) {
		            delete request[key];
		        }
		    }
		    if (typeof request.tenantId !== 'undefined' &&
		        !validator.isNonEmptyString(request.tenantId)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
		    }
		    // For any invalid parameter, use the external key name in the error description.
		    // displayName should be a string.
		    if (typeof request.displayName !== 'undefined' &&
		        !validator.isString(request.displayName)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);
		    }
		    if ((typeof request.localId !== 'undefined' || uploadAccountRequest) &&
		        !validator.isUid(request.localId)) {
		        // This is called localId on the backend but the developer specifies this as
		        // uid externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
		    }
		    // email should be a string and a valid email.
		    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
		    }
		    // phoneNumber should be a string and a valid phone number.
		    if (typeof request.phoneNumber !== 'undefined' &&
		        !validator.isPhoneNumber(request.phoneNumber)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
		    }
		    // password should be a string and a minimum of 6 chars.
		    if (typeof request.password !== 'undefined' &&
		        !validator.isPassword(request.password)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
		    }
		    // rawPassword should be a string and a minimum of 6 chars.
		    if (typeof request.rawPassword !== 'undefined' &&
		        !validator.isPassword(request.rawPassword)) {
		        // This is called rawPassword on the backend but the developer specifies this as
		        // password externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
		    }
		    // emailVerified should be a boolean.
		    if (typeof request.emailVerified !== 'undefined' &&
		        typeof request.emailVerified !== 'boolean') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);
		    }
		    // photoUrl should be a URL.
		    if (typeof request.photoUrl !== 'undefined' &&
		        !validator.isURL(request.photoUrl)) {
		        // This is called photoUrl on the backend but the developer specifies this as
		        // photoURL externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);
		    }
		    // disabled should be a boolean.
		    if (typeof request.disabled !== 'undefined' &&
		        typeof request.disabled !== 'boolean') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
		    }
		    // validSince should be a number.
		    if (typeof request.validSince !== 'undefined' &&
		        !validator.isNumber(request.validSince)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);
		    }
		    // createdAt should be a number.
		    if (typeof request.createdAt !== 'undefined' &&
		        !validator.isNumber(request.createdAt)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);
		    }
		    // lastSignInAt should be a number.
		    if (typeof request.lastLoginAt !== 'undefined' &&
		        !validator.isNumber(request.lastLoginAt)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);
		    }
		    // disableUser should be a boolean.
		    if (typeof request.disableUser !== 'undefined' &&
		        typeof request.disableUser !== 'boolean') {
		        // This is called disableUser on the backend but the developer specifies this as
		        // disabled externally. So the error message should use the client facing name.
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
		    }
		    // customAttributes should be stringified JSON with no blacklisted claims.
		    // The payload should not exceed 1KB.
		    if (typeof request.customAttributes !== 'undefined') {
		        let developerClaims;
		        try {
		            developerClaims = JSON.parse(request.customAttributes);
		        }
		        catch (error) {
		            // JSON parsing error. This should never happen as we stringify the claims internally.
		            // However, we still need to check since setAccountInfo via edit requests could pass
		            // this field.
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);
		        }
		        const invalidClaims = [];
		        // Check for any invalid claims.
		        exports.RESERVED_CLAIMS.forEach((blacklistedClaim) => {
		            if (Object.prototype.hasOwnProperty.call(developerClaims, blacklistedClaim)) {
		                invalidClaims.push(blacklistedClaim);
		            }
		        });
		        // Throw an error if an invalid claim is detected.
		        if (invalidClaims.length > 0) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims.length > 1 ?
		                `Developer claims "${invalidClaims.join('", "')}" are reserved and cannot be specified.` :
		                `Developer claim "${invalidClaims[0]}" is reserved and cannot be specified.`);
		        }
		        // Check claims payload does not exceed maxmimum size.
		        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${MAX_CLAIMS_PAYLOAD_SIZE} characters.`);
		        }
		    }
		    // passwordHash has to be a base64 encoded string.
		    if (typeof request.passwordHash !== 'undefined' &&
		        !validator.isString(request.passwordHash)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
		    }
		    // salt has to be a base64 encoded string.
		    if (typeof request.salt !== 'undefined' &&
		        !validator.isString(request.salt)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
		    }
		    // providerUserInfo has to be an array of valid UserInfo requests.
		    if (typeof request.providerUserInfo !== 'undefined' &&
		        !validator.isArray(request.providerUserInfo)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);
		    }
		    else if (validator.isArray(request.providerUserInfo)) {
		        request.providerUserInfo.forEach((providerUserInfoEntry) => {
		            validateProviderUserInfo(providerUserInfoEntry);
		        });
		    }
		    // linkProviderUserInfo must be a (single) UserProvider value.
		    if (typeof request.linkProviderUserInfo !== 'undefined') {
		        validateProviderUserInfo(request.linkProviderUserInfo);
		    }
		    // mfaInfo is used for importUsers.
		    // mfa.enrollments is used for setAccountInfo.
		    // enrollments has to be an array of valid AuthFactorInfo requests.
		    let enrollments = null;
		    if (request.mfaInfo) {
		        enrollments = request.mfaInfo;
		    }
		    else if (request.mfa && request.mfa.enrollments) {
		        enrollments = request.mfa.enrollments;
		    }
		    if (enrollments) {
		        if (!validator.isArray(enrollments)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);
		        }
		        enrollments.forEach((authFactorInfoEntry) => {
		            validateAuthFactorInfo(authFactorInfoEntry);
		        });
		    }
		}
		/**
		 * Instantiates the createSessionCookie endpoint settings.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // Validate the ID token is a non-empty string.
		    if (!validator.isNonEmptyString(request.idToken)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);
		    }
		    // Validate the custom session cookie duration.
		    if (!validator.isNumber(request.validDuration) ||
		        request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS ||
		        request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);
		    }
		})
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the session cookie.
		    if (!validator.isNonEmptyString(response.sessionCookie)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);
		    }
		});
		/**
		 * Instantiates the uploadAccount endpoint settings.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');
		/**
		 * Instantiates the downloadAccount endpoint settings.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // Validate next page token.
		    if (typeof request.nextPageToken !== 'undefined' &&
		        !validator.isNonEmptyString(request.nextPageToken)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
		    }
		    // Validate max results.
		    if (!validator.isNumber(request.maxResults) ||
		        request.maxResults <= 0 ||
		        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required "maxResults" must be a positive integer that does not exceed ' +
		            `${MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE}.`);
		    }
		});
		/**
		 * Instantiates the getAccountInfo endpoint settings.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
		    }
		})
		    // Set response validator.
		    .setResponseValidator((response) => {
		    if (!response.users || !response.users.length) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
		    }
		});
		/**
		 * Instantiates the getAccountInfo endpoint settings for use when fetching info
		 * for multiple accounts.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
		    }
		});
		/**
		 * Instantiates the deleteAccount endpoint settings.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    if (!request.localId) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
		    }
		});
		/**
		 * @internal
		 */
		exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST')
		    .setRequestValidator((request) => {
		    if (!request.localIds) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');
		    }
		    if (typeof request.force === 'undefined' || request.force !== true) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');
		    }
		})
		    .setResponseValidator((response) => {
		    const errors = response.errors || [];
		    errors.forEach((batchDeleteErrorInfo) => {
		        if (typeof batchDeleteErrorInfo.index === 'undefined') {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');
		        }
		        if (!batchDeleteErrorInfo.localId) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');
		        }
		        // Allow the (error) message to be missing/undef.
		    });
		});
		/**
		 * Instantiates the setAccountInfo endpoint settings for updating existing accounts.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // localId is a required parameter.
		    if (typeof request.localId === 'undefined') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');
		    }
		    // Throw error when tenantId is passed in POST body.
		    if (typeof request.tenantId !== 'undefined') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "UpdateRequest" property.');
		    }
		    validateCreateEditRequest(request, WriteOperationType.Update);
		})
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // If the localId is not returned, then the request failed.
		    if (!response.localId) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
		    }
		});
		/**
		 * Instantiates the signupNewUser endpoint settings for creating a new user with or without
		 * uid being specified. The backend will create a new one if not provided and return it.
		 *
		 * @internal
		 */
		exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // signupNewUser does not support customAttributes.
		    if (typeof request.customAttributes !== 'undefined') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"customAttributes" cannot be set when creating a new user.');
		    }
		    // signupNewUser does not support validSince.
		    if (typeof request.validSince !== 'undefined') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"validSince" cannot be set when creating a new user.');
		    }
		    // Throw error when tenantId is passed in POST body.
		    if (typeof request.tenantId !== 'undefined') {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "CreateRequest" property.');
		    }
		    validateCreateEditRequest(request, WriteOperationType.Create);
		})
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // If the localId is not returned, then the request failed.
		    if (!response.localId) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');
		    }
		});
		const FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    if (!validator.isEmail(request.email)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
		    }
		    if (typeof request.newEmail !== 'undefined' && !validator.isEmail(request.newEmail)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_NEW_EMAIL);
		    }
		    if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${request.requestType}" is not a supported email action request type.`);
		    }
		})
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // If the oobLink is not returned, then the request failed.
		    if (!response.oobLink) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');
		    }
		});
		/**
		 * Instantiates the retrieve OIDC configuration endpoint settings.
		 *
		 * @internal
		 */
		const GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the OIDC provider resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');
		    }
		});
		/**
		 * Instantiates the delete OIDC configuration endpoint settings.
		 *
		 * @internal
		 */
		const DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');
		/**
		 * Instantiates the create OIDC configuration endpoint settings.
		 *
		 * @internal
		 */
		const CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the OIDC provider resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');
		    }
		});
		/**
		 * Instantiates the update OIDC configuration endpoint settings.
		 *
		 * @internal
		 */
		const UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the configuration resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');
		    }
		});
		/**
		 * Instantiates the list OIDC configuration endpoint settings.
		 *
		 * @internal
		 */
		const LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // Validate next page token.
		    if (typeof request.pageToken !== 'undefined' &&
		        !validator.isNonEmptyString(request.pageToken)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
		    }
		    // Validate max results.
		    if (!validator.isNumber(request.pageSize) ||
		        request.pageSize <= 0 ||
		        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required "maxResults" must be a positive integer that does not exceed ' +
		            `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
		    }
		});
		/**
		 * Instantiates the retrieve SAML configuration endpoint settings.
		 *
		 * @internal
		 */
		const GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the SAML provider resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');
		    }
		});
		/**
		 * Instantiates the delete SAML configuration endpoint settings.
		 *
		 * @internal
		 */
		const DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');
		/**
		 * Instantiates the create SAML configuration endpoint settings.
		 *
		 * @internal
		 */
		const CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the SAML provider resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');
		    }
		});
		/**
		 * Instantiates the update SAML configuration endpoint settings.
		 *
		 * @internal
		 */
		const UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain the configuration resource name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');
		    }
		});
		/**
		 * Instantiates the list SAML configuration endpoint settings.
		 *
		 * @internal
		 */
		const LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // Validate next page token.
		    if (typeof request.pageToken !== 'undefined' &&
		        !validator.isNonEmptyString(request.pageToken)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
		    }
		    // Validate max results.
		    if (!validator.isNumber(request.pageSize) ||
		        request.pageSize <= 0 ||
		        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required "maxResults" must be a positive integer that does not exceed ' +
		            `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
		    }
		});
		/**
		 * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.
		 *
		 * @internal
		 */
		class AbstractAuthRequestHandler {
		    /**
		     * @param response - The response to check for errors.
		     * @returns The error code if present; null otherwise.
		     */
		    static getErrorCode(response) {
		        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;
		    }
		    static addUidToRequest(id, request) {
		        if (!validator.isUid(id.uid)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
		        }
		        request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];
		        return request;
		    }
		    static addEmailToRequest(id, request) {
		        if (!validator.isEmail(id.email)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
		        }
		        request.email ? request.email.push(id.email) : request.email = [id.email];
		        return request;
		    }
		    static addPhoneToRequest(id, request) {
		        if (!validator.isPhoneNumber(id.phoneNumber)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
		        }
		        request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];
		        return request;
		    }
		    static addProviderToRequest(id, request) {
		        if (!validator.isNonEmptyString(id.providerId)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
		        }
		        if (!validator.isNonEmptyString(id.providerUid)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);
		        }
		        const federatedUserId = {
		            providerId: id.providerId,
		            rawId: id.providerUid,
		        };
		        request.federatedUserId
		            ? request.federatedUserId.push(federatedUserId)
		            : request.federatedUserId = [federatedUserId];
		        return request;
		    }
		    /**
		     * @param app - The app used to fetch access tokens to sign API requests.
		     * @constructor
		     */
		    constructor(app) {
		        this.app = app;
		        if (typeof app !== 'object' || app === null || !('options' in app)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');
		        }
		        this.httpClient = new AuthHttpClient(app);
		    }
		    /**
		     * Creates a new Firebase session cookie with the specified duration that can be used for
		     * session management (set as a server side session cookie with custom cookie policy).
		     * The session cookie JWT will have the same payload claims as the provided ID token.
		     *
		     * @param idToken - The Firebase ID token to exchange for a session cookie.
		     * @param expiresIn - The session cookie duration in milliseconds.
		     *
		     * @returns A promise that resolves on success with the created session cookie.
		     */
		    createSessionCookie(idToken, expiresIn) {
		        const request = {
		            idToken,
		            // Convert to seconds.
		            validDuration: Math.floor(expiresIn / 1000),
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request)
		            .then((response) => response.sessionCookie);
		    }
		    /**
		     * Looks up a user by uid.
		     *
		     * @param uid - The uid of the user to lookup.
		     * @returns A promise that resolves with the user information.
		     */
		    getAccountInfoByUid(uid) {
		        if (!validator.isUid(uid)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
		        }
		        const request = {
		            localId: [uid],
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
		    }
		    /**
		     * Looks up a user by email.
		     *
		     * @param email - The email of the user to lookup.
		     * @returns A promise that resolves with the user information.
		     */
		    getAccountInfoByEmail(email) {
		        if (!validator.isEmail(email)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));
		        }
		        const request = {
		            email: [email],
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
		    }
		    /**
		     * Looks up a user by phone number.
		     *
		     * @param phoneNumber - The phone number of the user to lookup.
		     * @returns A promise that resolves with the user information.
		     */
		    getAccountInfoByPhoneNumber(phoneNumber) {
		        if (!validator.isPhoneNumber(phoneNumber)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));
		        }
		        const request = {
		            phoneNumber: [phoneNumber],
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
		    }
		    getAccountInfoByFederatedUid(providerId, rawId) {
		        if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
		        }
		        const request = {
		            federatedUserId: [{
		                    providerId,
		                    rawId,
		                }],
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
		    }
		    /**
		     * Looks up multiple users by their identifiers (uid, email, etc).
		     *
		     * @param identifiers - The identifiers indicating the users
		     *     to be looked up. Must have <= 100 entries.
		     * @param A - promise that resolves with the set of successfully
		     *     looked up users. Possibly empty if no users were looked up.
		     */
		    getAccountInfoByIdentifiers(identifiers) {
		        if (identifiers.length === 0) {
		            return Promise.resolve({ users: [] });
		        }
		        else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');
		        }
		        let request = {};
		        for (const id of identifiers) {
		            if ((0, identifier_1.isUidIdentifier)(id)) {
		                request = AbstractAuthRequestHandler.addUidToRequest(id, request);
		            }
		            else if ((0, identifier_1.isEmailIdentifier)(id)) {
		                request = AbstractAuthRequestHandler.addEmailToRequest(id, request);
		            }
		            else if ((0, identifier_1.isPhoneIdentifier)(id)) {
		                request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);
		            }
		            else if ((0, identifier_1.isProviderIdentifier)(id)) {
		                request = AbstractAuthRequestHandler.addProviderToRequest(id, request);
		            }
		            else {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);
		            }
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);
		    }
		    /**
		     * Exports the users (single batch only) with a size of maxResults and starting from
		     * the offset as specified by pageToken.
		     *
		     * @param maxResults - The page size, 1000 if undefined. This is also the maximum
		     *     allowed limit.
		     * @param pageToken - The next page token. If not specified, returns users starting
		     *     without any offset. Users are returned in the order they were created from oldest to
		     *     newest, relative to the page token offset.
		     * @returns A promise that resolves with the current batch of downloaded
		     *     users and the next page token if available. For the last page, an empty list of users
		     *     and no page token are returned.
		     */
		    downloadAccount(maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE, pageToken) {
		        // Construct request.
		        const request = {
		            maxResults,
		            nextPageToken: pageToken,
		        };
		        // Remove next page token if not provided.
		        if (typeof request.nextPageToken === 'undefined') {
		            delete request.nextPageToken;
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)
		            .then((response) => {
		            // No more users available.
		            if (!response.users) {
		                response.users = [];
		            }
		            return response;
		        });
		    }
		    /**
		     * Imports the list of users provided to Firebase Auth. This is useful when
		     * migrating from an external authentication system without having to use the Firebase CLI SDK.
		     * At most, 1000 users are allowed to be imported one at a time.
		     * When importing a list of password users, UserImportOptions are required to be specified.
		     *
		     * @param users - The list of user records to import to Firebase Auth.
		     * @param options - The user import options, required when the users provided
		     *     include password credentials.
		     * @returns A promise that resolves when the operation completes
		     *     with the result of the import. This includes the number of successful imports, the number
		     *     of failed uploads and their corresponding errors.
		     */
		    uploadAccount(users, options) {
		        // This will throw if any error is detected in the hash options.
		        // For errors in the list of users, this will not throw and will report the errors and the
		        // corresponding user index in the user import generated response below.
		        // No need to validate raw request or raw response as this is done in UserImportBuilder.
		        const userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, (userRequest) => {
		            // Pass true to validate the uploadAccount specific fields.
		            validateCreateEditRequest(userRequest, WriteOperationType.Upload);
		        });
		        const request = userImportBuilder.buildRequest();
		        // Fail quickly if more users than allowed are to be imported.
		        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${MAX_UPLOAD_ACCOUNT_BATCH_SIZE} users can be imported at once.`);
		        }
		        // If no remaining user in request after client side processing, there is no need
		        // to send the request to the server.
		        if (!request.users || request.users.length === 0) {
		            return Promise.resolve(userImportBuilder.buildResponse([]));
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request)
		            .then((response) => {
		            // No error object is returned if no error encountered.
		            const failedUploads = (response.error || []);
		            // Rewrite response as UserImportResult and re-insert client previously detected errors.
		            return userImportBuilder.buildResponse(failedUploads);
		        });
		    }
		    /**
		     * Deletes an account identified by a uid.
		     *
		     * @param uid - The uid of the user to delete.
		     * @returns A promise that resolves when the user is deleted.
		     */
		    deleteAccount(uid) {
		        if (!validator.isUid(uid)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
		        }
		        const request = {
		            localId: uid,
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);
		    }
		    deleteAccounts(uids, force) {
		        if (uids.length === 0) {
		            return Promise.resolve({});
		        }
		        else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');
		        }
		        const request = {
		            localIds: [],
		            force,
		        };
		        uids.forEach((uid) => {
		            if (!validator.isUid(uid)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
		            }
		            request.localIds.push(uid);
		        });
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);
		    }
		    /**
		     * Sets additional developer claims on an existing user identified by provided UID.
		     *
		     * @param uid - The user to edit.
		     * @param customUserClaims - The developer claims to set.
		     * @returns A promise that resolves when the operation completes
		     *     with the user id that was edited.
		     */
		    setCustomUserClaims(uid, customUserClaims) {
		        // Validate user UID.
		        if (!validator.isUid(uid)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
		        }
		        else if (!validator.isObject(customUserClaims)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));
		        }
		        // Delete operation. Replace null with an empty object.
		        if (customUserClaims === null) {
		            customUserClaims = {};
		        }
		        // Construct custom user attribute editting request.
		        const request = {
		            localId: uid,
		            customAttributes: JSON.stringify(customUserClaims),
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
		            .then((response) => {
		            return response.localId;
		        });
		    }
		    /**
		     * Edits an existing user.
		     *
		     * @param uid - The user to edit.
		     * @param properties - The properties to set on the user.
		     * @returns A promise that resolves when the operation completes
		     *     with the user id that was edited.
		     */
		    updateExistingAccount(uid, properties) {
		        if (!validator.isUid(uid)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
		        }
		        else if (!validator.isNonNullObject(properties)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));
		        }
		        else if (validator.isNonNullObject(properties.providerToLink)) {
		            // TODO(rsgowman): These checks overlap somewhat with
		            // validateProviderUserInfo. It may be possible to refactor a bit.
		            if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');
		            }
		            if (!validator.isNonEmptyString(properties.providerToLink.uid)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');
		            }
		        }
		        else if (typeof properties.providersToUnlink !== 'undefined') {
		            if (!validator.isArray(properties.providersToUnlink)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');
		            }
		            properties.providersToUnlink.forEach((providerId) => {
		                if (!validator.isNonEmptyString(providerId)) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');
		                }
		            });
		        }
		        // Build the setAccountInfo request.
		        const request = (0, deep_copy_1.deepCopy)(properties);
		        request.localId = uid;
		        // For deleting displayName or photoURL, these values must be passed as null.
		        // They will be removed from the backend request and an additional parameter
		        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']
		        // with an array of the parameter names to delete will be passed.
		        // Parameters that are deletable and their deleteAttribute names.
		        // Use client facing names, photoURL instead of photoUrl.
		        const deletableParams = {
		            displayName: 'DISPLAY_NAME',
		            photoURL: 'PHOTO_URL',
		        };
		        // Properties to delete if available.
		        request.deleteAttribute = [];
		        for (const key in deletableParams) {
		            if (request[key] === null) {
		                // Add property identifier to list of attributes to delete.
		                request.deleteAttribute.push(deletableParams[key]);
		                // Remove property from request.
		                delete request[key];
		            }
		        }
		        if (request.deleteAttribute.length === 0) {
		            delete request.deleteAttribute;
		        }
		        // For deleting phoneNumber, this value must be passed as null.
		        // It will be removed from the backend request and an additional parameter
		        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),
		        // will be passed.
		        if (request.phoneNumber === null) {
		            request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];
		            delete request.phoneNumber;
		        }
		        if (typeof (request.providerToLink) !== 'undefined') {
		            request.linkProviderUserInfo = (0, deep_copy_1.deepCopy)(request.providerToLink);
		            delete request.providerToLink;
		            request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;
		            delete request.linkProviderUserInfo.uid;
		        }
		        if (typeof (request.providersToUnlink) !== 'undefined') {
		            if (!validator.isArray(request.deleteProvider)) {
		                request.deleteProvider = [];
		            }
		            request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);
		            delete request.providersToUnlink;
		        }
		        // Rewrite photoURL to photoUrl.
		        if (typeof request.photoURL !== 'undefined') {
		            request.photoUrl = request.photoURL;
		            delete request.photoURL;
		        }
		        // Rewrite disabled to disableUser.
		        if (typeof request.disabled !== 'undefined') {
		            request.disableUser = request.disabled;
		            delete request.disabled;
		        }
		        // Construct mfa related user data.
		        if (validator.isNonNullObject(request.multiFactor)) {
		            if (request.multiFactor.enrolledFactors === null) {
		                // Remove all second factors.
		                request.mfa = {};
		            }
		            else if (validator.isArray(request.multiFactor.enrolledFactors)) {
		                request.mfa = {
		                    enrollments: [],
		                };
		                try {
		                    request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
		                        request.mfa.enrollments.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
		                    });
		                }
		                catch (e) {
		                    return Promise.reject(e);
		                }
		                if (request.mfa.enrollments.length === 0) {
		                    delete request.mfa.enrollments;
		                }
		            }
		            delete request.multiFactor;
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
		            .then((response) => {
		            return response.localId;
		        });
		    }
		    /**
		     * Revokes all refresh tokens for the specified user identified by the uid provided.
		     * In addition to revoking all refresh tokens for a user, all ID tokens issued
		     * before revocation will also be revoked on the Auth backend. Any request with an
		     * ID token generated before revocation will be rejected with a token expired error.
		     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in
		     * the same second as the revocation will still be valid. If there is a chance that a token
		     * was minted in the last second, delay for 1 second before revoking.
		     *
		     * @param uid - The user whose tokens are to be revoked.
		     * @returns A promise that resolves when the operation completes
		     *     successfully with the user id of the corresponding user.
		     */
		    revokeRefreshTokens(uid) {
		        // Validate user UID.
		        if (!validator.isUid(uid)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
		        }
		        const request = {
		            localId: uid,
		            // validSince is in UTC seconds.
		            validSince: Math.floor(new Date().getTime() / 1000),
		        };
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)
		            .then((response) => {
		            return response.localId;
		        });
		    }
		    /**
		     * Create a new user with the properties supplied.
		     *
		     * @param properties - The properties to set on the user.
		     * @returns A promise that resolves when the operation completes
		     *     with the user id that was created.
		     */
		    createNewAccount(properties) {
		        if (!validator.isNonNullObject(properties)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));
		        }
		        const request = (0, deep_copy_1.deepCopy)(properties);
		        // Rewrite photoURL to photoUrl.
		        if (typeof request.photoURL !== 'undefined') {
		            request.photoUrl = request.photoURL;
		            delete request.photoURL;
		        }
		        // Rewrite uid to localId if it exists.
		        if (typeof request.uid !== 'undefined') {
		            request.localId = request.uid;
		            delete request.uid;
		        }
		        // Construct mfa related user data.
		        if (validator.isNonNullObject(request.multiFactor)) {
		            if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {
		                const mfaInfo = [];
		                try {
		                    request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
		                        // Enrollment time and uid are not allowed for signupNewUser endpoint.
		                        // They will automatically be provisioned server side.
		                        if ('enrollmentTime' in multiFactorInfo) {
		                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"enrollmentTime" is not supported when adding second factors via "createUser()"');
		                        }
		                        else if ('uid' in multiFactorInfo) {
		                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"uid" is not supported when adding second factors via "createUser()"');
		                        }
		                        mfaInfo.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
		                    });
		                }
		                catch (e) {
		                    return Promise.reject(e);
		                }
		                request.mfaInfo = mfaInfo;
		            }
		            delete request.multiFactor;
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)
		            .then((response) => {
		            // Return the user id.
		            return response.localId;
		        });
		    }
		    /**
		     * Generates the out of band email action link for the email specified using the action code settings provided.
		     * Returns a promise that resolves with the generated link.
		     *
		     * @param requestType - The request type. This could be either used for password reset,
		     *     email verification, email link sign-in.
		     * @param email - The email of the user the link is being sent to.
		     * @param actionCodeSettings - The optional action code setings which defines whether
		     *     the link is to be handled by a mobile app and the additional state information to be passed in the
		     *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'
		     * @param newEmail - The email address the account is being updated to.
		     *     Required only for VERIFY_AND_CHANGE_EMAIL requests.
		     * @returns A promise that resolves with the email action link.
		     */
		    getEmailActionLink(requestType, email, actionCodeSettings, newEmail) {
		        let request = {
		            requestType,
		            email,
		            returnOobLink: true,
		            ...(typeof newEmail !== 'undefined') && { newEmail },
		        };
		        // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will
		        // be completed.
		        if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'"));
		        }
		        if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {
		            try {
		                const builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);
		                request = (0, deep_copy_1.deepExtend)(request, builder.buildRequest());
		            }
		            catch (e) {
		                return Promise.reject(e);
		            }
		        }
		        if (requestType === 'VERIFY_AND_CHANGE_EMAIL' && typeof newEmail === 'undefined') {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'"));
		        }
		        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request)
		            .then((response) => {
		            // Return the link.
		            return response.oobLink;
		        });
		    }
		    /**
		     * Looks up an OIDC provider configuration by provider ID.
		     *
		     * @param providerId - The provider identifier of the configuration to lookup.
		     * @returns A promise that resolves with the provider configuration information.
		     */
		    getOAuthIdpConfig(providerId) {
		        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId });
		    }
		    /**
		     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from
		     * the offset as specified by pageToken.
		     *
		     * @param maxResults - The page size, 100 if undefined. This is also the maximum
		     *     allowed limit.
		     * @param pageToken - The next page token. If not specified, returns OIDC configurations
		     *     without any offset. Configurations are returned in the order they were created from oldest to
		     *     newest, relative to the page token offset.
		     * @returns A promise that resolves with the current batch of downloaded
		     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider
		     *     configuration and no page token are returned.
		     */
		    listOAuthIdpConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
		        const request = {
		            pageSize: maxResults,
		        };
		        // Add next page token if provided.
		        if (typeof pageToken !== 'undefined') {
		            request.pageToken = pageToken;
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request)
		            .then((response) => {
		            if (!response.oauthIdpConfigs) {
		                response.oauthIdpConfigs = [];
		                delete response.nextPageToken;
		            }
		            return response;
		        });
		    }
		    /**
		     * Deletes an OIDC configuration identified by a providerId.
		     *
		     * @param providerId - The identifier of the OIDC configuration to delete.
		     * @returns A promise that resolves when the OIDC provider is deleted.
		     */
		    deleteOAuthIdpConfig(providerId) {
		        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId })
		            .then(() => {
		            // Return nothing.
		        });
		    }
		    /**
		     * Creates a new OIDC provider configuration with the properties provided.
		     *
		     * @param options - The properties to set on the new OIDC provider configuration to be created.
		     * @returns A promise that resolves with the newly created OIDC
		     *     configuration.
		     */
		    createOAuthIdpConfig(options) {
		        // Construct backend request.
		        let request;
		        try {
		            request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		        const providerId = options.providerId;
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId })
		            .then((response) => {
		            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');
		            }
		            return response;
		        });
		    }
		    /**
		     * Updates an existing OIDC provider configuration with the properties provided.
		     *
		     * @param providerId - The provider identifier of the OIDC configuration to update.
		     * @param options - The properties to update on the existing configuration.
		     * @returns A promise that resolves with the modified provider
		     *     configuration.
		     */
		    updateOAuthIdpConfig(providerId, options) {
		        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        // Construct backend request.
		        let request;
		        try {
		            request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		        const updateMask = utils.generateUpdateMask(request);
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId, updateMask: updateMask.join(',') })
		            .then((response) => {
		            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');
		            }
		            return response;
		        });
		    }
		    /**
		     * Looks up an SAML provider configuration by provider ID.
		     *
		     * @param providerId - The provider identifier of the configuration to lookup.
		     * @returns A promise that resolves with the provider configuration information.
		     */
		    getInboundSamlConfig(providerId) {
		        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId });
		    }
		    /**
		     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from
		     * the offset as specified by pageToken.
		     *
		     * @param maxResults - The page size, 100 if undefined. This is also the maximum
		     *     allowed limit.
		     * @param pageToken - The next page token. If not specified, returns SAML configurations starting
		     *     without any offset. Configurations are returned in the order they were created from oldest to
		     *     newest, relative to the page token offset.
		     * @returns A promise that resolves with the current batch of downloaded
		     *     SAML configurations and the next page token if available. For the last page, an empty list of provider
		     *     configuration and no page token are returned.
		     */
		    listInboundSamlConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
		        const request = {
		            pageSize: maxResults,
		        };
		        // Add next page token if provided.
		        if (typeof pageToken !== 'undefined') {
		            request.pageToken = pageToken;
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request)
		            .then((response) => {
		            if (!response.inboundSamlConfigs) {
		                response.inboundSamlConfigs = [];
		                delete response.nextPageToken;
		            }
		            return response;
		        });
		    }
		    /**
		     * Deletes a SAML configuration identified by a providerId.
		     *
		     * @param providerId - The identifier of the SAML configuration to delete.
		     * @returns A promise that resolves when the SAML provider is deleted.
		     */
		    deleteInboundSamlConfig(providerId) {
		        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId })
		            .then(() => {
		            // Return nothing.
		        });
		    }
		    /**
		     * Creates a new SAML provider configuration with the properties provided.
		     *
		     * @param options - The properties to set on the new SAML provider configuration to be created.
		     * @returns A promise that resolves with the newly created SAML
		     *     configuration.
		     */
		    createInboundSamlConfig(options) {
		        // Construct backend request.
		        let request;
		        try {
		            request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		        const providerId = options.providerId;
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId })
		            .then((response) => {
		            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');
		            }
		            return response;
		        });
		    }
		    /**
		     * Updates an existing SAML provider configuration with the properties provided.
		     *
		     * @param providerId - The provider identifier of the SAML configuration to update.
		     * @param options - The properties to update on the existing configuration.
		     * @returns A promise that resolves with the modified provider
		     *     configuration.
		     */
		    updateInboundSamlConfig(providerId, options) {
		        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
		        }
		        // Construct backend request.
		        let request;
		        try {
		            request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		        const updateMask = utils.generateUpdateMask(request);
		        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId, updateMask: updateMask.join(',') })
		            .then((response) => {
		            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');
		            }
		            return response;
		        });
		    }
		    /**
		     * Invokes the request handler based on the API settings object passed.
		     *
		     * @param urlBuilder - The URL builder for Auth endpoints.
		     * @param apiSettings - The API endpoint settings to apply to request and response.
		     * @param requestData - The request data.
		     * @param additionalResourceParams - Additional resource related params if needed.
		     * @returns A promise that resolves with the response.
		     */
		    invokeRequestHandler(urlBuilder, apiSettings, requestData, additionalResourceParams) {
		        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams)
		            .then((url) => {
		            // Validate request.
		            if (requestData) {
		                const requestValidator = apiSettings.getRequestValidator();
		                requestValidator(requestData);
		            }
		            // Process request.
		            const req = {
		                method: apiSettings.getHttpMethod(),
		                url,
		                headers: FIREBASE_AUTH_HEADERS,
		                data: requestData,
		                timeout: FIREBASE_AUTH_TIMEOUT,
		            };
		            return this.httpClient.send(req);
		        })
		            .then((response) => {
		            // Validate response.
		            const responseValidator = apiSettings.getResponseValidator();
		            responseValidator(response.data);
		            // Return entire response.
		            return response.data;
		        })
		            .catch((err) => {
		            if (err instanceof api_request_1.RequestResponseError) {
		                const error = err.response.data;
		                const errorCode = AbstractAuthRequestHandler.getErrorCode(error);
		                if (!errorCode) {
		                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' +
		                        'internal error occurred while attempting to extract the ' +
		                        'errorcode from the error.');
		                }
		                throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);
		            }
		            throw err;
		        });
		    }
		    /**
		     * @returns The current Auth user management resource URL builder.
		     */
		    getAuthUrlBuilder() {
		        if (!this.authUrlBuilder) {
		            this.authUrlBuilder = this.newAuthUrlBuilder();
		        }
		        return this.authUrlBuilder;
		    }
		    /**
		     * @returns The current project config resource URL builder.
		     */
		    getProjectConfigUrlBuilder() {
		        if (!this.projectConfigUrlBuilder) {
		            this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();
		        }
		        return this.projectConfigUrlBuilder;
		    }
		}
		exports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;
		/** Instantiates the getConfig endpoint settings. */
		const GET_PROJECT_CONFIG = new api_request_1.ApiSettings('/config', 'GET')
		    .setResponseValidator((response) => {
		    // Response should always contain at least the config name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get project config');
		    }
		});
		/** Instantiates the updateConfig endpoint settings. */
		const UPDATE_PROJECT_CONFIG = new api_request_1.ApiSettings('/config?updateMask={updateMask}', 'PATCH')
		    .setResponseValidator((response) => {
		    // Response should always contain at least the config name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update project config');
		    }
		});
		/** Instantiates the getTenant endpoint settings. */
		const GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain at least the tenant name.
		    if (!validator.isNonEmptyString(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');
		    }
		});
		/** Instantiates the deleteTenant endpoint settings. */
		const DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');
		/** Instantiates the updateTenant endpoint settings. */
		const UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain at least the tenant name.
		    if (!validator.isNonEmptyString(response.name) ||
		        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');
		    }
		});
		/** Instantiates the listTenants endpoint settings. */
		const LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')
		    // Set request validator.
		    .setRequestValidator((request) => {
		    // Validate next page token.
		    if (typeof request.pageToken !== 'undefined' &&
		        !validator.isNonEmptyString(request.pageToken)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
		    }
		    // Validate max results.
		    if (!validator.isNumber(request.pageSize) ||
		        request.pageSize <= 0 ||
		        request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required "maxResults" must be a positive non-zero number that does not exceed ' +
		            `the allowed ${MAX_LIST_TENANT_PAGE_SIZE}.`);
		    }
		});
		/** Instantiates the createTenant endpoint settings. */
		const CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')
		    // Set response validator.
		    .setResponseValidator((response) => {
		    // Response should always contain at least the tenant name.
		    if (!validator.isNonEmptyString(response.name) ||
		        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
		        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');
		    }
		});
		/**
		 * Utility for sending requests to Auth server that are Auth instance related. This includes user, tenant,
		 * and project config management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines
		 * additional tenant management related APIs.
		 */
		class AuthRequestHandler extends AbstractAuthRequestHandler {
		    /**
		     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.
		     *
		     * @param app - The app used to fetch access tokens to sign API requests.
		     * @constructor
		     */
		    constructor(app) {
		        super(app);
		        this.authResourceUrlBuilder = new AuthResourceUrlBuilder(app, 'v2');
		    }
		    /**
		     * @returns A new Auth user management resource URL builder instance.
		     */
		    newAuthUrlBuilder() {
		        return new AuthResourceUrlBuilder(this.app, 'v1');
		    }
		    /**
		     * @returns A new project config resource URL builder instance.
		     */
		    newProjectConfigUrlBuilder() {
		        return new AuthResourceUrlBuilder(this.app, 'v2');
		    }
		    /**
		     * Get the current project's config
		     * @returns A promise that resolves with the project config information.
		     */
		    getProjectConfig() {
		        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_PROJECT_CONFIG, {}, {})
		            .then((response) => {
		            return response;
		        });
		    }
		    /**
		     * Update the current project's config.
		     * @returns A promise that resolves with the project config information.
		     */
		    updateProjectConfig(options) {
		        try {
		            const request = project_config_1.ProjectConfig.buildServerRequest(options);
		            const updateMask = utils.generateUpdateMask(request);
		            return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_PROJECT_CONFIG, request, { updateMask: updateMask.join(',') })
		                .then((response) => {
		                return response;
		            });
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		    }
		    /**
		     * Looks up a tenant by tenant ID.
		     *
		     * @param tenantId - The tenant identifier of the tenant to lookup.
		     * @returns A promise that resolves with the tenant information.
		     */
		    getTenant(tenantId) {
		        if (!validator.isNonEmptyString(tenantId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
		        }
		        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_TENANT, {}, { tenantId })
		            .then((response) => {
		            return response;
		        });
		    }
		    /**
		     * Exports the tenants (single batch only) with a size of maxResults and starting from
		     * the offset as specified by pageToken.
		     *
		     * @param maxResults - The page size, 1000 if undefined. This is also the maximum
		     *     allowed limit.
		     * @param pageToken - The next page token. If not specified, returns tenants starting
		     *     without any offset. Tenants are returned in the order they were created from oldest to
		     *     newest, relative to the page token offset.
		     * @returns A promise that resolves with the current batch of downloaded
		     *     tenants and the next page token if available. For the last page, an empty list of tenants
		     *     and no page token are returned.
		     */
		    listTenants(maxResults = MAX_LIST_TENANT_PAGE_SIZE, pageToken) {
		        const request = {
		            pageSize: maxResults,
		            pageToken,
		        };
		        // Remove next page token if not provided.
		        if (typeof request.pageToken === 'undefined') {
		            delete request.pageToken;
		        }
		        return this.invokeRequestHandler(this.authResourceUrlBuilder, LIST_TENANTS, request)
		            .then((response) => {
		            if (!response.tenants) {
		                response.tenants = [];
		                delete response.nextPageToken;
		            }
		            return response;
		        });
		    }
		    /**
		     * Deletes a tenant identified by a tenantId.
		     *
		     * @param tenantId - The identifier of the tenant to delete.
		     * @returns A promise that resolves when the tenant is deleted.
		     */
		    deleteTenant(tenantId) {
		        if (!validator.isNonEmptyString(tenantId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
		        }
		        return this.invokeRequestHandler(this.authResourceUrlBuilder, DELETE_TENANT, undefined, { tenantId })
		            .then(() => {
		            // Return nothing.
		        });
		    }
		    /**
		     * Creates a new tenant with the properties provided.
		     *
		     * @param tenantOptions - The properties to set on the new tenant to be created.
		     * @returns A promise that resolves with the newly created tenant object.
		     */
		    createTenant(tenantOptions) {
		        try {
		            // Construct backend request.
		            const request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);
		            return this.invokeRequestHandler(this.authResourceUrlBuilder, CREATE_TENANT, request)
		                .then((response) => {
		                return response;
		            });
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		    }
		    /**
		     * Updates an existing tenant with the properties provided.
		     *
		     * @param tenantId - The tenant identifier of the tenant to update.
		     * @param tenantOptions - The properties to update on the existing tenant.
		     * @returns A promise that resolves with the modified tenant object.
		     */
		    updateTenant(tenantId, tenantOptions) {
		        if (!validator.isNonEmptyString(tenantId)) {
		            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
		        }
		        try {
		            // Construct backend request.
		            const request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);
		            // Do not traverse deep into testPhoneNumbers. The entire content should be replaced
		            // and not just specific phone numbers.
		            const updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);
		            return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_TENANT, request, { tenantId, updateMask: updateMask.join(',') })
		                .then((response) => {
		                return response;
		            });
		        }
		        catch (e) {
		            return Promise.reject(e);
		        }
		    }
		}
		exports.AuthRequestHandler = AuthRequestHandler;
		/**
		 * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user
		 * management related APIs for specified tenants.
		 * This extends the BaseFirebaseAuthRequestHandler class.
		 */
		class TenantAwareAuthRequestHandler extends AbstractAuthRequestHandler {
		    /**
		     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a
		     * FirebaseApp and a tenant ID.
		     *
		     * @param app - The app used to fetch access tokens to sign API requests.
		     * @param tenantId - The request handler's tenant ID.
		     * @constructor
		     */
		    constructor(app, tenantId) {
		        super(app);
		        this.tenantId = tenantId;
		    }
		    /**
		     * @returns A new Auth user management resource URL builder instance.
		     */
		    newAuthUrlBuilder() {
		        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);
		    }
		    /**
		     * @returns A new project config resource URL builder instance.
		     */
		    newProjectConfigUrlBuilder() {
		        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);
		    }
		    /**
		     * Imports the list of users provided to Firebase Auth. This is useful when
		     * migrating from an external authentication system without having to use the Firebase CLI SDK.
		     * At most, 1000 users are allowed to be imported one at a time.
		     * When importing a list of password users, UserImportOptions are required to be specified.
		     *
		     * Overrides the superclass methods by adding an additional check to match tenant IDs of
		     * imported user records if present.
		     *
		     * @param users - The list of user records to import to Firebase Auth.
		     * @param options - The user import options, required when the users provided
		     *     include password credentials.
		     * @returns A promise that resolves when the operation completes
		     *     with the result of the import. This includes the number of successful imports, the number
		     *     of failed uploads and their corresponding errors.
		     */
		    uploadAccount(users, options) {
		        // Add additional check to match tenant ID of imported user records.
		        users.forEach((user, index) => {
		            if (validator.isNonEmptyString(user.tenantId) &&
		                user.tenantId !== this.tenantId) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index "${index}" has mismatching tenant ID "${user.tenantId}"`);
		            }
		        });
		        return super.uploadAccount(users, options);
		    }
		}
		exports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;
		function emulatorHost() {
		    return process.env.FIREBASE_AUTH_EMULATOR_HOST;
		}
		/**
		 * When true the SDK should communicate with the Auth Emulator for all API
		 * calls and also produce unsigned tokens.
		 */
		function useEmulator() {
		    return !!emulatorHost();
		}
		exports.useEmulator = useEmulator; 
	} (authApiRequest));
	return authApiRequest;
}

var tenantManager = {};

var baseAuth = {};

var tokenGenerator$1 = {};

var cryptoSigner = {};

const require$$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(crypto);

/*! firebase-admin v12.7.0 */

var hasRequiredCryptoSigner;

function requireCryptoSigner () {
	if (hasRequiredCryptoSigner) return cryptoSigner;
	hasRequiredCryptoSigner = 1;
	/*!
	 * @license
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(cryptoSigner, "__esModule", { value: true });
	cryptoSigner.CryptoSignerErrorCode = cryptoSigner.CryptoSignerError = cryptoSigner.cryptoSignerFromApp = cryptoSigner.IAMSigner = cryptoSigner.ServiceAccountSigner = void 0;
	const credential_internal_1 = credentialInternal;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const validator = validator$2;
	const ALGORITHM_RS256 = 'RS256';
	/**
	 * A CryptoSigner implementation that uses an explicitly specified service account private key to
	 * sign data. Performs all operations locally, and does not make any RPC calls.
	 */
	class ServiceAccountSigner {
	    /**
	     * Creates a new CryptoSigner instance from the given service account credential.
	     *
	     * @param credential - A service account credential.
	     */
	    constructor(credential) {
	        this.credential = credential;
	        this.algorithm = ALGORITHM_RS256;
	        if (!credential) {
	            throw new CryptoSignerError({
	                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
	                message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.',
	            });
	        }
	    }
	    /**
	     * @inheritDoc
	     */
	    sign(buffer) {
	        const crypto = require$$3; // eslint-disable-line @typescript-eslint/no-var-requires
	        const sign = crypto.createSign('RSA-SHA256');
	        sign.update(buffer);
	        return Promise.resolve(sign.sign(this.credential.privateKey));
	    }
	    /**
	     * @inheritDoc
	     */
	    getAccountId() {
	        return Promise.resolve(this.credential.clientEmail);
	    }
	}
	cryptoSigner.ServiceAccountSigner = ServiceAccountSigner;
	/**
	 * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without
	 * a service account ID, attempts to discover a service account ID by consulting the local Metadata
	 * service. This will succeed in managed environments like Google Cloud Functions and App Engine.
	 *
	 * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob
	 * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata
	 */
	class IAMSigner {
	    constructor(httpClient, serviceAccountId) {
	        this.algorithm = ALGORITHM_RS256;
	        if (!httpClient) {
	            throw new CryptoSignerError({
	                code: CryptoSignerErrorCode.INVALID_ARGUMENT,
	                message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.',
	            });
	        }
	        if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {
	            throw new CryptoSignerError({
	                code: CryptoSignerErrorCode.INVALID_ARGUMENT,
	                message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.',
	            });
	        }
	        this.httpClient = httpClient;
	        this.serviceAccountId = serviceAccountId;
	    }
	    /**
	     * @inheritDoc
	     */
	    sign(buffer) {
	        return this.getAccountId().then((serviceAccount) => {
	            const request = {
	                method: 'POST',
	                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,
	                data: { payload: buffer.toString('base64') },
	            };
	            return this.httpClient.send(request);
	        }).then((response) => {
	            // Response from IAM is base64 encoded. Decode it into a buffer and return.
	            return Buffer.from(response.data.signedBlob, 'base64');
	        }).catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                throw new CryptoSignerError({
	                    code: CryptoSignerErrorCode.SERVER_ERROR,
	                    message: err.message,
	                    cause: err
	                });
	            }
	            throw err;
	        });
	    }
	    /**
	     * @inheritDoc
	     */
	    getAccountId() {
	        if (validator.isNonEmptyString(this.serviceAccountId)) {
	            return Promise.resolve(this.serviceAccountId);
	        }
	        const request = {
	            method: 'GET',
	            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',
	            headers: {
	                'Metadata-Flavor': 'Google',
	            },
	        };
	        const client = new api_request_1.HttpClient();
	        return client.send(request).then((response) => {
	            if (!response.text) {
	                throw new CryptoSignerError({
	                    code: CryptoSignerErrorCode.INTERNAL_ERROR,
	                    message: 'HTTP Response missing payload',
	                });
	            }
	            this.serviceAccountId = response.text;
	            return response.text;
	        }).catch((err) => {
	            throw new CryptoSignerError({
	                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
	                message: 'Failed to determine service account. Make sure to initialize ' +
	                    'the SDK with a service account credential. Alternatively specify a service ' +
	                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,
	            });
	        });
	    }
	}
	cryptoSigner.IAMSigner = IAMSigner;
	/**
	 * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a
	 * service account credential, creates a ServiceAccountSigner.
	 *
	 * @param app - A FirebaseApp instance.
	 * @returns A CryptoSigner instance.
	 */
	function cryptoSignerFromApp(app) {
	    const credential = app.options.credential;
	    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
	        return new ServiceAccountSigner(credential);
	    }
	    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);
	}
	cryptoSigner.cryptoSignerFromApp = cryptoSignerFromApp;
	/**
	 * CryptoSigner error code structure.
	 *
	 * @param errorInfo - The error information (code and message).
	 * @constructor
	 */
	class CryptoSignerError extends Error {
	    constructor(errorInfo) {
	        super(errorInfo.message);
	        this.errorInfo = errorInfo;
	        /* tslint:disable:max-line-length */
	        // Set the prototype explicitly. See the following link for more details:
	        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
	        /* tslint:enable:max-line-length */
	        this.__proto__ = CryptoSignerError.prototype;
	    }
	    /** @returns The error code. */
	    get code() {
	        return this.errorInfo.code;
	    }
	    /** @returns The error message. */
	    get message() {
	        return this.errorInfo.message;
	    }
	    /** @returns The error data. */
	    get cause() {
	        return this.errorInfo.cause;
	    }
	}
	cryptoSigner.CryptoSignerError = CryptoSignerError;
	/**
	 * Crypto Signer error codes and their default messages.
	 */
	class CryptoSignerErrorCode {
	}
	cryptoSigner.CryptoSignerErrorCode = CryptoSignerErrorCode;
	CryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';
	CryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';
	CryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';
	CryptoSignerErrorCode.SERVER_ERROR = 'server-error';
	return cryptoSigner;
}

/*! firebase-admin v12.7.0 */

var hasRequiredTokenGenerator$1;

function requireTokenGenerator$1 () {
	if (hasRequiredTokenGenerator$1) return tokenGenerator$1;
	hasRequiredTokenGenerator$1 = 1;
	(function (exports) {
		/*!
		 * @license
		 * Copyright 2017 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.handleCryptoSignerError = exports.FirebaseTokenGenerator = exports.EmulatedSigner = exports.BLACKLISTED_CLAIMS = void 0;
		const error_1 = error;
		const crypto_signer_1 = /*@__PURE__*/ requireCryptoSigner();
		const validator = validator$2;
		const utils_1 = utils$1;
		const ALGORITHM_NONE = 'none';
		const ONE_HOUR_IN_SECONDS = 60 * 60;
		// List of blacklisted claims which cannot be provided when creating a custom token
		exports.BLACKLISTED_CLAIMS = [
		    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti',
		    'nbf', 'nonce',
		];
		// Audience to use for Firebase Auth Custom tokens
		const FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';
		/**
		 * A CryptoSigner implementation that is used when communicating with the Auth emulator.
		 * It produces unsigned tokens.
		 */
		class EmulatedSigner {
		    constructor() {
		        this.algorithm = ALGORITHM_NONE;
		    }
		    /**
		     * @inheritDoc
		     */
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    sign(buffer) {
		        return Promise.resolve(Buffer.from(''));
		    }
		    /**
		     * @inheritDoc
		     */
		    getAccountId() {
		        return Promise.resolve('firebase-auth-emulator@example.com');
		    }
		}
		exports.EmulatedSigner = EmulatedSigner;
		/**
		 * Class for generating different types of Firebase Auth tokens (JWTs).
		 *
		 * @internal
		 */
		class FirebaseTokenGenerator {
		    /**
		     * @param tenantId - The tenant ID to use for the generated Firebase Auth
		     *     Custom token. If absent, then no tenant ID claim will be set in the
		     *     resulting JWT.
		     */
		    constructor(signer, tenantId) {
		        this.tenantId = tenantId;
		        if (!validator.isNonNullObject(signer)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.');
		        }
		        if (typeof this.tenantId !== 'undefined' && !validator.isNonEmptyString(this.tenantId)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`tenantId` argument must be a non-empty string.');
		        }
		        this.signer = signer;
		    }
		    /**
		     * Creates a new Firebase Auth Custom token.
		     *
		     * @param uid - The user ID to use for the generated Firebase Auth Custom token.
		     * @param developerClaims - Optional developer claims to include in the generated Firebase
		     *     Auth Custom token.
		     * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a
		     *     service account key and containing the provided payload.
		     */
		    createCustomToken(uid, developerClaims) {
		        let errorMessage;
		        if (!validator.isNonEmptyString(uid)) {
		            errorMessage = '`uid` argument must be a non-empty string uid.';
		        }
		        else if (uid.length > 128) {
		            errorMessage = '`uid` argument must a uid with less than or equal to 128 characters.';
		        }
		        else if (!this.isDeveloperClaimsValid_(developerClaims)) {
		            errorMessage = '`developerClaims` argument must be a valid, non-null object containing the developer claims.';
		        }
		        if (errorMessage) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
		        }
		        const claims = {};
		        if (typeof developerClaims !== 'undefined') {
		            for (const key in developerClaims) {
		                /* istanbul ignore else */
		                if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {
		                    if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {
		                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim "${key}" is reserved and cannot be specified.`);
		                    }
		                    claims[key] = developerClaims[key];
		                }
		            }
		        }
		        return this.signer.getAccountId().then((account) => {
		            const header = {
		                alg: this.signer.algorithm,
		                typ: 'JWT',
		            };
		            const iat = Math.floor(Date.now() / 1000);
		            const body = {
		                aud: FIREBASE_AUDIENCE,
		                iat,
		                exp: iat + ONE_HOUR_IN_SECONDS,
		                iss: account,
		                sub: account,
		                uid,
		            };
		            if (this.tenantId) {
		                body.tenant_id = this.tenantId;
		            }
		            if (Object.keys(claims).length > 0) {
		                body.claims = claims;
		            }
		            const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;
		            const signPromise = this.signer.sign(Buffer.from(token));
		            return Promise.all([token, signPromise]);
		        }).then(([token, signature]) => {
		            return `${token}.${this.encodeSegment(signature)}`;
		        }).catch((err) => {
		            throw handleCryptoSignerError(err);
		        });
		    }
		    encodeSegment(segment) {
		        const buffer = (segment instanceof Buffer) ? segment : Buffer.from(JSON.stringify(segment));
		        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');
		    }
		    /**
		     * Returns whether or not the provided developer claims are valid.
		     *
		     * @param developerClaims - Optional developer claims to validate.
		     * @returns True if the provided claims are valid; otherwise, false.
		     */
		    // eslint-disable-next-line @typescript-eslint/naming-convention
		    isDeveloperClaimsValid_(developerClaims) {
		        if (typeof developerClaims === 'undefined') {
		            return true;
		        }
		        return validator.isNonNullObject(developerClaims);
		    }
		}
		exports.FirebaseTokenGenerator = FirebaseTokenGenerator;
		/**
		 * Creates a new FirebaseAuthError by extracting the error code, message and other relevant
		 * details from a CryptoSignerError.
		 *
		 * @param err - The Error to convert into a FirebaseAuthError error
		 * @returns A Firebase Auth error that can be returned to the user.
		 */
		function handleCryptoSignerError(err) {
		    if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
		        return err;
		    }
		    if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
		        const httpError = err.cause;
		        const errorResponse = httpError.response.data;
		        if (validator.isNonNullObject(errorResponse) && errorResponse.error) {
		            const errorCode = errorResponse.error.status;
		            const description = 'Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens ' +
		                'for more details on how to use and troubleshoot this feature.';
		            const errorMsg = `${errorResponse.error.message}; ${description}`;
		            return error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, errorResponse);
		        }
		        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + errorResponse + '. Additionally, an ' +
		            'internal error occurred while attempting to extract the ' +
		            'errorcode from the error.');
		    }
		    return new error_1.FirebaseAuthError(mapToAuthClientErrorCode(err.code), err.message);
		}
		exports.handleCryptoSignerError = handleCryptoSignerError;
		function mapToAuthClientErrorCode(code) {
		    switch (code) {
		        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:
		            return error_1.AuthClientErrorCode.INVALID_CREDENTIAL;
		        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:
		            return error_1.AuthClientErrorCode.INVALID_ARGUMENT;
		        default:
		            return error_1.AuthClientErrorCode.INTERNAL_ERROR;
		    }
		} 
	} (tokenGenerator$1));
	return tokenGenerator$1;
}

var tokenVerifier$1 = {};

var jwt = {};

const require$$2$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(jwksRsa);

/*! firebase-admin v12.7.0 */

var hasRequiredJwt;

function requireJwt () {
	if (hasRequiredJwt) return jwt;
	hasRequiredJwt = 1;
	(function (exports) {
		/*!
		 * Copyright 2021 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;
		const validator = validator$2;
		const jwt = require$$1$2;
		const jwks = require$$2$1;
		const api_request_1 = /*@__PURE__*/ requireApiRequest();
		exports.ALGORITHM_RS256 = 'RS256';
		// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type
		// and prefixes the error message with the following. Use the prefix to identify errors thrown
		// from the key provider callback.
		// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96
		const JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';
		const NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';
		const NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';
		const HOUR_IN_SECONDS = 3600;
		class JwksFetcher {
		    constructor(jwksUrl, httpAgent) {
		        this.publicKeysExpireAt = 0;
		        if (!validator.isURL(jwksUrl)) {
		            throw new Error('The provided JWKS URL is not a valid URL.');
		        }
		        this.client = jwks({
		            jwksUri: jwksUrl,
		            cache: false,
		            requestAgent: httpAgent,
		        });
		    }
		    fetchPublicKeys() {
		        if (this.shouldRefresh()) {
		            return this.refresh();
		        }
		        return Promise.resolve(this.publicKeys);
		    }
		    shouldRefresh() {
		        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
		    }
		    refresh() {
		        return this.client.getSigningKeys()
		            .then((signingKeys) => {
		            // reset expire at from previous set of keys.
		            this.publicKeysExpireAt = 0;
		            const newKeys = signingKeys.reduce((map, signingKey) => {
		                map[signingKey.kid] = signingKey.getPublicKey();
		                return map;
		            }, {});
		            this.publicKeysExpireAt = Date.now() + (HOUR_IN_SECONDS * 6 * 1000);
		            this.publicKeys = newKeys;
		            return newKeys;
		        }).catch((err) => {
		            throw new Error(`Error fetching Json Web Keys: ${err.message}`);
		        });
		    }
		}
		exports.JwksFetcher = JwksFetcher;
		/**
		 * Class to fetch public keys from a client certificates URL.
		 */
		class UrlKeyFetcher {
		    constructor(clientCertUrl, httpAgent) {
		        this.clientCertUrl = clientCertUrl;
		        this.httpAgent = httpAgent;
		        this.publicKeysExpireAt = 0;
		        if (!validator.isURL(clientCertUrl)) {
		            throw new Error('The provided public client certificate URL is not a valid URL.');
		        }
		    }
		    /**
		     * Fetches the public keys for the Google certs.
		     *
		     * @returns A promise fulfilled with public keys for the Google certs.
		     */
		    fetchPublicKeys() {
		        if (this.shouldRefresh()) {
		            return this.refresh();
		        }
		        return Promise.resolve(this.publicKeys);
		    }
		    /**
		     * Checks if the cached public keys need to be refreshed.
		     *
		     * @returns Whether the keys should be fetched from the client certs url or not.
		     */
		    shouldRefresh() {
		        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
		    }
		    refresh() {
		        const client = new api_request_1.HttpClient();
		        const request = {
		            method: 'GET',
		            url: this.clientCertUrl,
		            httpAgent: this.httpAgent,
		        };
		        return client.send(request).then((resp) => {
		            if (!resp.isJson() || resp.data.error) {
		                // Treat all non-json messages and messages with an 'error' field as
		                // error responses.
		                throw new api_request_1.RequestResponseError(resp);
		            }
		            // reset expire at from previous set of keys.
		            this.publicKeysExpireAt = 0;
		            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {
		                const cacheControlHeader = resp.headers['cache-control'];
		                const parts = cacheControlHeader.split(',');
		                parts.forEach((part) => {
		                    const subParts = part.trim().split('=');
		                    if (subParts[0] === 'max-age') {
		                        const maxAge = +subParts[1];
		                        this.publicKeysExpireAt = Date.now() + (maxAge * 1000);
		                    }
		                });
		            }
		            this.publicKeys = resp.data;
		            return resp.data;
		        }).catch((err) => {
		            if (err instanceof api_request_1.RequestResponseError) {
		                let errorMessage = 'Error fetching public keys for Google certs: ';
		                const resp = err.response;
		                if (resp.isJson() && resp.data.error) {
		                    errorMessage += `${resp.data.error}`;
		                    if (resp.data.error_description) {
		                        errorMessage += ' (' + resp.data.error_description + ')';
		                    }
		                }
		                else {
		                    errorMessage += `${resp.text}`;
		                }
		                throw new Error(errorMessage);
		            }
		            throw err;
		        });
		    }
		}
		exports.UrlKeyFetcher = UrlKeyFetcher;
		/**
		 * Class for verifying JWT signature with a public key.
		 */
		class PublicKeySignatureVerifier {
		    constructor(keyFetcher) {
		        this.keyFetcher = keyFetcher;
		        if (!validator.isNonNullObject(keyFetcher)) {
		            throw new Error('The provided key fetcher is not an object or null.');
		        }
		    }
		    static withCertificateUrl(clientCertUrl, httpAgent) {
		        return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));
		    }
		    static withJwksUrl(jwksUrl, httpAgent) {
		        return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl, httpAgent));
		    }
		    verify(token) {
		        if (!validator.isString(token)) {
		            return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
		        }
		        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), { algorithms: [exports.ALGORITHM_RS256] })
		            .catch((error) => {
		            if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {
		                // No kid in JWT header. Try with all the public keys.
		                return this.verifyWithoutKid(token);
		            }
		            throw error;
		        });
		    }
		    verifyWithoutKid(token) {
		        return this.keyFetcher.fetchPublicKeys()
		            .then(publicKeys => this.verifyWithAllKeys(token, publicKeys));
		    }
		    verifyWithAllKeys(token, keys) {
		        const promises = [];
		        Object.values(keys).forEach((key) => {
		            const result = verifyJwtSignature(token, key)
		                .then(() => true)
		                .catch((error) => {
		                if (error.code === JwtErrorCode.TOKEN_EXPIRED) {
		                    throw error;
		                }
		                return false;
		            });
		            promises.push(result);
		        });
		        return Promise.all(promises)
		            .then((result) => {
		            if (result.every((r) => r === false)) {
		                throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');
		            }
		        });
		    }
		}
		exports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;
		/**
		 * Class for verifying unsigned (emulator) JWTs.
		 */
		class EmulatorSignatureVerifier {
		    verify(token) {
		        // Signature checks skipped for emulator; no need to fetch public keys.
		        return verifyJwtSignature(token, undefined, { algorithms: ['none'] });
		    }
		}
		exports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;
		/**
		 * Provides a callback to fetch public keys.
		 *
		 * @param fetcher - KeyFetcher to fetch the keys from.
		 * @returns A callback function that can be used to get keys in `jsonwebtoken`.
		 */
		function getKeyCallback(fetcher) {
		    return (header, callback) => {
		        if (!header.kid) {
		            callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));
		        }
		        const kid = header.kid || '';
		        fetcher.fetchPublicKeys().then((publicKeys) => {
		            if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {
		                callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));
		            }
		            else {
		                callback(null, publicKeys[kid]);
		            }
		        })
		            .catch(error => {
		            callback(error);
		        });
		    };
		}
		/**
		 * Verifies the signature of a JWT using the provided secret or a function to fetch
		 * the secret or public key.
		 *
		 * @param token - The JWT to be verified.
		 * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.
		 * @param options - JWT verification options.
		 * @returns A Promise resolving for a token with a valid signature.
		 */
		function verifyJwtSignature(token, secretOrPublicKey, options) {
		    if (!validator.isString(token)) {
		        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
		    }
		    return new Promise((resolve, reject) => {
		        jwt.verify(token, secretOrPublicKey, options, (error) => {
		            if (!error) {
		                return resolve();
		            }
		            if (error.name === 'TokenExpiredError') {
		                return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' +
		                    'client app and try again.'));
		            }
		            else if (error.name === 'JsonWebTokenError') {
		                if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {
		                    const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';
		                    let code = JwtErrorCode.KEY_FETCH_ERROR;
		                    if (message === NO_MATCHING_KID_ERROR_MESSAGE) {
		                        code = JwtErrorCode.NO_MATCHING_KID;
		                    }
		                    else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {
		                        code = JwtErrorCode.NO_KID_IN_HEADER;
		                    }
		                    return reject(new JwtError(code, message));
		                }
		            }
		            return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));
		        });
		    });
		}
		exports.verifyJwtSignature = verifyJwtSignature;
		/**
		 * Decodes general purpose Firebase JWTs.
		 *
		 * @param jwtToken - JWT token to be decoded.
		 * @returns Decoded token containing the header and payload.
		 */
		function decodeJwt(jwtToken) {
		    if (!validator.isString(jwtToken)) {
		        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
		    }
		    const fullDecodedToken = jwt.decode(jwtToken, {
		        complete: true,
		    });
		    if (!fullDecodedToken) {
		        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));
		    }
		    const header = fullDecodedToken?.header;
		    const payload = fullDecodedToken?.payload;
		    return Promise.resolve({ header, payload });
		}
		exports.decodeJwt = decodeJwt;
		/**
		 * Jwt error code structure.
		 *
		 * @param code - The error code.
		 * @param message - The error message.
		 * @constructor
		 */
		class JwtError extends Error {
		    constructor(code, message) {
		        super(message);
		        this.code = code;
		        this.message = message;
		        this.__proto__ = JwtError.prototype;
		    }
		}
		exports.JwtError = JwtError;
		/**
		 * JWT error codes.
		 */
		var JwtErrorCode;
		(function (JwtErrorCode) {
		    JwtErrorCode["INVALID_ARGUMENT"] = "invalid-argument";
		    JwtErrorCode["INVALID_CREDENTIAL"] = "invalid-credential";
		    JwtErrorCode["TOKEN_EXPIRED"] = "token-expired";
		    JwtErrorCode["INVALID_SIGNATURE"] = "invalid-token";
		    JwtErrorCode["NO_MATCHING_KID"] = "no-matching-kid-error";
		    JwtErrorCode["NO_KID_IN_HEADER"] = "no-kid-error";
		    JwtErrorCode["KEY_FETCH_ERROR"] = "key-fetch-error";
		})(JwtErrorCode || (exports.JwtErrorCode = JwtErrorCode = {})); 
	} (jwt));
	return jwt;
}

/*! firebase-admin v12.7.0 */

var hasRequiredTokenVerifier$1;

function requireTokenVerifier$1 () {
	if (hasRequiredTokenVerifier$1) return tokenVerifier$1;
	hasRequiredTokenVerifier$1 = 1;
	(function (exports) {
		/*!
		 * Copyright 2018 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createSessionCookieVerifier = exports.createAuthBlockingTokenVerifier = exports.createIdTokenVerifier = exports.FirebaseTokenVerifier = exports.SESSION_COOKIE_INFO = exports.AUTH_BLOCKING_TOKEN_INFO = exports.ID_TOKEN_INFO = void 0;
		const error_1 = error;
		const util = utils$1;
		const validator = validator$2;
		const jwt_1 = /*@__PURE__*/ requireJwt();
		// Audience to use for Firebase Auth Custom tokens
		const FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';
		// URL containing the public keys for the Google certs (whose private keys are used to sign Firebase
		// Auth ID tokens)
		const CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com';
		// URL containing the public keys for Firebase session cookies. This will be updated to a different URL soon.
		const SESSION_COOKIE_CERT_URL = 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys';
		const EMULATOR_VERIFIER = new jwt_1.EmulatorSignatureVerifier();
		/**
		 * User facing token information related to the Firebase ID token.
		 *
		 * @internal
		 */
		exports.ID_TOKEN_INFO = {
		    url: 'https://firebase.google.com/docs/auth/admin/verify-id-tokens',
		    verifyApiName: 'verifyIdToken()',
		    jwtName: 'Firebase ID token',
		    shortName: 'ID token',
		    expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED,
		};
		/**
		 * User facing token information related to the Firebase Auth Blocking token.
		 *
		 * @internal
		 */
		exports.AUTH_BLOCKING_TOKEN_INFO = {
		    url: 'https://cloud.google.com/identity-platform/docs/blocking-functions',
		    verifyApiName: '_verifyAuthBlockingToken()',
		    jwtName: 'Firebase Auth Blocking token',
		    shortName: 'Auth Blocking token',
		    expiredErrorCode: error_1.AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED,
		};
		/**
		 * User facing token information related to the Firebase session cookie.
		 *
		 * @internal
		 */
		exports.SESSION_COOKIE_INFO = {
		    url: 'https://firebase.google.com/docs/auth/admin/manage-cookies',
		    verifyApiName: 'verifySessionCookie()',
		    jwtName: 'Firebase session cookie',
		    shortName: 'session cookie',
		    expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED,
		};
		/**
		 * Class for verifying general purpose Firebase JWTs. This verifies ID tokens and session cookies.
		 *
		 * @internal
		 */
		class FirebaseTokenVerifier {
		    constructor(clientCertUrl, issuer, tokenInfo, app) {
		        this.issuer = issuer;
		        this.tokenInfo = tokenInfo;
		        this.app = app;
		        if (!validator.isURL(clientCertUrl)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided public client certificate URL is an invalid URL.');
		        }
		        else if (!validator.isURL(issuer)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT issuer is an invalid URL.');
		        }
		        else if (!validator.isNonNullObject(tokenInfo)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT information is not an object or null.');
		        }
		        else if (!validator.isURL(tokenInfo.url)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT verification documentation URL is invalid.');
		        }
		        else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT verify API name must be a non-empty string.');
		        }
		        else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public full name must be a non-empty string.');
		        }
		        else if (!validator.isNonEmptyString(tokenInfo.shortName)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public short name must be a non-empty string.');
		        }
		        else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !('code' in tokenInfo.expiredErrorCode)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT expiration error code must be a non-null ErrorInfo object.');
		        }
		        this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? 'an' : 'a';
		        this.signatureVerifier =
		            jwt_1.PublicKeySignatureVerifier.withCertificateUrl(clientCertUrl, app.options.httpAgent);
		        // For backward compatibility, the project ID is validated in the verification call.
		    }
		    /**
		     * Verifies the format and signature of a Firebase Auth JWT token.
		     *
		     * @param jwtToken - The Firebase Auth JWT token to verify.
		     * @param isEmulator - Whether to accept Auth Emulator tokens.
		     * @returns A promise fulfilled with the decoded claims of the Firebase Auth ID token.
		     */
		    verifyJWT(jwtToken, isEmulator = false) {
		        if (!validator.isString(jwtToken)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
		        }
		        return this.ensureProjectId()
		            .then((projectId) => {
		            return this.decodeAndVerify(jwtToken, projectId, isEmulator);
		        })
		            .then((decoded) => {
		            const decodedIdToken = decoded.payload;
		            decodedIdToken.uid = decodedIdToken.sub;
		            return decodedIdToken;
		        });
		    }
		    /** @alpha */
		    // eslint-disable-next-line @typescript-eslint/naming-convention
		    _verifyAuthBlockingToken(jwtToken, isEmulator, audience) {
		        if (!validator.isString(jwtToken)) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
		        }
		        return this.ensureProjectId()
		            .then((projectId) => {
		            if (typeof audience === 'undefined') {
		                audience = `${projectId}.cloudfunctions.net/`;
		            }
		            return this.decodeAndVerify(jwtToken, projectId, isEmulator, audience);
		        })
		            .then((decoded) => {
		            const decodedAuthBlockingToken = decoded.payload;
		            decodedAuthBlockingToken.uid = decodedAuthBlockingToken.sub;
		            return decodedAuthBlockingToken;
		        });
		    }
		    ensureProjectId() {
		        return util.findProjectId(this.app)
		            .then((projectId) => {
		            if (!validator.isNonEmptyString(projectId)) {
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Must initialize app with a cert credential or set your Firebase project ID as the ' +
		                    `GOOGLE_CLOUD_PROJECT environment variable to call ${this.tokenInfo.verifyApiName}.`);
		            }
		            return Promise.resolve(projectId);
		        });
		    }
		    decodeAndVerify(token, projectId, isEmulator, audience) {
		        return this.safeDecode(token)
		            .then((decodedToken) => {
		            this.verifyContent(decodedToken, projectId, isEmulator, audience);
		            return this.verifySignature(token, isEmulator)
		                .then(() => decodedToken);
		        });
		    }
		    safeDecode(jwtToken) {
		        return (0, jwt_1.decodeJwt)(jwtToken)
		            .catch((err) => {
		            if (err.code === jwt_1.JwtErrorCode.INVALID_ARGUMENT) {
		                const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} ` +
		                    `for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
		                const errorMessage = `Decoding ${this.tokenInfo.jwtName} failed. Make sure you passed ` +
		                    `the entire string JWT which represents ${this.shortNameArticle} ` +
		                    `${this.tokenInfo.shortName}.` + verifyJwtTokenDocsMessage;
		                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
		            }
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, err.message);
		        });
		    }
		    /**
		     * Verifies the content of a Firebase Auth JWT.
		     *
		     * @param fullDecodedToken - The decoded JWT.
		     * @param projectId - The Firebase Project Id.
		     * @param isEmulator - Whether the token is an Emulator token.
		     */
		    verifyContent(fullDecodedToken, projectId, isEmulator, audience) {
		        const header = fullDecodedToken && fullDecodedToken.header;
		        const payload = fullDecodedToken && fullDecodedToken.payload;
		        const projectIdMatchMessage = ` Make sure the ${this.tokenInfo.shortName} comes from the same ` +
		            'Firebase project as the service account used to authenticate this SDK.';
		        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} ` +
		            `for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
		        let errorMessage;
		        if (!isEmulator && typeof header.kid === 'undefined') {
		            const isCustomToken = (payload.aud === FIREBASE_AUDIENCE);
		            const isLegacyCustomToken = (header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d);
		            if (isCustomToken) {
		                errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ` +
		                    `${this.tokenInfo.shortName}, but was given a custom token.`;
		            }
		            else if (isLegacyCustomToken) {
		                errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ` +
		                    `${this.tokenInfo.shortName}, but was given a legacy custom token.`;
		            }
		            else {
		                errorMessage = `${this.tokenInfo.jwtName} has no "kid" claim.`;
		            }
		            errorMessage += verifyJwtTokenDocsMessage;
		        }
		        else if (!isEmulator && header.alg !== jwt_1.ALGORITHM_RS256) {
		            errorMessage = `${this.tokenInfo.jwtName} has incorrect algorithm. Expected "` + jwt_1.ALGORITHM_RS256 + '" but got ' +
		                '"' + header.alg + '".' + verifyJwtTokenDocsMessage;
		        }
		        else if (typeof audience !== 'undefined' && !payload.aud.includes(audience)) {
		            errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` +
		                audience + '" but got "' + payload.aud + '".' + verifyJwtTokenDocsMessage;
		        }
		        else if (typeof audience === 'undefined' && payload.aud !== projectId) {
		            errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` +
		                projectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage +
		                verifyJwtTokenDocsMessage;
		        }
		        else if (payload.iss !== this.issuer + projectId) {
		            errorMessage = `${this.tokenInfo.jwtName} has incorrect "iss" (issuer) claim. Expected ` +
		                `"${this.issuer}` + projectId + '" but got "' +
		                payload.iss + '".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;
		        }
		        else if (!(payload.event_type !== undefined &&
		            (payload.event_type === 'beforeSendSms' || payload.event_type === 'beforeSendEmail'))) {
		            // excluding `beforeSendSms` and `beforeSendEmail` from processing `sub` as there is no user record available.
		            // `sub` is the same as `uid` which is part of the user record.
		            if (typeof payload.sub !== 'string') {
		                errorMessage = `${this.tokenInfo.jwtName} has no "sub" (subject) claim.` + verifyJwtTokenDocsMessage;
		            }
		            else if (payload.sub === '') {
		                errorMessage = `${this.tokenInfo.jwtName} has an empty "sub" (subject) claim.` +
		                    verifyJwtTokenDocsMessage;
		            }
		            else if (payload.sub.length > 128) {
		                errorMessage = `${this.tokenInfo.jwtName} has a "sub" (subject) claim longer than 128 characters.` +
		                    verifyJwtTokenDocsMessage;
		            }
		        }
		        if (errorMessage) {
		            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
		        }
		    }
		    verifySignature(jwtToken, isEmulator) {
		        const verifier = isEmulator ? EMULATOR_VERIFIER : this.signatureVerifier;
		        return verifier.verify(jwtToken)
		            .catch((error) => {
		            throw this.mapJwtErrorToAuthError(error);
		        });
		    }
		    /**
		     * Maps JwtError to FirebaseAuthError
		     *
		     * @param error - JwtError to be mapped.
		     * @returns FirebaseAuthError or Error instance.
		     */
		    mapJwtErrorToAuthError(error) {
		        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} ` +
		            `for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
		        if (error.code === jwt_1.JwtErrorCode.TOKEN_EXPIRED) {
		            const errorMessage = `${this.tokenInfo.jwtName} has expired. Get a fresh ${this.tokenInfo.shortName}` +
		                ` from your client app and try again (auth/${this.tokenInfo.expiredErrorCode.code}).` +
		                verifyJwtTokenDocsMessage;
		            return new error_1.FirebaseAuthError(this.tokenInfo.expiredErrorCode, errorMessage);
		        }
		        else if (error.code === jwt_1.JwtErrorCode.INVALID_SIGNATURE) {
		            const errorMessage = `${this.tokenInfo.jwtName} has invalid signature.` + verifyJwtTokenDocsMessage;
		            return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
		        }
		        else if (error.code === jwt_1.JwtErrorCode.NO_MATCHING_KID) {
		            const errorMessage = `${this.tokenInfo.jwtName} has "kid" claim which does not ` +
		                `correspond to a known public key. Most likely the ${this.tokenInfo.shortName} ` +
		                'is expired, so get a fresh token from your client app and try again.';
		            return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
		        }
		        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message);
		    }
		}
		exports.FirebaseTokenVerifier = FirebaseTokenVerifier;
		/**
		 * Creates a new FirebaseTokenVerifier to verify Firebase ID tokens.
		 *
		 * @internal
		 * @param app - Firebase app instance.
		 * @returns FirebaseTokenVerifier
		 */
		function createIdTokenVerifier(app) {
		    return new FirebaseTokenVerifier(CLIENT_CERT_URL, 'https://securetoken.google.com/', exports.ID_TOKEN_INFO, app);
		}
		exports.createIdTokenVerifier = createIdTokenVerifier;
		/**
		 * Creates a new FirebaseTokenVerifier to verify Firebase Auth Blocking tokens.
		 *
		 * @internal
		 * @param app - Firebase app instance.
		 * @returns FirebaseTokenVerifier
		 */
		function createAuthBlockingTokenVerifier(app) {
		    return new FirebaseTokenVerifier(CLIENT_CERT_URL, 'https://securetoken.google.com/', exports.AUTH_BLOCKING_TOKEN_INFO, app);
		}
		exports.createAuthBlockingTokenVerifier = createAuthBlockingTokenVerifier;
		/**
		 * Creates a new FirebaseTokenVerifier to verify Firebase session cookies.
		 *
		 * @internal
		 * @param app - Firebase app instance.
		 * @returns FirebaseTokenVerifier
		 */
		function createSessionCookieVerifier(app) {
		    return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, 'https://session.firebase.google.com/', exports.SESSION_COOKIE_INFO, app);
		}
		exports.createSessionCookieVerifier = createSessionCookieVerifier; 
	} (tokenVerifier$1));
	return tokenVerifier$1;
}

var userRecord = {};

/*! firebase-admin v12.7.0 */

var hasRequiredUserRecord;

function requireUserRecord () {
	if (hasRequiredUserRecord) return userRecord;
	hasRequiredUserRecord = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(userRecord, "__esModule", { value: true });
	userRecord.UserRecord = userRecord.UserInfo = userRecord.UserMetadata = userRecord.MultiFactorSettings = userRecord.TotpMultiFactorInfo = userRecord.TotpInfo = userRecord.PhoneMultiFactorInfo = userRecord.MultiFactorInfo = void 0;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const validator_1 = validator$2;
	const utils = utils$1;
	const error_1 = error;
	/**
	 * 'REDACTED', encoded as a base64 string.
	 */
	const B64_REDACTED = Buffer.from('REDACTED').toString('base64');
	/**
	 * Parses a time stamp string or number and returns the corresponding date if valid.
	 *
	 * @param time - The unix timestamp string or number in milliseconds.
	 * @returns The corresponding date as a UTC string, if valid. Otherwise, null.
	 */
	function parseDate(time) {
	    try {
	        const date = new Date(parseInt(time, 10));
	        if (!isNaN(date.getTime())) {
	            return date.toUTCString();
	        }
	    }
	    catch (e) {
	        // Do nothing. null will be returned.
	    }
	    return null;
	}
	var MultiFactorId;
	(function (MultiFactorId) {
	    MultiFactorId["Phone"] = "phone";
	    MultiFactorId["Totp"] = "totp";
	})(MultiFactorId || (MultiFactorId = {}));
	/**
	 * Interface representing the common properties of a user-enrolled second factor.
	 */
	class MultiFactorInfo {
	    /**
	     * Initializes the MultiFactorInfo associated subclass using the server side.
	     * If no MultiFactorInfo is associated with the response, null is returned.
	     *
	     * @param response - The server side response.
	     * @internal
	     */
	    static initMultiFactorInfo(response) {
	        let multiFactorInfo = null;
	        // PhoneMultiFactorInfo, TotpMultiFactorInfo currently available.
	        try {
	            if (response.phoneInfo !== undefined) {
	                multiFactorInfo = new PhoneMultiFactorInfo(response);
	            }
	            else if (response.totpInfo !== undefined) {
	                multiFactorInfo = new TotpMultiFactorInfo(response);
	            }
	            else {
	                // Ignore the other SDK unsupported MFA factors to prevent blocking developers using the current SDK.
	            }
	        }
	        catch (e) {
	            // Ignore error.
	        }
	        return multiFactorInfo;
	    }
	    /**
	     * Initializes the MultiFactorInfo object using the server side response.
	     *
	     * @param response - The server side response.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        this.initFromServerResponse(response);
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        return {
	            uid: this.uid,
	            displayName: this.displayName,
	            factorId: this.factorId,
	            enrollmentTime: this.enrollmentTime,
	        };
	    }
	    /**
	     * Initializes the MultiFactorInfo object using the provided server response.
	     *
	     * @param response - The server side response.
	     */
	    initFromServerResponse(response) {
	        const factorId = response && this.getFactorId(response);
	        if (!factorId || !response || !response.mfaEnrollmentId) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');
	        }
	        utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);
	        utils.addReadonlyGetter(this, 'factorId', factorId);
	        utils.addReadonlyGetter(this, 'displayName', response.displayName);
	        // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
	        // For example, "2017-01-15T01:30:15.01Z".
	        // This can be parsed directly via Date constructor.
	        // This can be computed using Data.prototype.toISOString.
	        if (response.enrolledAt) {
	            utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());
	        }
	        else {
	            utils.addReadonlyGetter(this, 'enrollmentTime', null);
	        }
	    }
	}
	userRecord.MultiFactorInfo = MultiFactorInfo;
	/**
	 * Interface representing a phone specific user-enrolled second factor.
	 */
	class PhoneMultiFactorInfo extends MultiFactorInfo {
	    /**
	     * Initializes the PhoneMultiFactorInfo object using the server side response.
	     *
	     * @param response - The server side response.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        super(response);
	        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);
	    }
	    /**
	     * {@inheritdoc MultiFactorInfo.toJSON}
	     */
	    toJSON() {
	        return Object.assign(super.toJSON(), {
	            phoneNumber: this.phoneNumber,
	        });
	    }
	    /**
	     * Returns the factor ID based on the response provided.
	     *
	     * @param response - The server side response.
	     * @returns The multi-factor ID associated with the provided response. If the response is
	     *     not associated with any known multi-factor ID, null is returned.
	     *
	     * @internal
	     */
	    getFactorId(response) {
	        return (response && response.phoneInfo) ? MultiFactorId.Phone : null;
	    }
	}
	userRecord.PhoneMultiFactorInfo = PhoneMultiFactorInfo;
	/**
	 * `TotpInfo` struct associated with a second factor
	 */
	class TotpInfo {
	}
	userRecord.TotpInfo = TotpInfo;
	/**
	 * Interface representing a TOTP specific user-enrolled second factor.
	 */
	class TotpMultiFactorInfo extends MultiFactorInfo {
	    /**
	     * Initializes the `TotpMultiFactorInfo` object using the server side response.
	     *
	     * @param response - The server side response.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        super(response);
	        utils.addReadonlyGetter(this, 'totpInfo', response.totpInfo);
	    }
	    /**
	     * {@inheritdoc MultiFactorInfo.toJSON}
	     */
	    toJSON() {
	        return Object.assign(super.toJSON(), {
	            totpInfo: this.totpInfo,
	        });
	    }
	    /**
	     * Returns the factor ID based on the response provided.
	     *
	     * @param response - The server side response.
	     * @returns The multi-factor ID associated with the provided response. If the response is
	     *     not associated with any known multi-factor ID, `null` is returned.
	     *
	     * @internal
	     */
	    getFactorId(response) {
	        return (response && response.totpInfo) ? MultiFactorId.Totp : null;
	    }
	}
	userRecord.TotpMultiFactorInfo = TotpMultiFactorInfo;
	/**
	 * The multi-factor related user settings.
	 */
	class MultiFactorSettings {
	    /**
	     * Initializes the `MultiFactor` object using the server side or JWT format response.
	     *
	     * @param response - The server side response.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        const parsedEnrolledFactors = [];
	        if (!(0, validator_1.isNonNullObject)(response)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');
	        }
	        else if (response.mfaInfo) {
	            response.mfaInfo.forEach((factorResponse) => {
	                const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);
	                if (multiFactorInfo) {
	                    parsedEnrolledFactors.push(multiFactorInfo);
	                }
	            });
	        }
	        // Make enrolled factors immutable.
	        utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));
	    }
	    /**
	     * Returns a JSON-serializable representation of this multi-factor object.
	     *
	     * @returns A JSON-serializable representation of this multi-factor object.
	     */
	    toJSON() {
	        return {
	            enrolledFactors: this.enrolledFactors.map((info) => info.toJSON()),
	        };
	    }
	}
	userRecord.MultiFactorSettings = MultiFactorSettings;
	/**
	 * Represents a user's metadata.
	 */
	class UserMetadata {
	    /**
	     * @param response - The server side response returned from the `getAccountInfo`
	     *     endpoint.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        // Creation date should always be available but due to some backend bugs there
	        // were cases in the past where users did not have creation date properly set.
	        // This included legacy Firebase migrating project users and some anonymous users.
	        // These bugs have already been addressed since then.
	        utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));
	        utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));
	        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;
	        utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        return {
	            lastSignInTime: this.lastSignInTime,
	            creationTime: this.creationTime,
	            lastRefreshTime: this.lastRefreshTime,
	        };
	    }
	}
	userRecord.UserMetadata = UserMetadata;
	/**
	 * Represents a user's info from a third-party identity provider
	 * such as Google or Facebook.
	 */
	class UserInfo {
	    /**
	     * @param response - The server side response returned from the `getAccountInfo`
	     *     endpoint.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        // Provider user id and provider id are required.
	        if (!response.rawId || !response.providerId) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');
	        }
	        utils.addReadonlyGetter(this, 'uid', response.rawId);
	        utils.addReadonlyGetter(this, 'displayName', response.displayName);
	        utils.addReadonlyGetter(this, 'email', response.email);
	        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);
	        utils.addReadonlyGetter(this, 'providerId', response.providerId);
	        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        return {
	            uid: this.uid,
	            displayName: this.displayName,
	            email: this.email,
	            photoURL: this.photoURL,
	            providerId: this.providerId,
	            phoneNumber: this.phoneNumber,
	        };
	    }
	}
	userRecord.UserInfo = UserInfo;
	/**
	 * Represents a user.
	 */
	class UserRecord {
	    /**
	     * @param response - The server side response returned from the getAccountInfo
	     *     endpoint.
	     * @constructor
	     * @internal
	     */
	    constructor(response) {
	        // The Firebase user id is required.
	        if (!response.localId) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');
	        }
	        utils.addReadonlyGetter(this, 'uid', response.localId);
	        utils.addReadonlyGetter(this, 'email', response.email);
	        utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);
	        utils.addReadonlyGetter(this, 'displayName', response.displayName);
	        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);
	        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);
	        // If disabled is not provided, the account is enabled by default.
	        utils.addReadonlyGetter(this, 'disabled', response.disabled || false);
	        utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));
	        const providerData = [];
	        for (const entry of (response.providerUserInfo || [])) {
	            providerData.push(new UserInfo(entry));
	        }
	        utils.addReadonlyGetter(this, 'providerData', providerData);
	        // If the password hash is redacted (probably due to missing permissions)
	        // then clear it out, similar to how the salt is returned. (Otherwise, it
	        // *looks* like a b64-encoded hash is present, which is confusing.)
	        if (response.passwordHash === B64_REDACTED) {
	            utils.addReadonlyGetter(this, 'passwordHash', undefined);
	        }
	        else {
	            utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);
	        }
	        utils.addReadonlyGetter(this, 'passwordSalt', response.salt);
	        if (response.customAttributes) {
	            utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));
	        }
	        let validAfterTime = null;
	        // Convert validSince first to UTC milliseconds and then to UTC date string.
	        if (typeof response.validSince !== 'undefined') {
	            validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);
	        }
	        utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);
	        utils.addReadonlyGetter(this, 'tenantId', response.tenantId);
	        const multiFactor = new MultiFactorSettings(response);
	        if (multiFactor.enrolledFactors.length > 0) {
	            utils.addReadonlyGetter(this, 'multiFactor', multiFactor);
	        }
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        const json = {
	            uid: this.uid,
	            email: this.email,
	            emailVerified: this.emailVerified,
	            displayName: this.displayName,
	            photoURL: this.photoURL,
	            phoneNumber: this.phoneNumber,
	            disabled: this.disabled,
	            // Convert metadata to json.
	            metadata: this.metadata.toJSON(),
	            passwordHash: this.passwordHash,
	            passwordSalt: this.passwordSalt,
	            customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),
	            tokensValidAfterTime: this.tokensValidAfterTime,
	            tenantId: this.tenantId,
	        };
	        if (this.multiFactor) {
	            json.multiFactor = this.multiFactor.toJSON();
	        }
	        json.providerData = [];
	        for (const entry of this.providerData) {
	            // Convert each provider data to json.
	            json.providerData.push(entry.toJSON());
	        }
	        return json;
	    }
	}
	userRecord.UserRecord = UserRecord;
	return userRecord;
}

/*! firebase-admin v12.7.0 */

var hasRequiredBaseAuth;

function requireBaseAuth () {
	if (hasRequiredBaseAuth) return baseAuth;
	hasRequiredBaseAuth = 1;
	/*!
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(baseAuth, "__esModule", { value: true });
	baseAuth.BaseAuth = baseAuth.createFirebaseTokenGenerator = void 0;
	const error_1 = error;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const validator = validator$2;
	const auth_api_request_1 = /*@__PURE__*/ requireAuthApiRequest();
	const token_generator_1 = /*@__PURE__*/ requireTokenGenerator$1();
	const token_verifier_1 = /*@__PURE__*/ requireTokenVerifier$1();
	const auth_config_1 = /*@__PURE__*/ requireAuthConfig();
	const user_record_1 = /*@__PURE__*/ requireUserRecord();
	const identifier_1 = /*@__PURE__*/ requireIdentifier();
	const crypto_signer_1 = /*@__PURE__*/ requireCryptoSigner();
	/**
	 * @internal
	 */
	function createFirebaseTokenGenerator(app, tenantId) {
	    try {
	        const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);
	        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);
	    }
	    catch (err) {
	        throw (0, token_generator_1.handleCryptoSignerError)(err);
	    }
	}
	baseAuth.createFirebaseTokenGenerator = createFirebaseTokenGenerator;
	/**
	 * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.
	 */
	class BaseAuth {
	    /**
	     * The BaseAuth class constructor.
	     *
	     * @param app - The FirebaseApp to associate with this Auth instance.
	     * @param authRequestHandler - The RPC request handler for this instance.
	     * @param tokenGenerator - Optional token generator. If not specified, a
	     *     (non-tenant-aware) instance will be created. Use this paramter to
	     *     specify a tenant-aware tokenGenerator.
	     * @constructor
	     * @internal
	     */
	    constructor(app, 
	    /** @internal */ authRequestHandler, tokenGenerator) {
	        this.authRequestHandler = authRequestHandler;
	        if (tokenGenerator) {
	            this.tokenGenerator = tokenGenerator;
	        }
	        else {
	            this.tokenGenerator = createFirebaseTokenGenerator(app);
	        }
	        this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);
	        this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);
	        this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);
	    }
	    /**
	     * Creates a new Firebase custom token (JWT) that can be sent back to a client
	     * device to use to sign in with the client SDKs' `signInWithCustomToken()`
	     * methods. (Tenant-aware instances will also embed the tenant ID in the
	     * token.)
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}
	     * for code samples and detailed documentation.
	     *
	     * @param uid - The `uid` to use as the custom token's subject.
	     * @param developerClaims - Optional additional claims to include
	     *   in the custom token's payload.
	     *
	     * @returns A promise fulfilled with a custom token for the
	     *   provided `uid` and payload.
	     */
	    createCustomToken(uid, developerClaims) {
	        return this.tokenGenerator.createCustomToken(uid, developerClaims);
	    }
	    /**
	     * Verifies a Firebase ID token (JWT). If the token is valid, the promise is
	     * fulfilled with the token's decoded claims; otherwise, the promise is
	     * rejected.
	     *
	     * If `checkRevoked` is set to true, first verifies whether the corresponding
	     * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,
	     * verifies if the session corresponding to the ID token was revoked. If the
	     * corresponding user's session was invalidated, an `auth/id-token-revoked`
	     * error is thrown. If not specified the check is not applied.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}
	     * for code samples and detailed documentation.
	     *
	     * @param idToken - The ID token to verify.
	     * @param checkRevoked - Whether to check if the ID token was revoked.
	     *   This requires an extra request to the Firebase Auth backend to check
	     *   the `tokensValidAfterTime` time for the corresponding user.
	     *   When not specified, this additional check is not applied.
	     *
	     * @returns A promise fulfilled with the
	     *   token's decoded claims if the ID token is valid; otherwise, a rejected
	     *   promise.
	     */
	    verifyIdToken(idToken, checkRevoked = false) {
	        const isEmulator = (0, auth_api_request_1.useEmulator)();
	        return this.idTokenVerifier.verifyJWT(idToken, isEmulator)
	            .then((decodedIdToken) => {
	            // Whether to check if the token was revoked.
	            if (checkRevoked || isEmulator) {
	                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);
	            }
	            return decodedIdToken;
	        });
	    }
	    /**
	     * Gets the user data for the user corresponding to a given `uid`.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
	     * for code samples and detailed documentation.
	     *
	     * @param uid - The `uid` corresponding to the user whose data to fetch.
	     *
	     * @returns A promise fulfilled with the user
	     *   data corresponding to the provided `uid`.
	     */
	    getUser(uid) {
	        return this.authRequestHandler.getAccountInfoByUid(uid)
	            .then((response) => {
	            // Returns the user record populated with server response.
	            return new user_record_1.UserRecord(response.users[0]);
	        });
	    }
	    /**
	     * Gets the user data for the user corresponding to a given email.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
	     * for code samples and detailed documentation.
	     *
	     * @param email - The email corresponding to the user whose data to
	     *   fetch.
	     *
	     * @returns A promise fulfilled with the user
	     *   data corresponding to the provided email.
	     */
	    getUserByEmail(email) {
	        return this.authRequestHandler.getAccountInfoByEmail(email)
	            .then((response) => {
	            // Returns the user record populated with server response.
	            return new user_record_1.UserRecord(response.users[0]);
	        });
	    }
	    /**
	     * Gets the user data for the user corresponding to a given phone number. The
	     * phone number has to conform to the E.164 specification.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
	     * for code samples and detailed documentation.
	     *
	     * @param phoneNumber - The phone number corresponding to the user whose
	     *   data to fetch.
	     *
	     * @returns A promise fulfilled with the user
	     *   data corresponding to the provided phone number.
	     */
	    getUserByPhoneNumber(phoneNumber) {
	        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)
	            .then((response) => {
	            // Returns the user record populated with server response.
	            return new user_record_1.UserRecord(response.users[0]);
	        });
	    }
	    /**
	     * Gets the user data for the user corresponding to a given provider id.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
	     * for code samples and detailed documentation.
	     *
	     * @param providerId - The provider ID, for example, "google.com" for the
	     *   Google provider.
	     * @param uid - The user identifier for the given provider.
	     *
	     * @returns A promise fulfilled with the user data corresponding to the
	     *   given provider id.
	     */
	    getUserByProviderUid(providerId, uid) {
	        // Although we don't really advertise it, we want to also handle
	        // non-federated idps with this call. So if we detect one of them, we'll
	        // reroute this request appropriately.
	        if (providerId === 'phone') {
	            return this.getUserByPhoneNumber(uid);
	        }
	        else if (providerId === 'email') {
	            return this.getUserByEmail(uid);
	        }
	        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid)
	            .then((response) => {
	            // Returns the user record populated with server response.
	            return new user_record_1.UserRecord(response.users[0]);
	        });
	    }
	    /**
	     * Gets the user data corresponding to the specified identifiers.
	     *
	     * There are no ordering guarantees; in particular, the nth entry in the result list is not
	     * guaranteed to correspond to the nth entry in the input parameters list.
	     *
	     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,
	     * this method throws a FirebaseAuthError.
	     *
	     * @param identifiers - The identifiers used to indicate which user records should be returned.
	     *     Must not have more than 100 entries.
	     * @returns A promise that resolves to the corresponding user records.
	     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100
	     *     identifiers are specified.
	     */
	    getUsers(identifiers) {
	        if (!validator.isArray(identifiers)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');
	        }
	        return this.authRequestHandler
	            .getAccountInfoByIdentifiers(identifiers)
	            .then((response) => {
	            /**
	             * Checks if the specified identifier is within the list of
	             * UserRecords.
	             */
	            const isUserFound = ((id, userRecords) => {
	                return !!userRecords.find((userRecord) => {
	                    if ((0, identifier_1.isUidIdentifier)(id)) {
	                        return id.uid === userRecord.uid;
	                    }
	                    else if ((0, identifier_1.isEmailIdentifier)(id)) {
	                        return id.email === userRecord.email;
	                    }
	                    else if ((0, identifier_1.isPhoneIdentifier)(id)) {
	                        return id.phoneNumber === userRecord.phoneNumber;
	                    }
	                    else if ((0, identifier_1.isProviderIdentifier)(id)) {
	                        const matchingUserInfo = userRecord.providerData.find((userInfo) => {
	                            return id.providerId === userInfo.providerId;
	                        });
	                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;
	                    }
	                    else {
	                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');
	                    }
	                });
	            });
	            const users = response.users ? response.users.map((user) => new user_record_1.UserRecord(user)) : [];
	            const notFound = identifiers.filter((id) => !isUserFound(id, users));
	            return { users, notFound };
	        });
	    }
	    /**
	     * Retrieves a list of users (single batch only) with a size of `maxResults`
	     * starting from the offset as specified by `pageToken`. This is used to
	     * retrieve all the users of a specified project in batches.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}
	     * for code samples and detailed documentation.
	     *
	     * @param maxResults - The page size, 1000 if undefined. This is also
	     *   the maximum allowed limit.
	     * @param pageToken - The next page token. If not specified, returns
	     *   users starting without any offset.
	     * @returns A promise that resolves with
	     *   the current batch of downloaded users and the next page token.
	     */
	    listUsers(maxResults, pageToken) {
	        return this.authRequestHandler.downloadAccount(maxResults, pageToken)
	            .then((response) => {
	            // List of users to return.
	            const users = [];
	            // Convert each user response to a UserRecord.
	            response.users.forEach((userResponse) => {
	                users.push(new user_record_1.UserRecord(userResponse));
	            });
	            // Return list of user records and the next page token if available.
	            const result = {
	                users,
	                pageToken: response.nextPageToken,
	            };
	            // Delete result.pageToken if undefined.
	            if (typeof result.pageToken === 'undefined') {
	                delete result.pageToken;
	            }
	            return result;
	        });
	    }
	    /**
	     * Creates a new user.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}
	     * for code samples and detailed documentation.
	     *
	     * @param properties - The properties to set on the
	     *   new user record to be created.
	     *
	     * @returns A promise fulfilled with the user
	     *   data corresponding to the newly created user.
	     */
	    createUser(properties) {
	        return this.authRequestHandler.createNewAccount(properties)
	            .then((uid) => {
	            // Return the corresponding user record.
	            return this.getUser(uid);
	        })
	            .catch((error) => {
	            if (error.code === 'auth/user-not-found') {
	                // Something must have happened after creating the user and then retrieving it.
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');
	            }
	            throw error;
	        });
	    }
	    /**
	     * Deletes an existing user.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}
	     * for code samples and detailed documentation.
	     *
	     * @param uid - The `uid` corresponding to the user to delete.
	     *
	     * @returns An empty promise fulfilled once the user has been
	     *   deleted.
	     */
	    deleteUser(uid) {
	        return this.authRequestHandler.deleteAccount(uid)
	            .then(() => {
	            // Return nothing on success.
	        });
	    }
	    /**
	     * Deletes the users specified by the given uids.
	     *
	     * Deleting a non-existing user won't generate an error (i.e. this method
	     * is idempotent.) Non-existing users are considered to be successfully
	     * deleted, and are therefore counted in the
	     * `DeleteUsersResult.successCount` value.
	     *
	     * Only a maximum of 1000 identifiers may be supplied. If more than 1000
	     * identifiers are supplied, this method throws a FirebaseAuthError.
	     *
	     * This API is currently rate limited at the server to 1 QPS. If you exceed
	     * this, you may get a quota exceeded error. Therefore, if you want to
	     * delete more than 1000 users, you may need to add a delay to ensure you
	     * don't go over this limit.
	     *
	     * @param uids - The `uids` corresponding to the users to delete.
	     *
	     * @returns A Promise that resolves to the total number of successful/failed
	     *     deletions, as well as the array of errors that corresponds to the
	     *     failed deletions.
	     */
	    deleteUsers(uids) {
	        if (!validator.isArray(uids)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');
	        }
	        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)
	            .then((batchDeleteAccountsResponse) => {
	            const result = {
	                failureCount: 0,
	                successCount: uids.length,
	                errors: [],
	            };
	            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {
	                return result;
	            }
	            result.failureCount = batchDeleteAccountsResponse.errors.length;
	            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;
	            result.errors = batchDeleteAccountsResponse.errors.map((batchDeleteErrorInfo) => {
	                if (batchDeleteErrorInfo.index === undefined) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');
	                }
	                const errMsgToError = (msg) => {
	                    // We unconditionally set force=true, so the 'NOT_DISABLED' error
	                    // should not be possible.
	                    const code = msg && msg.startsWith('NOT_DISABLED') ?
	                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;
	                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);
	                };
	                return {
	                    index: batchDeleteErrorInfo.index,
	                    error: errMsgToError(batchDeleteErrorInfo.message),
	                };
	            });
	            return result;
	        });
	    }
	    /**
	     * Updates an existing user.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}
	     * for code samples and detailed documentation.
	     *
	     * @param uid - The `uid` corresponding to the user to update.
	     * @param properties - The properties to update on
	     *   the provided user.
	     *
	     * @returns A promise fulfilled with the
	     *   updated user data.
	     */
	    updateUser(uid, properties) {
	        // Although we don't really advertise it, we want to also handle linking of
	        // non-federated idps with this call. So if we detect one of them, we'll
	        // adjust the properties parameter appropriately. This *does* imply that a
	        // conflict could arise, e.g. if the user provides a phoneNumber property,
	        // but also provides a providerToLink with a 'phone' provider id. In that
	        // case, we'll throw an error.
	        properties = (0, deep_copy_1.deepCopy)(properties);
	        if (properties?.providerToLink) {
	            if (properties.providerToLink.providerId === 'email') {
	                if (typeof properties.email !== 'undefined') {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To "
	                        + 'link to the email/password provider, only specify the UpdateRequest.email field.');
	                }
	                properties.email = properties.providerToLink.uid;
	                delete properties.providerToLink;
	            }
	            else if (properties.providerToLink.providerId === 'phone') {
	                if (typeof properties.phoneNumber !== 'undefined') {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To "
	                        + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');
	                }
	                properties.phoneNumber = properties.providerToLink.uid;
	                delete properties.providerToLink;
	            }
	        }
	        if (properties?.providersToUnlink) {
	            if (properties.providersToUnlink.indexOf('phone') !== -1) {
	                // If we've been told to unlink the phone provider both via setting
	                // phoneNumber to null *and* by setting providersToUnlink to include
	                // 'phone', then we'll reject that. Though it might also be reasonable
	                // to relax this restriction and just unlink it.
	                if (properties.phoneNumber === null) {
	                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To "
	                        + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');
	                }
	            }
	        }
	        return this.authRequestHandler.updateExistingAccount(uid, properties)
	            .then((existingUid) => {
	            // Return the corresponding user record.
	            return this.getUser(existingUid);
	        });
	    }
	    /**
	     * Sets additional developer claims on an existing user identified by the
	     * provided `uid`, typically used to define user roles and levels of
	     * access. These claims should propagate to all devices where the user is
	     * already signed in (after token expiration or when token refresh is forced)
	     * and the next time the user signs in. If a reserved OIDC claim name
	     * is used (sub, iat, iss, etc), an error is thrown. They are set on the
	     * authenticated user's ID token JWT.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |
	     * Defining user roles and access levels}
	     * for code samples and detailed documentation.
	     *
	     * @param uid - The `uid` of the user to edit.
	     * @param customUserClaims - The developer claims to set. If null is
	     *   passed, existing custom claims are deleted. Passing a custom claims payload
	     *   larger than 1000 bytes will throw an error. Custom claims are added to the
	     *   user's ID token which is transmitted on every authenticated request.
	     *   For profile non-access related user attributes, use database or other
	     *   separate storage systems.
	     * @returns A promise that resolves when the operation completes
	     *   successfully.
	     */
	    setCustomUserClaims(uid, customUserClaims) {
	        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)
	            .then(() => {
	            // Return nothing on success.
	        });
	    }
	    /**
	     * Revokes all refresh tokens for an existing user.
	     *
	     * This API will update the user's {@link UserRecord.tokensValidAfterTime} to
	     * the current UTC. It is important that the server on which this is called has
	     * its clock set correctly and synchronized.
	     *
	     * While this will revoke all sessions for a specified user and disable any
	     * new ID tokens for existing sessions from getting minted, existing ID tokens
	     * may remain active until their natural expiration (one hour). To verify that
	     * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}
	     * where `checkRevoked` is set to true.
	     *
	     * @param uid - The `uid` corresponding to the user whose refresh tokens
	     *   are to be revoked.
	     *
	     * @returns An empty promise fulfilled once the user's refresh
	     *   tokens have been revoked.
	     */
	    revokeRefreshTokens(uid) {
	        return this.authRequestHandler.revokeRefreshTokens(uid)
	            .then(() => {
	            // Return nothing on success.
	        });
	    }
	    /**
	     * Imports the provided list of users into Firebase Auth.
	     * A maximum of 1000 users are allowed to be imported one at a time.
	     * When importing users with passwords,
	     * {@link UserImportOptions} are required to be
	     * specified.
	     * This operation is optimized for bulk imports and will ignore checks on `uid`,
	     * `email` and other identifier uniqueness which could result in duplications.
	     *
	     * @param users - The list of user records to import to Firebase Auth.
	     * @param options - The user import options, required when the users provided include
	     *   password credentials.
	     * @returns A promise that resolves when
	     *   the operation completes with the result of the import. This includes the
	     *   number of successful imports, the number of failed imports and their
	     *   corresponding errors.
	    */
	    importUsers(users, options) {
	        return this.authRequestHandler.uploadAccount(users, options);
	    }
	    /**
	     * Creates a new Firebase session cookie with the specified options. The created
	     * JWT string can be set as a server-side session cookie with a custom cookie
	     * policy, and be used for session management. The session cookie JWT will have
	     * the same payload claims as the provided ID token.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}
	     * for code samples and detailed documentation.
	     *
	     * @param idToken - The Firebase ID token to exchange for a session
	     *   cookie.
	     * @param sessionCookieOptions - The session
	     *   cookie options which includes custom session duration.
	     *
	     * @returns A promise that resolves on success with the
	     *   created session cookie.
	     */
	    createSessionCookie(idToken, sessionCookieOptions) {
	        // Return rejected promise if expiresIn is not available.
	        if (!validator.isNonNullObject(sessionCookieOptions) ||
	            !validator.isNumber(sessionCookieOptions.expiresIn)) {
	            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
	        }
	        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);
	    }
	    /**
	     * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.
	     * Rejects the promise if the cookie could not be verified.
	     *
	     * If `checkRevoked` is set to true, first verifies whether the corresponding
	     * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,
	     * verifies if the session corresponding to the session cookie was revoked.
	     * If the corresponding user's session was invalidated, an
	     * `auth/session-cookie-revoked` error is thrown. If not specified the check
	     * is not performed.
	     *
	     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |
	     * Verify Session Cookies}
	     * for code samples and detailed documentation
	     *
	     * @param sessionCookie - The session cookie to verify.
	     * @param checkForRevocation -  Whether to check if the session cookie was
	     *   revoked. This requires an extra request to the Firebase Auth backend to
	     *   check the `tokensValidAfterTime` time for the corresponding user.
	     *   When not specified, this additional check is not performed.
	     *
	     * @returns A promise fulfilled with the
	     *   session cookie's decoded claims if the session cookie is valid; otherwise,
	     *   a rejected promise.
	     */
	    verifySessionCookie(sessionCookie, checkRevoked = false) {
	        const isEmulator = (0, auth_api_request_1.useEmulator)();
	        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator)
	            .then((decodedIdToken) => {
	            // Whether to check if the token was revoked.
	            if (checkRevoked || isEmulator) {
	                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);
	            }
	            return decodedIdToken;
	        });
	    }
	    /**
	     * Generates the out of band email action link to reset a user's password.
	     * The link is generated for the user with the specified email address. The
	     * optional  {@link ActionCodeSettings} object
	     * defines whether the link is to be handled by a mobile app or browser and the
	     * additional state information to be passed in the deep link, etc.
	     *
	     * @example
	     * ```javascript
	     * var actionCodeSettings = {
	     *   url: 'https://www.example.com/?email=user@example.com',
	     *   iOS: {
	     *     bundleId: 'com.example.ios'
	     *   },
	     *   android: {
	     *     packageName: 'com.example.android',
	     *     installApp: true,
	     *     minimumVersion: '12'
	     *   },
	     *   handleCodeInApp: true,
	     *   dynamicLinkDomain: 'custom.page.link'
	     * };
	     * admin.auth()
	     *     .generatePasswordResetLink('user@example.com', actionCodeSettings)
	     *     .then(function(link) {
	     *       // The link was successfully generated.
	     *     })
	     *     .catch(function(error) {
	     *       // Some error occurred, you can inspect the code: error.code
	     *     });
	     * ```
	     *
	     * @param email - The email address of the user whose password is to be
	     *   reset.
	     * @param actionCodeSettings - The action
	     *     code settings. If specified, the state/continue URL is set as the
	     *     "continueUrl" parameter in the password reset link. The default password
	     *     reset landing page will use this to display a link to go back to the app
	     *     if it is installed.
	     *     If the actionCodeSettings is not specified, no URL is appended to the
	     *     action URL.
	     *     The state URL provided must belong to a domain that is whitelisted by the
	     *     developer in the console. Otherwise an error is thrown.
	     *     Mobile app redirects are only applicable if the developer configures
	     *     and accepts the Firebase Dynamic Links terms of service.
	     *     The Android package name and iOS bundle ID are respected only if they
	     *     are configured in the same Firebase Auth project.
	     * @returns A promise that resolves with the generated link.
	     */
	    generatePasswordResetLink(email, actionCodeSettings) {
	        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);
	    }
	    /**
	     * Generates the out of band email action link to verify the user's ownership
	     * of the specified email. The {@link ActionCodeSettings} object provided
	     * as an argument to this method defines whether the link is to be handled by a
	     * mobile app or browser along with additional state information to be passed in
	     * the deep link, etc.
	     *
	     * @example
	     * ```javascript
	     * var actionCodeSettings = {
	     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
	     *   iOS: {
	     *     bundleId: 'com.example.ios'
	     *   },
	     *   android: {
	     *     packageName: 'com.example.android',
	     *     installApp: true,
	     *     minimumVersion: '12'
	     *   },
	     *   handleCodeInApp: true,
	     *   dynamicLinkDomain: 'custom.page.link'
	     * };
	     * admin.auth()
	     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
	     *     .then(function(link) {
	     *       // The link was successfully generated.
	     *     })
	     *     .catch(function(error) {
	     *       // Some error occurred, you can inspect the code: error.code
	     *     });
	     * ```
	     *
	     * @param email - The email account to verify.
	     * @param actionCodeSettings - The action
	     *     code settings. If specified, the state/continue URL is set as the
	     *     "continueUrl" parameter in the email verification link. The default email
	     *     verification landing page will use this to display a link to go back to
	     *     the app if it is installed.
	     *     If the actionCodeSettings is not specified, no URL is appended to the
	     *     action URL.
	     *     The state URL provided must belong to a domain that is whitelisted by the
	     *     developer in the console. Otherwise an error is thrown.
	     *     Mobile app redirects are only applicable if the developer configures
	     *     and accepts the Firebase Dynamic Links terms of service.
	     *     The Android package name and iOS bundle ID are respected only if they
	     *     are configured in the same Firebase Auth project.
	     * @returns A promise that resolves with the generated link.
	     */
	    generateEmailVerificationLink(email, actionCodeSettings) {
	        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);
	    }
	    /**
	     * Generates an out-of-band email action link to verify the user's ownership
	     * of the specified email. The {@link ActionCodeSettings} object provided
	     * as an argument to this method defines whether the link is to be handled by a
	     * mobile app or browser along with additional state information to be passed in
	     * the deep link, etc.
	     *
	     * @param email - The current email account.
	     * @param newEmail - The email address the account is being updated to.
	     * @param actionCodeSettings - The action
	     *     code settings. If specified, the state/continue URL is set as the
	     *     "continueUrl" parameter in the email verification link. The default email
	     *     verification landing page will use this to display a link to go back to
	     *     the app if it is installed.
	     *     If the actionCodeSettings is not specified, no URL is appended to the
	     *     action URL.
	     *     The state URL provided must belong to a domain that is authorized
	     *     in the console, or an error will be thrown.
	     *     Mobile app redirects are only applicable if the developer configures
	     *     and accepts the Firebase Dynamic Links terms of service.
	     *     The Android package name and iOS bundle ID are respected only if they
	     *     are configured in the same Firebase Auth project.
	     * @returns A promise that resolves with the generated link.
	     */
	    generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {
	        return this.authRequestHandler.getEmailActionLink('VERIFY_AND_CHANGE_EMAIL', email, actionCodeSettings, newEmail);
	    }
	    /**
	     * Generates the out of band email action link to verify the user's ownership
	     * of the specified email. The {@link ActionCodeSettings} object provided
	     * as an argument to this method defines whether the link is to be handled by a
	     * mobile app or browser along with additional state information to be passed in
	     * the deep link, etc.
	     *
	     * @example
	     * ```javascript
	     * var actionCodeSettings = {
	     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
	     *   iOS: {
	     *     bundleId: 'com.example.ios'
	     *   },
	     *   android: {
	     *     packageName: 'com.example.android',
	     *     installApp: true,
	     *     minimumVersion: '12'
	     *   },
	     *   handleCodeInApp: true,
	     *   dynamicLinkDomain: 'custom.page.link'
	     * };
	     * admin.auth()
	     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
	     *     .then(function(link) {
	     *       // The link was successfully generated.
	     *     })
	     *     .catch(function(error) {
	     *       // Some error occurred, you can inspect the code: error.code
	     *     });
	     * ```
	     *
	     * @param email - The email account to verify.
	     * @param actionCodeSettings - The action
	     *     code settings. If specified, the state/continue URL is set as the
	     *     "continueUrl" parameter in the email verification link. The default email
	     *     verification landing page will use this to display a link to go back to
	     *     the app if it is installed.
	     *     If the actionCodeSettings is not specified, no URL is appended to the
	     *     action URL.
	     *     The state URL provided must belong to a domain that is whitelisted by the
	     *     developer in the console. Otherwise an error is thrown.
	     *     Mobile app redirects are only applicable if the developer configures
	     *     and accepts the Firebase Dynamic Links terms of service.
	     *     The Android package name and iOS bundle ID are respected only if they
	     *     are configured in the same Firebase Auth project.
	     * @returns A promise that resolves with the generated link.
	     */
	    generateSignInWithEmailLink(email, actionCodeSettings) {
	        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);
	    }
	    /**
	     * Returns the list of existing provider configurations matching the filter
	     * provided. At most, 100 provider configs can be listed at a time.
	     *
	     * SAML and OIDC provider support requires Google Cloud's Identity Platform
	     * (GCIP). To learn more about GCIP, including pricing and features,
	     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	     *
	     * @param options - The provider config filter to apply.
	     * @returns A promise that resolves with the list of provider configs meeting the
	     *   filter requirements.
	     */
	    listProviderConfigs(options) {
	        const processResponse = (response, providerConfigs) => {
	            // Return list of provider configuration and the next page token if available.
	            const result = {
	                providerConfigs,
	            };
	            // Delete result.pageToken if undefined.
	            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {
	                result.pageToken = response.nextPageToken;
	            }
	            return result;
	        };
	        if (options && options.type === 'oidc') {
	            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)
	                .then((response) => {
	                // List of provider configurations to return.
	                const providerConfigs = [];
	                // Convert each provider config response to a OIDCConfig.
	                response.oauthIdpConfigs.forEach((configResponse) => {
	                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));
	                });
	                // Return list of provider configuration and the next page token if available.
	                return processResponse(response, providerConfigs);
	            });
	        }
	        else if (options && options.type === 'saml') {
	            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)
	                .then((response) => {
	                // List of provider configurations to return.
	                const providerConfigs = [];
	                // Convert each provider config response to a SAMLConfig.
	                response.inboundSamlConfigs.forEach((configResponse) => {
	                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));
	                });
	                // Return list of provider configuration and the next page token if available.
	                return processResponse(response, providerConfigs);
	            });
	        }
	        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"AuthProviderConfigFilter.type" must be either "saml" or "oidc"'));
	    }
	    /**
	     * Looks up an Auth provider configuration by the provided ID.
	     * Returns a promise that resolves with the provider configuration
	     * corresponding to the provider ID specified. If the specified ID does not
	     * exist, an `auth/configuration-not-found` error is thrown.
	     *
	     * SAML and OIDC provider support requires Google Cloud's Identity Platform
	     * (GCIP). To learn more about GCIP, including pricing and features,
	     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	     *
	     * @param providerId - The provider ID corresponding to the provider
	     *     config to return.
	     * @returns A promise that resolves
	     *     with the configuration corresponding to the provided ID.
	     */
	    getProviderConfig(providerId) {
	        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.getOAuthIdpConfig(providerId)
	                .then((response) => {
	                return new auth_config_1.OIDCConfig(response);
	            });
	        }
	        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.getInboundSamlConfig(providerId)
	                .then((response) => {
	                return new auth_config_1.SAMLConfig(response);
	            });
	        }
	        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
	    }
	    /**
	     * Deletes the provider configuration corresponding to the provider ID passed.
	     * If the specified ID does not exist, an `auth/configuration-not-found` error
	     * is thrown.
	     *
	     * SAML and OIDC provider support requires Google Cloud's Identity Platform
	     * (GCIP). To learn more about GCIP, including pricing and features,
	     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	     *
	     * @param providerId - The provider ID corresponding to the provider
	     *     config to delete.
	     * @returns A promise that resolves on completion.
	     */
	    deleteProviderConfig(providerId) {
	        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);
	        }
	        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.deleteInboundSamlConfig(providerId);
	        }
	        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
	    }
	    /**
	     * Returns a promise that resolves with the updated `AuthProviderConfig`
	     * corresponding to the provider ID specified.
	     * If the specified ID does not exist, an `auth/configuration-not-found` error
	     * is thrown.
	     *
	     * SAML and OIDC provider support requires Google Cloud's Identity Platform
	     * (GCIP). To learn more about GCIP, including pricing and features,
	     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	     *
	     * @param providerId - The provider ID corresponding to the provider
	     *     config to update.
	     * @param updatedConfig - The updated configuration.
	     * @returns A promise that resolves with the updated provider configuration.
	     */
	    updateProviderConfig(providerId, updatedConfig) {
	        if (!validator.isNonNullObject(updatedConfig)) {
	            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "UpdateAuthProviderRequest" configuration.'));
	        }
	        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)
	                .then((response) => {
	                return new auth_config_1.OIDCConfig(response);
	            });
	        }
	        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
	            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)
	                .then((response) => {
	                return new auth_config_1.SAMLConfig(response);
	            });
	        }
	        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
	    }
	    /**
	     * Returns a promise that resolves with the newly created `AuthProviderConfig`
	     * when the new provider configuration is created.
	     *
	     * SAML and OIDC provider support requires Google Cloud's Identity Platform
	     * (GCIP). To learn more about GCIP, including pricing and features,
	     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	     *
	     * @param config - The provider configuration to create.
	     * @returns A promise that resolves with the created provider configuration.
	     */
	    createProviderConfig(config) {
	        if (!validator.isNonNullObject(config)) {
	            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "AuthProviderConfig" configuration.'));
	        }
	        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {
	            return this.authRequestHandler.createOAuthIdpConfig(config)
	                .then((response) => {
	                return new auth_config_1.OIDCConfig(response);
	            });
	        }
	        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {
	            return this.authRequestHandler.createInboundSamlConfig(config)
	                .then((response) => {
	                return new auth_config_1.SAMLConfig(response);
	            });
	        }
	        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
	    }
	    /** @alpha */
	    // eslint-disable-next-line @typescript-eslint/naming-convention
	    _verifyAuthBlockingToken(token, audience) {
	        const isEmulator = (0, auth_api_request_1.useEmulator)();
	        return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience)
	            .then((decodedAuthBlockingToken) => {
	            return decodedAuthBlockingToken;
	        });
	    }
	    /**
	     * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that
	     * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked
	     * or user disabled.
	     *
	     * @param decodedIdToken - The JWT's decoded claims.
	     * @param revocationErrorInfo - The revocation error info to throw on revocation
	     *     detection.
	     * @returns A promise that will be fulfilled after a successful verification.
	     */
	    verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {
	        // Get tokens valid after time for the corresponding user.
	        return this.getUser(decodedIdToken.sub)
	            .then((user) => {
	            if (user.disabled) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');
	            }
	            // If no tokens valid after time available, token is not revoked.
	            if (user.tokensValidAfterTime) {
	                // Get the ID token authentication time and convert to milliseconds UTC.
	                const authTimeUtc = decodedIdToken.auth_time * 1000;
	                // Get user tokens valid after time in milliseconds UTC.
	                const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();
	                // Check if authentication time is older than valid since time.
	                if (authTimeUtc < validSinceUtc) {
	                    throw new error_1.FirebaseAuthError(revocationErrorInfo);
	                }
	            }
	            // All checks above passed. Return the decoded token.
	            return decodedIdToken;
	        });
	    }
	}
	baseAuth.BaseAuth = BaseAuth;
	return baseAuth;
}

/*! firebase-admin v12.7.0 */

var hasRequiredTenantManager;

function requireTenantManager () {
	if (hasRequiredTenantManager) return tenantManager;
	hasRequiredTenantManager = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tenantManager, "__esModule", { value: true });
	tenantManager.TenantManager = tenantManager.TenantAwareAuth = void 0;
	const validator = validator$2;
	const utils = utils$1;
	const error_1 = error;
	const base_auth_1 = /*@__PURE__*/ requireBaseAuth();
	const tenant_1 = /*@__PURE__*/ requireTenant();
	const auth_api_request_1 = /*@__PURE__*/ requireAuthApiRequest();
	/**
	 * Tenant-aware `Auth` interface used for managing users, configuring SAML/OIDC providers,
	 * generating email links for password reset, email verification, etc for specific tenants.
	 *
	 * Multi-tenancy support requires Google Cloud's Identity Platform
	 * (GCIP). To learn more about GCIP, including pricing and features,
	 * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
	 *
	 * Each tenant contains its own identity providers, settings and sets of users.
	 * Using `TenantAwareAuth`, users for a specific tenant and corresponding OIDC/SAML
	 * configurations can also be managed, ID tokens for users signed in to a specific tenant
	 * can be verified, and email action links can also be generated for users belonging to the
	 * tenant.
	 *
	 * `TenantAwareAuth` instances for a specific `tenantId` can be instantiated by calling
	 * {@link TenantManager.authForTenant}.
	 */
	class TenantAwareAuth extends base_auth_1.BaseAuth {
	    /**
	     * The TenantAwareAuth class constructor.
	     *
	     * @param app - The app that created this tenant.
	     * @param tenantId - The corresponding tenant ID.
	     * @constructor
	     * @internal
	     */
	    constructor(app, tenantId) {
	        super(app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), (0, base_auth_1.createFirebaseTokenGenerator)(app, tenantId));
	        utils.addReadonlyGetter(this, 'tenantId', tenantId);
	    }
	    /**
	     * {@inheritdoc BaseAuth.verifyIdToken}
	     */
	    verifyIdToken(idToken, checkRevoked = false) {
	        return super.verifyIdToken(idToken, checkRevoked)
	            .then((decodedClaims) => {
	            // Validate tenant ID.
	            if (decodedClaims.firebase.tenant !== this.tenantId) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
	            }
	            return decodedClaims;
	        });
	    }
	    /**
	     * {@inheritdoc BaseAuth.createSessionCookie}
	     */
	    createSessionCookie(idToken, sessionCookieOptions) {
	        // Validate arguments before processing.
	        if (!validator.isNonEmptyString(idToken)) {
	            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));
	        }
	        if (!validator.isNonNullObject(sessionCookieOptions) ||
	            !validator.isNumber(sessionCookieOptions.expiresIn)) {
	            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
	        }
	        // This will verify the ID token and then match the tenant ID before creating the session cookie.
	        return this.verifyIdToken(idToken)
	            .then(() => {
	            return super.createSessionCookie(idToken, sessionCookieOptions);
	        });
	    }
	    /**
	     * {@inheritdoc BaseAuth.verifySessionCookie}
	     */
	    verifySessionCookie(sessionCookie, checkRevoked = false) {
	        return super.verifySessionCookie(sessionCookie, checkRevoked)
	            .then((decodedClaims) => {
	            if (decodedClaims.firebase.tenant !== this.tenantId) {
	                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
	            }
	            return decodedClaims;
	        });
	    }
	}
	tenantManager.TenantAwareAuth = TenantAwareAuth;
	/**
	 * Defines the tenant manager used to help manage tenant related operations.
	 * This includes:
	 * <ul>
	 * <li>The ability to create, update, list, get and delete tenants for the underlying
	 *     project.</li>
	 * <li>Getting a `TenantAwareAuth` instance for running Auth related operations
	 *     (user management, provider configuration management, token verification,
	 *     email link generation, etc) in the context of a specified tenant.</li>
	 * </ul>
	 */
	class TenantManager {
	    /**
	     * Initializes a TenantManager instance for a specified FirebaseApp.
	     *
	     * @param app - The app for this TenantManager instance.
	     *
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.app = app;
	        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
	        this.tenantsMap = {};
	    }
	    /**
	     * Returns a `TenantAwareAuth` instance bound to the given tenant ID.
	     *
	     * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.
	     *
	     * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.
	     */
	    authForTenant(tenantId) {
	        if (!validator.isNonEmptyString(tenantId)) {
	            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
	        }
	        if (typeof this.tenantsMap[tenantId] === 'undefined') {
	            this.tenantsMap[tenantId] = new TenantAwareAuth(this.app, tenantId);
	        }
	        return this.tenantsMap[tenantId];
	    }
	    /**
	     * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.
	     *
	     * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.
	     *
	     * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.
	     */
	    getTenant(tenantId) {
	        return this.authRequestHandler.getTenant(tenantId)
	            .then((response) => {
	            return new tenant_1.Tenant(response);
	        });
	    }
	    /**
	     * Retrieves a list of tenants (single batch only) with a size of `maxResults`
	     * starting from the offset as specified by `pageToken`. This is used to
	     * retrieve all the tenants of a specified project in batches.
	     *
	     * @param maxResults - The page size, 1000 if undefined. This is also
	     *   the maximum allowed limit.
	     * @param pageToken - The next page token. If not specified, returns
	     *   tenants starting without any offset.
	     *
	     * @returns A promise that resolves with
	     *   a batch of downloaded tenants and the next page token.
	     */
	    listTenants(maxResults, pageToken) {
	        return this.authRequestHandler.listTenants(maxResults, pageToken)
	            .then((response) => {
	            // List of tenants to return.
	            const tenants = [];
	            // Convert each user response to a Tenant.
	            response.tenants.forEach((tenantResponse) => {
	                tenants.push(new tenant_1.Tenant(tenantResponse));
	            });
	            // Return list of tenants and the next page token if available.
	            const result = {
	                tenants,
	                pageToken: response.nextPageToken,
	            };
	            // Delete result.pageToken if undefined.
	            if (typeof result.pageToken === 'undefined') {
	                delete result.pageToken;
	            }
	            return result;
	        });
	    }
	    /**
	     * Deletes an existing tenant.
	     *
	     * @param tenantId - The `tenantId` corresponding to the tenant to delete.
	     *
	     * @returns An empty promise fulfilled once the tenant has been deleted.
	     */
	    deleteTenant(tenantId) {
	        return this.authRequestHandler.deleteTenant(tenantId);
	    }
	    /**
	     * Creates a new tenant.
	     * When creating new tenants, tenants that use separate billing and quota will require their
	     * own project and must be defined as `full_service`.
	     *
	     * @param tenantOptions - The properties to set on the new tenant configuration to be created.
	     *
	     * @returns A promise fulfilled with the tenant configuration corresponding to the newly
	     *   created tenant.
	     */
	    createTenant(tenantOptions) {
	        return this.authRequestHandler.createTenant(tenantOptions)
	            .then((response) => {
	            return new tenant_1.Tenant(response);
	        });
	    }
	    /**
	     * Updates an existing tenant configuration.
	     *
	     * @param tenantId - The `tenantId` corresponding to the tenant to delete.
	     * @param tenantOptions - The properties to update on the provided tenant.
	     *
	     * @returns A promise fulfilled with the update tenant data.
	     */
	    updateTenant(tenantId, tenantOptions) {
	        return this.authRequestHandler.updateTenant(tenantId, tenantOptions)
	            .then((response) => {
	            return new tenant_1.Tenant(response);
	        });
	    }
	}
	tenantManager.TenantManager = TenantManager;
	return tenantManager;
}

var projectConfigManager = {};

/*! firebase-admin v12.7.0 */

var hasRequiredProjectConfigManager;

function requireProjectConfigManager () {
	if (hasRequiredProjectConfigManager) return projectConfigManager;
	hasRequiredProjectConfigManager = 1;
	Object.defineProperty(projectConfigManager, "__esModule", { value: true });
	projectConfigManager.ProjectConfigManager = void 0;
	const project_config_1 = /*@__PURE__*/ requireProjectConfig();
	const auth_api_request_1 = /*@__PURE__*/ requireAuthApiRequest();
	/**
	 * Manages (gets and updates) the current project config.
	 */
	class ProjectConfigManager {
	    /**
	     * Initializes a ProjectConfigManager instance for a specified FirebaseApp.
	     *
	     * @param app - The app for this ProjectConfigManager instance.
	     *
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
	    }
	    /**
	     * Get the project configuration.
	     *
	     * @returns A promise fulfilled with the project configuration.
	     */
	    getProjectConfig() {
	        return this.authRequestHandler.getProjectConfig()
	            .then((response) => {
	            return new project_config_1.ProjectConfig(response);
	        });
	    }
	    /**
	     * Updates an existing project configuration.
	     *
	     * @param projectConfigOptions - The properties to update on the project.
	     *
	     * @returns A promise fulfilled with the updated project config.
	     */
	    updateProjectConfig(projectConfigOptions) {
	        return this.authRequestHandler.updateProjectConfig(projectConfigOptions)
	            .then((response) => {
	            return new project_config_1.ProjectConfig(response);
	        });
	    }
	}
	projectConfigManager.ProjectConfigManager = ProjectConfigManager;
	return projectConfigManager;
}

/*! firebase-admin v12.7.0 */

var hasRequiredAuth$1;

function requireAuth$1 () {
	if (hasRequiredAuth$1) return auth$1;
	hasRequiredAuth$1 = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(auth$1, "__esModule", { value: true });
	auth$1.Auth = void 0;
	const auth_api_request_1 = /*@__PURE__*/ requireAuthApiRequest();
	const tenant_manager_1 = /*@__PURE__*/ requireTenantManager();
	const base_auth_1 = /*@__PURE__*/ requireBaseAuth();
	const project_config_manager_1 = /*@__PURE__*/ requireProjectConfigManager();
	/**
	 * Auth service bound to the provided app.
	 * An Auth instance can have multiple tenants.
	 */
	class Auth extends base_auth_1.BaseAuth {
	    /**
	     * @param app - The app for this Auth service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        super(app, new auth_api_request_1.AuthRequestHandler(app));
	        this.app_ = app;
	        this.tenantManager_ = new tenant_manager_1.TenantManager(app);
	        this.projectConfigManager_ = new project_config_manager_1.ProjectConfigManager(app);
	    }
	    /**
	     * Returns the app associated with this Auth instance.
	     *
	     * @returns The app associated with this Auth instance.
	     */
	    get app() {
	        return this.app_;
	    }
	    /**
	     * Returns the tenant manager instance associated with the current project.
	     *
	     * @returns The tenant manager instance associated with the current project.
	     */
	    tenantManager() {
	        return this.tenantManager_;
	    }
	    /**
	     * Returns the project config manager instance associated with the current project.
	     *
	     * @returns The project config manager instance associated with the current project.
	     */
	    projectConfigManager() {
	        return this.projectConfigManager_;
	    }
	}
	auth$1.Auth = Auth;
	return auth$1;
}

const require$$4 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(standalone);

var messaging$1 = {};

var messagingInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredMessagingInternal;

function requireMessagingInternal () {
	if (hasRequiredMessagingInternal) return messagingInternal;
	hasRequiredMessagingInternal = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(messagingInternal, "__esModule", { value: true });
	messagingInternal.validateMessage = messagingInternal.BLACKLISTED_OPTIONS_KEYS = messagingInternal.BLACKLISTED_DATA_PAYLOAD_KEYS = void 0;
	const index_1 = utils$1;
	const error_1 = error;
	const validator = validator$2;
	// Keys which are not allowed in the messaging data payload object.
	messagingInternal.BLACKLISTED_DATA_PAYLOAD_KEYS = ['from'];
	// Keys which are not allowed in the messaging options object.
	messagingInternal.BLACKLISTED_OPTIONS_KEYS = [
	    'condition', 'data', 'notification', 'registrationIds', 'registration_ids', 'to',
	];
	/**
	 * Checks if the given Message object is valid. Recursively validates all the child objects
	 * included in the message (android, apns, data etc.). If successful, transforms the message
	 * in place by renaming the keys to what's expected by the remote FCM service.
	 *
	 * @param {Message} Message An object to be validated.
	 */
	function validateMessage(message) {
	    if (!validator.isNonNullObject(message)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Message must be a non-null object');
	    }
	    const anyMessage = message;
	    if (anyMessage.topic) {
	        // If the topic name is prefixed, remove it.
	        if (anyMessage.topic.startsWith('/topics/')) {
	            anyMessage.topic = anyMessage.topic.replace(/^\/topics\//, '');
	        }
	        // Checks for illegal characters and empty string.
	        if (!/^[a-zA-Z0-9-_.~%]+$/.test(anyMessage.topic)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Malformed topic name');
	        }
	    }
	    const targets = [anyMessage.token, anyMessage.topic, anyMessage.condition];
	    if (targets.filter((v) => validator.isNonEmptyString(v)).length !== 1) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Exactly one of topic, token or condition is required');
	    }
	    validateStringMap(message.data, 'data');
	    validateAndroidConfig(message.android);
	    validateWebpushConfig(message.webpush);
	    validateApnsConfig(message.apns);
	    validateFcmOptions(message.fcmOptions);
	    validateNotification(message.notification);
	}
	messagingInternal.validateMessage = validateMessage;
	/**
	 * Checks if the given object only contains strings as child values.
	 *
	 * @param {object} map An object to be validated.
	 * @param {string} label A label to be included in the errors thrown.
	 */
	function validateStringMap(map, label) {
	    if (typeof map === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(map)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `${label} must be a non-null object`);
	    }
	    Object.keys(map).forEach((key) => {
	        if (!validator.isString(map[key])) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `${label} must only contain string values`);
	        }
	    });
	}
	/**
	 * Checks if the given WebpushConfig object is valid. The object must have valid headers and data.
	 *
	 * @param {WebpushConfig} config An object to be validated.
	 */
	function validateWebpushConfig(config) {
	    if (typeof config === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(config)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'webpush must be a non-null object');
	    }
	    validateStringMap(config.headers, 'webpush.headers');
	    validateStringMap(config.data, 'webpush.data');
	}
	/**
	 * Checks if the given ApnsConfig object is valid. The object must have valid headers and a
	 * payload.
	 *
	 * @param {ApnsConfig} config An object to be validated.
	 */
	function validateApnsConfig(config) {
	    if (typeof config === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(config)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns must be a non-null object');
	    }
	    validateStringMap(config.headers, 'apns.headers');
	    validateApnsPayload(config.payload);
	    validateApnsFcmOptions(config.fcmOptions);
	}
	/**
	 * Checks if the given ApnsFcmOptions object is valid.
	 *
	 * @param {ApnsFcmOptions} fcmOptions An object to be validated.
	 */
	function validateApnsFcmOptions(fcmOptions) {
	    if (typeof fcmOptions === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(fcmOptions)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');
	    }
	    if (typeof fcmOptions.imageUrl !== 'undefined' &&
	        !validator.isURL(fcmOptions.imageUrl)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'imageUrl must be a valid URL string');
	    }
	    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');
	    }
	    const propertyMappings = {
	        imageUrl: 'image',
	    };
	    Object.keys(propertyMappings).forEach((key) => {
	        if (key in fcmOptions && propertyMappings[key] in fcmOptions) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Multiple specifications for ${key} in ApnsFcmOptions`);
	        }
	    });
	    (0, index_1.renameProperties)(fcmOptions, propertyMappings);
	}
	/**
	 * Checks if the given FcmOptions object is valid.
	 *
	 * @param {FcmOptions} fcmOptions An object to be validated.
	 */
	function validateFcmOptions(fcmOptions) {
	    if (typeof fcmOptions === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(fcmOptions)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');
	    }
	    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');
	    }
	}
	/**
	 * Checks if the given Notification object is valid.
	 *
	 * @param {Notification} notification An object to be validated.
	 */
	function validateNotification(notification) {
	    if (typeof notification === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(notification)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'notification must be a non-null object');
	    }
	    if (typeof notification.imageUrl !== 'undefined' && !validator.isURL(notification.imageUrl)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'notification.imageUrl must be a valid URL string');
	    }
	    const propertyMappings = {
	        imageUrl: 'image',
	    };
	    Object.keys(propertyMappings).forEach((key) => {
	        if (key in notification && propertyMappings[key] in notification) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Multiple specifications for ${key} in Notification`);
	        }
	    });
	    (0, index_1.renameProperties)(notification, propertyMappings);
	}
	/**
	 * Checks if the given ApnsPayload object is valid. The object must have a valid aps value.
	 *
	 * @param {ApnsPayload} payload An object to be validated.
	 */
	function validateApnsPayload(payload) {
	    if (typeof payload === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(payload)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload must be a non-null object');
	    }
	    validateAps(payload.aps);
	}
	/**
	 * Checks if the given Aps object is valid. The object must have a valid alert. If the validation
	 * is successful, transforms the input object by renaming the keys to valid APNS payload keys.
	 *
	 * @param {Aps} aps An object to be validated.
	 */
	function validateAps(aps) {
	    if (typeof aps === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(aps)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps must be a non-null object');
	    }
	    validateApsAlert(aps.alert);
	    validateApsSound(aps.sound);
	    const propertyMappings = {
	        contentAvailable: 'content-available',
	        mutableContent: 'mutable-content',
	        threadId: 'thread-id',
	    };
	    Object.keys(propertyMappings).forEach((key) => {
	        if (key in aps && propertyMappings[key] in aps) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Multiple specifications for ${key} in Aps`);
	        }
	    });
	    (0, index_1.renameProperties)(aps, propertyMappings);
	    const contentAvailable = aps['content-available'];
	    if (typeof contentAvailable !== 'undefined' && contentAvailable !== 1) {
	        if (contentAvailable === true) {
	            aps['content-available'] = 1;
	        }
	        else {
	            delete aps['content-available'];
	        }
	    }
	    const mutableContent = aps['mutable-content'];
	    if (typeof mutableContent !== 'undefined' && mutableContent !== 1) {
	        if (mutableContent === true) {
	            aps['mutable-content'] = 1;
	        }
	        else {
	            delete aps['mutable-content'];
	        }
	    }
	}
	function validateApsSound(sound) {
	    if (typeof sound === 'undefined' || validator.isNonEmptyString(sound)) {
	        return;
	    }
	    else if (!validator.isNonNullObject(sound)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound must be a non-empty string or a non-null object');
	    }
	    if (!validator.isNonEmptyString(sound.name)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.name must be a non-empty string');
	    }
	    const volume = sound.volume;
	    if (typeof volume !== 'undefined') {
	        if (!validator.isNumber(volume)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be a number');
	        }
	        if (volume < 0 || volume > 1) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be in the interval [0, 1]');
	        }
	    }
	    const soundObject = sound;
	    const key = 'critical';
	    const critical = soundObject[key];
	    if (typeof critical !== 'undefined' && critical !== 1) {
	        if (critical === true) {
	            soundObject[key] = 1;
	        }
	        else {
	            delete soundObject[key];
	        }
	    }
	}
	/**
	 * Checks if the given alert object is valid. Alert could be a string or a complex object.
	 * If specified as an object, it must have valid localization parameters. If successful, transforms
	 * the input object by renaming the keys to valid APNS payload keys.
	 *
	 * @param {string | ApsAlert} alert An alert string or an object to be validated.
	 */
	function validateApsAlert(alert) {
	    if (typeof alert === 'undefined' || validator.isString(alert)) {
	        return;
	    }
	    else if (!validator.isNonNullObject(alert)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert must be a string or a non-null object');
	    }
	    const apsAlert = alert;
	    if (validator.isNonEmptyArray(apsAlert.locArgs) &&
	        !validator.isNonEmptyString(apsAlert.locKey)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.locKey is required when specifying locArgs');
	    }
	    if (validator.isNonEmptyArray(apsAlert.titleLocArgs) &&
	        !validator.isNonEmptyString(apsAlert.titleLocKey)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.titleLocKey is required when specifying titleLocArgs');
	    }
	    if (validator.isNonEmptyArray(apsAlert.subtitleLocArgs) &&
	        !validator.isNonEmptyString(apsAlert.subtitleLocKey)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.subtitleLocKey is required when specifying subtitleLocArgs');
	    }
	    const propertyMappings = {
	        locKey: 'loc-key',
	        locArgs: 'loc-args',
	        titleLocKey: 'title-loc-key',
	        titleLocArgs: 'title-loc-args',
	        subtitleLocKey: 'subtitle-loc-key',
	        subtitleLocArgs: 'subtitle-loc-args',
	        actionLocKey: 'action-loc-key',
	        launchImage: 'launch-image',
	    };
	    (0, index_1.renameProperties)(apsAlert, propertyMappings);
	}
	/**
	 * Checks if the given AndroidConfig object is valid. The object must have valid ttl, data,
	 * and notification fields. If successful, transforms the input object by renaming keys to valid
	 * Android keys. Also transforms the ttl value to the format expected by FCM service.
	 *
	 * @param config - An object to be validated.
	 */
	function validateAndroidConfig(config) {
	    if (typeof config === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(config)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android must be a non-null object');
	    }
	    if (typeof config.ttl !== 'undefined') {
	        if (!validator.isNumber(config.ttl) || config.ttl < 0) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'TTL must be a non-negative duration in milliseconds');
	        }
	        const duration = (0, index_1.transformMillisecondsToSecondsString)(config.ttl);
	        config.ttl = duration;
	    }
	    validateStringMap(config.data, 'android.data');
	    validateAndroidNotification(config.notification);
	    validateAndroidFcmOptions(config.fcmOptions);
	    const propertyMappings = {
	        collapseKey: 'collapse_key',
	        restrictedPackageName: 'restricted_package_name',
	    };
	    (0, index_1.renameProperties)(config, propertyMappings);
	}
	/**
	 * Checks if the given AndroidNotification object is valid. The object must have valid color and
	 * localization parameters. If successful, transforms the input object by renaming keys to valid
	 * Android keys.
	 *
	 * @param {AndroidNotification} notification An object to be validated.
	 */
	function validateAndroidNotification(notification) {
	    if (typeof notification === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(notification)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification must be a non-null object');
	    }
	    if (typeof notification.color !== 'undefined' && !/^#[0-9a-fA-F]{6}$/.test(notification.color)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.color must be in the form #RRGGBB');
	    }
	    if (validator.isNonEmptyArray(notification.bodyLocArgs) &&
	        !validator.isNonEmptyString(notification.bodyLocKey)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.bodyLocKey is required when specifying bodyLocArgs');
	    }
	    if (validator.isNonEmptyArray(notification.titleLocArgs) &&
	        !validator.isNonEmptyString(notification.titleLocKey)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.titleLocKey is required when specifying titleLocArgs');
	    }
	    if (typeof notification.imageUrl !== 'undefined' &&
	        !validator.isURL(notification.imageUrl)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.imageUrl must be a valid URL string');
	    }
	    if (typeof notification.eventTimestamp !== 'undefined') {
	        if (!(notification.eventTimestamp instanceof Date)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.eventTimestamp must be a valid `Date` object');
	        }
	        // Convert timestamp to RFC3339 UTC "Zulu" format, example "2014-10-02T15:01:23.045123456Z"
	        const zuluTimestamp = notification.eventTimestamp.toISOString();
	        notification.eventTimestamp = zuluTimestamp;
	    }
	    if (typeof notification.vibrateTimingsMillis !== 'undefined') {
	        if (!validator.isNonEmptyArray(notification.vibrateTimingsMillis)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.vibrateTimingsMillis must be a non-empty array of numbers');
	        }
	        const vibrateTimings = [];
	        notification.vibrateTimingsMillis.forEach((value) => {
	            if (!validator.isNumber(value) || value < 0) {
	                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.vibrateTimingsMillis must be non-negative durations in milliseconds');
	            }
	            const duration = (0, index_1.transformMillisecondsToSecondsString)(value);
	            vibrateTimings.push(duration);
	        });
	        notification.vibrateTimingsMillis = vibrateTimings;
	    }
	    if (typeof notification.priority !== 'undefined') {
	        const priority = 'PRIORITY_' + notification.priority.toUpperCase();
	        notification.priority = priority;
	    }
	    if (typeof notification.visibility !== 'undefined') {
	        const visibility = notification.visibility.toUpperCase();
	        notification.visibility = visibility;
	    }
	    validateLightSettings(notification.lightSettings);
	    const propertyMappings = {
	        clickAction: 'click_action',
	        bodyLocKey: 'body_loc_key',
	        bodyLocArgs: 'body_loc_args',
	        titleLocKey: 'title_loc_key',
	        titleLocArgs: 'title_loc_args',
	        channelId: 'channel_id',
	        imageUrl: 'image',
	        eventTimestamp: 'event_time',
	        localOnly: 'local_only',
	        priority: 'notification_priority',
	        vibrateTimingsMillis: 'vibrate_timings',
	        defaultVibrateTimings: 'default_vibrate_timings',
	        defaultSound: 'default_sound',
	        lightSettings: 'light_settings',
	        defaultLightSettings: 'default_light_settings',
	        notificationCount: 'notification_count',
	    };
	    (0, index_1.renameProperties)(notification, propertyMappings);
	}
	/**
	 * Checks if the given LightSettings object is valid. The object must have valid color and
	 * light on/off duration parameters. If successful, transforms the input object by renaming
	 * keys to valid Android keys.
	 *
	 * @param {LightSettings} lightSettings An object to be validated.
	 */
	function validateLightSettings(lightSettings) {
	    if (typeof lightSettings === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(lightSettings)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings must be a non-null object');
	    }
	    if (!validator.isNumber(lightSettings.lightOnDurationMillis) || lightSettings.lightOnDurationMillis < 0) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.lightOnDurationMillis must be a non-negative duration in milliseconds');
	    }
	    const durationOn = (0, index_1.transformMillisecondsToSecondsString)(lightSettings.lightOnDurationMillis);
	    lightSettings.lightOnDurationMillis = durationOn;
	    if (!validator.isNumber(lightSettings.lightOffDurationMillis) || lightSettings.lightOffDurationMillis < 0) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.lightOffDurationMillis must be a non-negative duration in milliseconds');
	    }
	    const durationOff = (0, index_1.transformMillisecondsToSecondsString)(lightSettings.lightOffDurationMillis);
	    lightSettings.lightOffDurationMillis = durationOff;
	    if (!validator.isString(lightSettings.color) ||
	        (!/^#[0-9a-fA-F]{6}$/.test(lightSettings.color) && !/^#[0-9a-fA-F]{8}$/.test(lightSettings.color))) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.color must be in the form #RRGGBB or #RRGGBBAA format');
	    }
	    const colorString = lightSettings.color.length === 7 ? lightSettings.color + 'FF' : lightSettings.color;
	    const rgb = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/i.exec(colorString);
	    if (!rgb || rgb.length < 4) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INTERNAL_ERROR, 'regex to extract rgba values from ' + colorString + ' failed.');
	    }
	    const color = {
	        red: parseInt(rgb[1], 16) / 255.0,
	        green: parseInt(rgb[2], 16) / 255.0,
	        blue: parseInt(rgb[3], 16) / 255.0,
	        alpha: parseInt(rgb[4], 16) / 255.0,
	    };
	    lightSettings.color = color;
	    const propertyMappings = {
	        lightOnDurationMillis: 'light_on_duration',
	        lightOffDurationMillis: 'light_off_duration',
	    };
	    (0, index_1.renameProperties)(lightSettings, propertyMappings);
	}
	/**
	 * Checks if the given AndroidFcmOptions object is valid.
	 *
	 * @param {AndroidFcmOptions} fcmOptions An object to be validated.
	 */
	function validateAndroidFcmOptions(fcmOptions) {
	    if (typeof fcmOptions === 'undefined') {
	        return;
	    }
	    else if (!validator.isNonNullObject(fcmOptions)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');
	    }
	    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {
	        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');
	    }
	}
	return messagingInternal;
}

var messagingApiRequestInternal = {};

var messagingErrorsInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredMessagingErrorsInternal;

function requireMessagingErrorsInternal () {
	if (hasRequiredMessagingErrorsInternal) return messagingErrorsInternal;
	hasRequiredMessagingErrorsInternal = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(messagingErrorsInternal, "__esModule", { value: true });
	messagingErrorsInternal.getErrorCode = messagingErrorsInternal.createFirebaseError = void 0;
	const error_1 = error;
	const validator = validator$2;
	/**
	 * Creates a new `FirebaseMessagingError` by extracting the error code, message and other relevant
	 * details from a `RequestResponseError` response.
	 *
	 * @param err - The `RequestResponseError` to convert into a Firebase error
	 * @returns A Firebase error that can be returned to the user.
	 */
	function createFirebaseError(err) {
	    if (err.response.isJson()) {
	        // For JSON responses, map the server response to a client-side error.
	        const json = err.response.data;
	        const errorCode = getErrorCode(json);
	        const errorMessage = getErrorMessage(json);
	        return error_1.FirebaseMessagingError.fromServerError(errorCode, errorMessage, json);
	    }
	    // Non-JSON response
	    let error;
	    switch (err.response.status) {
	        case 400:
	            error = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;
	            break;
	        case 401:
	        case 403:
	            error = error_1.MessagingClientErrorCode.AUTHENTICATION_ERROR;
	            break;
	        case 500:
	            error = error_1.MessagingClientErrorCode.INTERNAL_ERROR;
	            break;
	        case 503:
	            error = error_1.MessagingClientErrorCode.SERVER_UNAVAILABLE;
	            break;
	        default:
	            // Treat non-JSON responses with unexpected status codes as unknown errors.
	            error = error_1.MessagingClientErrorCode.UNKNOWN_ERROR;
	    }
	    return new error_1.FirebaseMessagingError({
	        code: error.code,
	        message: `${error.message} Raw server response: "${err.response.text}". Status code: ` +
	            `${err.response.status}.`,
	    });
	}
	messagingErrorsInternal.createFirebaseError = createFirebaseError;
	/**
	 * @param response - The response to check for errors.
	 * @returns The error code if present; null otherwise.
	 */
	function getErrorCode(response) {
	    if (validator.isNonNullObject(response) && 'error' in response) {
	        const error = response.error;
	        if (validator.isString(error)) {
	            return error;
	        }
	        if (validator.isArray(error.details)) {
	            const fcmErrorType = 'type.googleapis.com/google.firebase.fcm.v1.FcmError';
	            for (const element of error.details) {
	                if (element['@type'] === fcmErrorType) {
	                    return element.errorCode;
	                }
	            }
	        }
	        if ('status' in error) {
	            return error.status;
	        }
	        else {
	            return error.message;
	        }
	    }
	    return null;
	}
	messagingErrorsInternal.getErrorCode = getErrorCode;
	/**
	 * Extracts error message from the given response object.
	 *
	 * @param response - The response to check for errors.
	 * @returns The error message if present; null otherwise.
	 */
	function getErrorMessage(response) {
	    if (validator.isNonNullObject(response) &&
	        'error' in response &&
	        validator.isNonEmptyString(response.error.message)) {
	        return response.error.message;
	    }
	    return null;
	}
	return messagingErrorsInternal;
}

var batchRequestInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredBatchRequestInternal;

function requireBatchRequestInternal () {
	if (hasRequiredBatchRequestInternal) return batchRequestInternal;
	hasRequiredBatchRequestInternal = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(batchRequestInternal, "__esModule", { value: true });
	batchRequestInternal.BatchRequestClient = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const error_1 = error;
	const PART_BOUNDARY = '__END_OF_PART__';
	const TEN_SECONDS_IN_MILLIS = 15000;
	/**
	 * An HTTP client that can be used to make batch requests. This client is not tied to any service
	 * (FCM or otherwise). Therefore it can be used to make batch requests to any service that allows
	 * it. If this requirement ever arises we can move this implementation to the utils module
	 * where it can be easily shared among other modules.
	 */
	class BatchRequestClient {
	    /**
	     * @param {HttpClient} httpClient The client that will be used to make HTTP calls.
	     * @param {string} batchUrl The URL that accepts batch requests.
	     * @param {object=} commonHeaders Optional headers that will be included in all requests.
	     *
	     * @constructor
	     */
	    constructor(httpClient, batchUrl, commonHeaders) {
	        this.httpClient = httpClient;
	        this.batchUrl = batchUrl;
	        this.commonHeaders = commonHeaders;
	    }
	    /**
	     * Sends the given array of sub requests as a single batch, and parses the results into an array
	     * of `RequestResponse` objects.
	     *
	     * @param requests - An array of sub requests to send.
	     * @returns A promise that resolves when the send operation is complete.
	     */
	    send(requests) {
	        requests = requests.map((req) => {
	            req.headers = Object.assign({}, this.commonHeaders, req.headers);
	            return req;
	        });
	        const requestHeaders = {
	            'Content-Type': `multipart/mixed; boundary=${PART_BOUNDARY}`,
	        };
	        const request = {
	            method: 'POST',
	            url: this.batchUrl,
	            data: this.getMultipartPayload(requests),
	            headers: Object.assign({}, this.commonHeaders, requestHeaders),
	            timeout: TEN_SECONDS_IN_MILLIS,
	        };
	        return this.httpClient.send(request).then((response) => {
	            if (!response.multipart) {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a multipart response.');
	            }
	            return response.multipart.map((buff) => {
	                return (0, api_request_1.parseHttpResponse)(buff, request);
	            });
	        });
	    }
	    getMultipartPayload(requests) {
	        let buffer = '';
	        requests.forEach((request, idx) => {
	            buffer += createPart(request, PART_BOUNDARY, idx);
	        });
	        buffer += `--${PART_BOUNDARY}--\r\n`;
	        return Buffer.from(buffer, 'utf-8');
	    }
	}
	batchRequestInternal.BatchRequestClient = BatchRequestClient;
	/**
	 * Creates a single part in a multipart HTTP request body. The part consists of several headers
	 * followed by the serialized sub request as the body. As per the requirements of the FCM batch
	 * API, sets the content-type header to application/http, and the content-transfer-encoding to
	 * binary.
	 *
	 * @param request - A sub request that will be used to populate the part.
	 * @param boundary - Multipart boundary string.
	 * @param idx - An index number that is used to set the content-id header.
	 * @returns The part as a string that can be included in the HTTP body.
	 */
	function createPart(request, boundary, idx) {
	    const serializedRequest = serializeSubRequest(request);
	    let part = `--${boundary}\r\n`;
	    part += `Content-Length: ${serializedRequest.length}\r\n`;
	    part += 'Content-Type: application/http\r\n';
	    part += `content-id: ${idx + 1}\r\n`;
	    part += 'content-transfer-encoding: binary\r\n';
	    part += '\r\n';
	    part += `${serializedRequest}\r\n`;
	    return part;
	}
	/**
	 * Serializes a sub request into a string that can be embedded in a multipart HTTP request. The
	 * format of the string is the wire format of a typical HTTP request, consisting of a header and a
	 * body.
	 *
	 * @param request - The sub request to be serialized.
	 * @returns String representation of the SubRequest.
	 */
	function serializeSubRequest(request) {
	    const requestBody = JSON.stringify(request.body);
	    let messagePayload = `POST ${request.url} HTTP/1.1\r\n`;
	    messagePayload += `Content-Length: ${requestBody.length}\r\n`;
	    messagePayload += 'Content-Type: application/json; charset=UTF-8\r\n';
	    if (request.headers) {
	        Object.keys(request.headers).forEach((key) => {
	            messagePayload += `${key}: ${request.headers[key]}\r\n`;
	        });
	    }
	    messagePayload += '\r\n';
	    messagePayload += requestBody;
	    return messagePayload;
	}
	return batchRequestInternal;
}

/*! firebase-admin v12.7.0 */

var hasRequiredMessagingApiRequestInternal;

function requireMessagingApiRequestInternal () {
	if (hasRequiredMessagingApiRequestInternal) return messagingApiRequestInternal;
	hasRequiredMessagingApiRequestInternal = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(messagingApiRequestInternal, "__esModule", { value: true });
	messagingApiRequestInternal.FirebaseMessagingRequestHandler = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const messaging_errors_internal_1 = /*@__PURE__*/ requireMessagingErrorsInternal();
	const batch_request_internal_1 = /*@__PURE__*/ requireBatchRequestInternal();
	const index_1 = utils$1;
	// FCM backend constants
	const FIREBASE_MESSAGING_TIMEOUT = 15000;
	const FIREBASE_MESSAGING_BATCH_URL = 'https://fcm.googleapis.com/batch';
	const FIREBASE_MESSAGING_HTTP_METHOD = 'POST';
	const FIREBASE_MESSAGING_HEADERS = {
	    'X-Firebase-Client': `fire-admin-node/${(0, index_1.getSdkVersion)()}`,
	    'X-Goog-Api-Client': `gl-node/${process.versions.node} fire-admin/${(0, index_1.getSdkVersion)()}`
	};
	const LEGACY_FIREBASE_MESSAGING_HEADERS = {
	    'X-Firebase-Client': `fire-admin-node/${(0, index_1.getSdkVersion)()}`,
	    'X-Goog-Api-Client': `gl-node/${process.versions.node} fire-admin/${(0, index_1.getSdkVersion)()}`,
	    'access_token_auth': 'true',
	};
	/**
	 * Class that provides a mechanism to send requests to the Firebase Cloud Messaging backend.
	 */
	class FirebaseMessagingRequestHandler {
	    /**
	     * @param app - The app used to fetch access tokens to sign API requests.
	     * @constructor
	     */
	    constructor(app) {
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	        this.http2Client = new api_request_1.AuthorizedHttp2Client(app);
	        this.batchClient = new batch_request_internal_1.BatchRequestClient(this.httpClient, FIREBASE_MESSAGING_BATCH_URL, FIREBASE_MESSAGING_HEADERS);
	    }
	    /**
	     * Invokes the request handler with the provided request data.
	     *
	     * @param host - The host to which to send the request.
	     * @param path - The path to which to send the request.
	     * @param requestData - The request data.
	     * @returns A promise that resolves with the response.
	     */
	    invokeRequestHandler(host, path, requestData) {
	        const request = {
	            method: FIREBASE_MESSAGING_HTTP_METHOD,
	            url: `https://${host}${path}`,
	            data: requestData,
	            headers: LEGACY_FIREBASE_MESSAGING_HEADERS,
	            timeout: FIREBASE_MESSAGING_TIMEOUT,
	        };
	        return this.httpClient.send(request).then((response) => {
	            // Send non-JSON responses to the catch() below where they will be treated as errors.
	            if (!response.isJson()) {
	                throw new api_request_1.RequestResponseError(response);
	            }
	            // Check for backend errors in the response.
	            const errorCode = (0, messaging_errors_internal_1.getErrorCode)(response.data);
	            if (errorCode) {
	                throw new api_request_1.RequestResponseError(response);
	            }
	            // Return entire response.
	            return response.data;
	        })
	            .catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                throw (0, messaging_errors_internal_1.createFirebaseError)(err);
	            }
	            // Re-throw the error if it already has the proper format.
	            throw err;
	        });
	    }
	    /**
	     * Invokes the HTTP/1.1 request handler with the provided request data.
	     *
	     * @param host - The host to which to send the request.
	     * @param path - The path to which to send the request.
	     * @param requestData - The request data.
	     * @returns A promise that resolves with the {@link SendResponse}.
	     */
	    invokeHttpRequestHandlerForSendResponse(host, path, requestData) {
	        const request = {
	            method: FIREBASE_MESSAGING_HTTP_METHOD,
	            url: `https://${host}${path}`,
	            data: requestData,
	            headers: LEGACY_FIREBASE_MESSAGING_HEADERS,
	            timeout: FIREBASE_MESSAGING_TIMEOUT,
	        };
	        return this.httpClient.send(request).then((response) => {
	            return this.buildSendResponse(response);
	        })
	            .catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                return this.buildSendResponseFromError(err);
	            }
	            // Re-throw the error if it already has the proper format.
	            throw err;
	        });
	    }
	    /**
	     * Invokes the HTTP/2 request handler with the provided request data.
	     *
	     * @param host - The host to which to send the request.
	     * @param path - The path to which to send the request.
	     * @param requestData - The request data.
	     * @returns A promise that resolves with the {@link SendResponse}.
	     */
	    invokeHttp2RequestHandlerForSendResponse(host, path, requestData, http2SessionHandler) {
	        const request = {
	            method: FIREBASE_MESSAGING_HTTP_METHOD,
	            url: `https://${host}${path}`,
	            data: requestData,
	            headers: LEGACY_FIREBASE_MESSAGING_HEADERS,
	            timeout: FIREBASE_MESSAGING_TIMEOUT,
	            http2SessionHandler: http2SessionHandler
	        };
	        return this.http2Client.send(request).then((response) => {
	            return this.buildSendResponse(response);
	        })
	            .catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                return this.buildSendResponseFromError(err);
	            }
	            // Re-throw the error if it already has the proper format.
	            throw err;
	        });
	    }
	    /**
	     * Sends the given array of sub requests as a single batch to FCM, and parses the result into
	     * a `BatchResponse` object.
	     *
	     * @param requests - An array of sub requests to send.
	     * @returns A promise that resolves when the send operation is complete.
	     */
	    sendBatchRequest(requests) {
	        return this.batchClient.send(requests)
	            .then((responses) => {
	            return responses.map((part) => {
	                return this.buildSendResponse(part);
	            });
	        }).then((responses) => {
	            const successCount = responses.filter((resp) => resp.success).length;
	            return {
	                responses,
	                successCount,
	                failureCount: responses.length - successCount,
	            };
	        }).catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                throw (0, messaging_errors_internal_1.createFirebaseError)(err);
	            }
	            // Re-throw the error if it already has the proper format.
	            throw err;
	        });
	    }
	    buildSendResponse(response) {
	        const result = {
	            success: response.status === 200,
	        };
	        if (result.success) {
	            result.messageId = response.data.name;
	        }
	        else {
	            result.error = (0, messaging_errors_internal_1.createFirebaseError)(new api_request_1.RequestResponseError(response));
	        }
	        return result;
	    }
	    buildSendResponseFromError(err) {
	        return {
	            success: false,
	            error: (0, messaging_errors_internal_1.createFirebaseError)(err)
	        };
	    }
	}
	messagingApiRequestInternal.FirebaseMessagingRequestHandler = FirebaseMessagingRequestHandler;
	return messagingApiRequestInternal;
}

/*! firebase-admin v12.7.0 */

var hasRequiredMessaging$1;

function requireMessaging$1 () {
	if (hasRequiredMessaging$1) return messaging$1;
	hasRequiredMessaging$1 = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(messaging$1, "__esModule", { value: true });
	messaging$1.Messaging = void 0;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const error_1 = error;
	const utils = utils$1;
	const validator = validator$2;
	const messaging_internal_1 = /*@__PURE__*/ requireMessagingInternal();
	const messaging_api_request_internal_1 = /*@__PURE__*/ requireMessagingApiRequestInternal();
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	// FCM endpoints
	const FCM_SEND_HOST = 'fcm.googleapis.com';
	const FCM_SEND_PATH = '/fcm/send';
	const FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';
	const FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';
	const FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';
	// Maximum messages that can be included in a batch request.
	const FCM_MAX_BATCH_SIZE = 500;
	// Key renames for the messaging notification payload object.
	const CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = {
	    bodyLocArgs: 'body_loc_args',
	    bodyLocKey: 'body_loc_key',
	    clickAction: 'click_action',
	    titleLocArgs: 'title_loc_args',
	    titleLocKey: 'title_loc_key',
	};
	// Key renames for the messaging options object.
	const CAMELCASE_OPTIONS_KEYS_MAP = {
	    dryRun: 'dry_run',
	    timeToLive: 'time_to_live',
	    collapseKey: 'collapse_key',
	    mutableContent: 'mutable_content',
	    contentAvailable: 'content_available',
	    restrictedPackageName: 'restricted_package_name',
	};
	// Key renames for the MessagingDeviceResult object.
	const MESSAGING_DEVICE_RESULT_KEYS_MAP = {
	    message_id: 'messageId',
	    registration_id: 'canonicalRegistrationToken',
	};
	// Key renames for the MessagingDevicesResponse object.
	const MESSAGING_DEVICES_RESPONSE_KEYS_MAP = {
	    canonical_ids: 'canonicalRegistrationTokenCount',
	    failure: 'failureCount',
	    success: 'successCount',
	    multicast_id: 'multicastId',
	};
	// Key renames for the MessagingDeviceGroupResponse object.
	const MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = {
	    success: 'successCount',
	    failure: 'failureCount',
	    failed_registration_ids: 'failedRegistrationTokens',
	};
	// Key renames for the MessagingTopicResponse object.
	const MESSAGING_TOPIC_RESPONSE_KEYS_MAP = {
	    message_id: 'messageId',
	};
	// Key renames for the MessagingConditionResponse object.
	const MESSAGING_CONDITION_RESPONSE_KEYS_MAP = {
	    message_id: 'messageId',
	};
	/**
	 * Maps a raw FCM server response to a `MessagingDevicesResponse` object.
	 *
	 * @param response - The raw FCM server response to map.
	 *
	 * @returns The mapped `MessagingDevicesResponse` object.
	 */
	function mapRawResponseToDevicesResponse(response) {
	    // Rename properties on the server response
	    utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);
	    if ('results' in response) {
	        response.results.forEach((messagingDeviceResult) => {
	            utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP);
	            // Map the FCM server's error strings to actual error objects.
	            if ('error' in messagingDeviceResult) {
	                const newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error, /* message */ undefined, messagingDeviceResult.error);
	                messagingDeviceResult.error = newError;
	            }
	        });
	    }
	    return response;
	}
	/**
	 * Maps a raw FCM server response to a `MessagingDeviceGroupResponse` object.
	 *
	 * @param response - The raw FCM server response to map.
	 *
	 * @returns The mapped `MessagingDeviceGroupResponse` object.
	 */
	function mapRawResponseToDeviceGroupResponse(response) {
	    // Rename properties on the server response
	    utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP);
	    // Add the 'failedRegistrationTokens' property if it does not exist on the response, which
	    // it won't when the 'failureCount' property has a value of 0)
	    response.failedRegistrationTokens = response.failedRegistrationTokens || [];
	    return response;
	}
	/**
	 * Maps a raw FCM server response to a `MessagingTopicManagementResponse` object.
	 *
	 * @param {object} response The raw FCM server response to map.
	 *
	 * @returns {MessagingTopicManagementResponse} The mapped `MessagingTopicManagementResponse` object.
	 */
	function mapRawResponseToTopicManagementResponse(response) {
	    // Add the success and failure counts.
	    const result = {
	        successCount: 0,
	        failureCount: 0,
	        errors: [],
	    };
	    if ('results' in response) {
	        response.results.forEach((tokenManagementResult, index) => {
	            // Map the FCM server's error strings to actual error objects.
	            if ('error' in tokenManagementResult) {
	                result.failureCount += 1;
	                const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */ undefined, tokenManagementResult.error);
	                result.errors.push({
	                    index,
	                    error: newError,
	                });
	            }
	            else {
	                result.successCount += 1;
	            }
	        });
	    }
	    return result;
	}
	/**
	 * Messaging service bound to the provided app.
	 */
	class Messaging {
	    /**
	     * @internal
	     */
	    constructor(app) {
	        this.useLegacyTransport = false;
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');
	        }
	        this.appInternal = app;
	        this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);
	    }
	    /**
	     * The {@link firebase-admin.app#App} associated with the current `Messaging` service
	     * instance.
	     *
	     * @example
	     * ```javascript
	     * var app = messaging.app;
	     * ```
	     */
	    get app() {
	        return this.appInternal;
	    }
	    /**
	     * Enables the use of legacy HTTP/1.1 transport for `sendEach()` and `sendEachForMulticast()`.
	     *
	     * @example
	     * ```javascript
	     * const messaging = getMessaging(app);
	     * messaging.enableLegacyTransport();
	     * messaging.sendEach(messages);
	     * ```
	     *
	     * @deprecated This will be removed when the HTTP/2 transport implementation reaches the same
	     * stability as the legacy HTTP/1.1 implementation.
	     */
	    enableLegacyHttpTransport() {
	        this.useLegacyTransport = true;
	    }
	    /**
	     * Sends the given message via FCM.
	     *
	     * @param message - The message payload.
	     * @param dryRun - Whether to send the message in the dry-run
	     *   (validation only) mode.
	     * @returns A promise fulfilled with a unique message ID
	     *   string after the message has been successfully handed off to the FCM
	     *   service for delivery.
	     */
	    send(message, dryRun) {
	        const copy = (0, deep_copy_1.deepCopy)(message);
	        (0, messaging_internal_1.validateMessage)(copy);
	        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');
	        }
	        return this.getUrlPath()
	            .then((urlPath) => {
	            const request = { message: copy };
	            if (dryRun) {
	                request.validate_only = true;
	            }
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);
	        })
	            .then((response) => {
	            return response.name;
	        });
	    }
	    /**
	    * Sends each message in the given array via Firebase Cloud Messaging.
	    *
	    * Unlike {@link Messaging.sendAll}, this method makes a single RPC call for each message
	    * in the given array.
	    *
	    * The responses list obtained from the return value corresponds to the order of `messages`.
	    * An error from this method or a `BatchResponse` with all failures indicates a total failure,
	    * meaning that none of the messages in the list could be sent. Partial failures or no
	    * failures are only indicated by a `BatchResponse` return value.
	    *
	    * @param messages - A non-empty array
	    *   containing up to 500 messages.
	    * @param dryRun - Whether to send the messages in the dry-run
	    *   (validation only) mode.
	    * @returns A Promise fulfilled with an object representing the result of the
	    *   send operation.
	    */
	    sendEach(messages, dryRun) {
	        if (validator.isArray(messages) && messages.constructor !== Array) {
	            // In more recent JS specs, an array-like object might have a constructor that is not of
	            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to
	            // a regular array here before calling deepCopy(). See issue #566 for details.
	            messages = Array.from(messages);
	        }
	        const copy = (0, deep_copy_1.deepCopy)(messages);
	        if (!validator.isNonEmptyArray(copy)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');
	        }
	        if (copy.length > FCM_MAX_BATCH_SIZE) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);
	        }
	        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');
	        }
	        const http2SessionHandler = this.useLegacyTransport ? undefined : new api_request_1.Http2SessionHandler(`https://${FCM_SEND_HOST}`);
	        return this.getUrlPath()
	            .then((urlPath) => {
	            const requests = copy.map(async (message) => {
	                (0, messaging_internal_1.validateMessage)(message);
	                const request = { message };
	                if (dryRun) {
	                    request.validate_only = true;
	                }
	                if (http2SessionHandler) {
	                    return this.messagingRequestHandler.invokeHttp2RequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request, http2SessionHandler);
	                }
	                return this.messagingRequestHandler.invokeHttpRequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request);
	            });
	            return Promise.allSettled(requests);
	        })
	            .then((results) => {
	            const responses = [];
	            results.forEach(result => {
	                if (result.status === 'fulfilled') {
	                    responses.push(result.value);
	                }
	                else { // rejected
	                    responses.push({ success: false, error: result.reason });
	                }
	            });
	            const successCount = responses.filter((resp) => resp.success).length;
	            return {
	                responses,
	                successCount,
	                failureCount: responses.length - successCount,
	            };
	        })
	            .finally(() => {
	            if (http2SessionHandler) {
	                http2SessionHandler.close();
	            }
	        });
	    }
	    /**
	     * Sends the given multicast message to all the FCM registration tokens
	     * specified in it.
	     *
	     * This method uses the {@link Messaging.sendEach} API under the hood to send the given
	     * message to all the target recipients. The responses list obtained from the
	     * return value corresponds to the order of tokens in the `MulticastMessage`.
	     * An error from this method or a `BatchResponse` with all failures indicates a total
	     * failure, meaning that the messages in the list could be sent. Partial failures or
	     * failures are only indicated by a `BatchResponse` return value.
	     *
	     * @param message - A multicast message
	     *   containing up to 500 tokens.
	     * @param dryRun - Whether to send the message in the dry-run
	     *   (validation only) mode.
	     * @returns A Promise fulfilled with an object representing the result of the
	     *   send operation.
	     */
	    sendEachForMulticast(message, dryRun) {
	        const copy = (0, deep_copy_1.deepCopy)(message);
	        if (!validator.isNonNullObject(copy)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');
	        }
	        if (!validator.isNonEmptyArray(copy.tokens)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');
	        }
	        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);
	        }
	        const messages = copy.tokens.map((token) => {
	            return {
	                token,
	                android: copy.android,
	                apns: copy.apns,
	                data: copy.data,
	                notification: copy.notification,
	                webpush: copy.webpush,
	                fcmOptions: copy.fcmOptions,
	            };
	        });
	        return this.sendEach(messages, dryRun);
	    }
	    /**
	     * Sends all the messages in the given array via Firebase Cloud Messaging.
	     * Employs batching to send the entire list as a single RPC call. Compared
	     * to the `send()` method, this method is a significantly more efficient way
	     * to send multiple messages.
	     *
	     * The responses list obtained from the return value
	     * corresponds to the order of tokens in the `MulticastMessage`. An error
	     * from this method indicates a total failure, meaning that none of the messages
	     * in the list could be sent. Partial failures are indicated by a `BatchResponse`
	     * return value.
	     *
	     * @param messages - A non-empty array
	     *   containing up to 500 messages.
	     * @param dryRun - Whether to send the messages in the dry-run
	     *   (validation only) mode.
	     * @returns A Promise fulfilled with an object representing the result of the
	     *   send operation.
	     *
	     * @deprecated Use {@link Messaging.sendEach} instead.
	     */
	    sendAll(messages, dryRun) {
	        if (validator.isArray(messages) && messages.constructor !== Array) {
	            // In more recent JS specs, an array-like object might have a constructor that is not of
	            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to
	            // a regular array here before calling deepCopy(). See issue #566 for details.
	            messages = Array.from(messages);
	        }
	        const copy = (0, deep_copy_1.deepCopy)(messages);
	        if (!validator.isNonEmptyArray(copy)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');
	        }
	        if (copy.length > FCM_MAX_BATCH_SIZE) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);
	        }
	        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');
	        }
	        return this.getUrlPath()
	            .then((urlPath) => {
	            const requests = copy.map((message) => {
	                (0, messaging_internal_1.validateMessage)(message);
	                const request = { message };
	                if (dryRun) {
	                    request.validate_only = true;
	                }
	                return {
	                    url: `https://${FCM_SEND_HOST}${urlPath}`,
	                    body: request,
	                };
	            });
	            return this.messagingRequestHandler.sendBatchRequest(requests);
	        });
	    }
	    /**
	     * Sends the given multicast message to all the FCM registration tokens
	     * specified in it.
	     *
	     * This method uses the `sendAll()` API under the hood to send the given
	     * message to all the target recipients. The responses list obtained from the
	     * return value corresponds to the order of tokens in the `MulticastMessage`.
	     * An error from this method indicates a total failure, meaning that the message
	     * was not sent to any of the tokens in the list. Partial failures are indicated
	     * by a `BatchResponse` return value.
	     *
	     * @param message - A multicast message
	     *   containing up to 500 tokens.
	     * @param dryRun - Whether to send the message in the dry-run
	     *   (validation only) mode.
	     * @returns A Promise fulfilled with an object representing the result of the
	     *   send operation.
	     *
	     * @deprecated Use {@link Messaging.sendEachForMulticast} instead.
	     */
	    sendMulticast(message, dryRun) {
	        const copy = (0, deep_copy_1.deepCopy)(message);
	        if (!validator.isNonNullObject(copy)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');
	        }
	        if (!validator.isNonEmptyArray(copy.tokens)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');
	        }
	        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);
	        }
	        const messages = copy.tokens.map((token) => {
	            return {
	                token,
	                android: copy.android,
	                apns: copy.apns,
	                data: copy.data,
	                notification: copy.notification,
	                webpush: copy.webpush,
	                fcmOptions: copy.fcmOptions,
	            };
	        });
	        return this.sendAll(messages, dryRun);
	    }
	    /**
	     * Sends an FCM message to a single device corresponding to the provided
	     * registration token.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_individual_devices |
	     * Send to individual devices}
	     * for code samples and detailed documentation. Takes either a
	     * `registrationToken` to send to a single device or a
	     * `registrationTokens` parameter containing an array of tokens to send
	     * to multiple devices.
	     *
	     * @param registrationToken - A device registration token or an array of
	     *   device registration tokens to which the message should be sent.
	     * @param payload - The message payload.
	     * @param options - Optional options to
	     *   alter the message.
	     *
	     * @returns A promise fulfilled with the server's response after the message
	     *   has been sent.
	     *
	     * @deprecated Use {@link Messaging.send} instead.
	     */
	    sendToDevice(registrationTokenOrTokens, payload, options = {}) {
	        // Validate the input argument types. Since these are common developer errors when getting
	        // started, throw an error instead of returning a rejected promise.
	        this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
	        this.validateMessagingPayloadAndOptionsTypes(payload, options);
	        return Promise.resolve()
	            .then(() => {
	            // Validate the contents of the input arguments. Because we are now in a promise, any thrown
	            // error will cause this method to return a rejected promise.
	            this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
	            const payloadCopy = this.validateMessagingPayload(payload);
	            const optionsCopy = this.validateMessagingOptions(options);
	            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
	            (0, deep_copy_1.deepExtend)(request, optionsCopy);
	            if (validator.isString(registrationTokenOrTokens)) {
	                request.to = registrationTokenOrTokens;
	            }
	            else {
	                request.registration_ids = registrationTokenOrTokens;
	            }
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
	        })
	            .then((response) => {
	            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in
	            // the underlying FCM request. If the provided registration token argument is actually a
	            // valid notification key, the response from the FCM server will be a device group response.
	            // If that is the case, we map the response to a MessagingDeviceGroupResponse.
	            // See b/35394951 for more context.
	            if ('multicast_id' in response) {
	                return mapRawResponseToDevicesResponse(response);
	            }
	            else {
	                const groupResponse = mapRawResponseToDeviceGroupResponse(response);
	                return {
	                    ...groupResponse,
	                    canonicalRegistrationTokenCount: -1,
	                    multicastId: -1,
	                    results: [],
	                };
	            }
	        });
	    }
	    /**
	     * Sends an FCM message to a device group corresponding to the provided
	     * notification key.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_device_group |
	     * Send to a device group} for code samples and detailed documentation.
	     *
	     * @param notificationKey - The notification key for the device group to
	     *   which to send the message.
	     * @param payload - The message payload.
	     * @param options - Optional options to
	     *   alter the message.
	     *
	     * @returns A promise fulfilled with the server's response after the message
	     *   has been sent.
	     *
	     * @deprecated Use {@link Messaging.send} instead.
	     */
	    sendToDeviceGroup(notificationKey, payload, options = {}) {
	        if (!validator.isNonEmptyString(notificationKey)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');
	        }
	        else if (notificationKey.indexOf(':') !== -1) {
	            // It is possible the developer provides a registration token instead of a notification key
	            // to this method. We can detect some of those cases by checking to see if the string contains
	            // a colon. Not all registration tokens will contain a colon (only newer ones will), but no
	            // notification keys will contain a colon, so we can use it as a rough heuristic.
	            // See b/35394951 for more context.
	            return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' +
	                'You should use sendToDevice() instead.'));
	        }
	        // Validate the types of the payload and options arguments. Since these are common developer
	        // errors, throw an error instead of returning a rejected promise.
	        this.validateMessagingPayloadAndOptionsTypes(payload, options);
	        return Promise.resolve()
	            .then(() => {
	            // Validate the contents of the payload and options objects. Because we are now in a
	            // promise, any thrown error will cause this method to return a rejected promise.
	            const payloadCopy = this.validateMessagingPayload(payload);
	            const optionsCopy = this.validateMessagingOptions(options);
	            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
	            (0, deep_copy_1.deepExtend)(request, optionsCopy);
	            request.to = notificationKey;
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
	        })
	            .then((response) => {
	            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in
	            // the underlying FCM request. If the provided notification key argument has an invalid
	            // format (that is, it is either a registration token or some random string), the response
	            // from the FCM server will default to a devices response (which we detect by looking for
	            // the `multicast_id` property). If that is the case, we either throw an error saying the
	            // provided notification key is invalid (if the message failed to send) or map the response
	            // to a MessagingDevicesResponse (if the message succeeded).
	            // See b/35394951 for more context.
	            if ('multicast_id' in response) {
	                if (response.success === 0) {
	                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');
	                }
	                else {
	                    const devicesResponse = mapRawResponseToDevicesResponse(response);
	                    return {
	                        ...devicesResponse,
	                        failedRegistrationTokens: [],
	                    };
	                }
	            }
	            return mapRawResponseToDeviceGroupResponse(response);
	        });
	    }
	    /**
	     * Sends an FCM message to a topic.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_topic |
	     * Send to a topic} for code samples and detailed documentation.
	     *
	     * @param topic - The topic to which to send the message.
	     * @param payload - The message payload.
	     * @param options - Optional options to
	     *   alter the message.
	     *
	     * @returns A promise fulfilled with the server's response after the message
	     *   has been sent.
	     *
	     * @deprecated Use {@link Messaging.send} instead.
	     */
	    sendToTopic(topic, payload, options = {}) {
	        // Validate the input argument types. Since these are common developer errors when getting
	        // started, throw an error instead of returning a rejected promise.
	        this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
	        this.validateMessagingPayloadAndOptionsTypes(payload, options);
	        // Prepend the topic with /topics/ if necessary.
	        topic = this.normalizeTopic(topic);
	        return Promise.resolve()
	            .then(() => {
	            // Validate the contents of the payload and options objects. Because we are now in a
	            // promise, any thrown error will cause this method to return a rejected promise.
	            const payloadCopy = this.validateMessagingPayload(payload);
	            const optionsCopy = this.validateMessagingOptions(options);
	            this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
	            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
	            (0, deep_copy_1.deepExtend)(request, optionsCopy);
	            request.to = topic;
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
	        })
	            .then((response) => {
	            // Rename properties on the server response
	            utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);
	            return response;
	        });
	    }
	    /**
	     * Sends an FCM message to a condition.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_condition |
	     * Send to a condition}
	     * for code samples and detailed documentation.
	     *
	     * @param condition - The condition determining to which topics to send
	     *   the message.
	     * @param payload - The message payload.
	     * @param options - Optional options to
	     *   alter the message.
	     *
	     * @returns A promise fulfilled with the server's response after the message
	     *   has been sent.
	     *
	     * @deprecated Use {@link Messaging.send} instead.
	     */
	    sendToCondition(condition, payload, options = {}) {
	        if (!validator.isNonEmptyString(condition)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');
	        }
	        // Validate the types of the payload and options arguments. Since these are common developer
	        // errors, throw an error instead of returning a rejected promise.
	        this.validateMessagingPayloadAndOptionsTypes(payload, options);
	        // The FCM server rejects conditions which are surrounded in single quotes. When the condition
	        // is stringified over the wire, double quotes in it get converted to \" which the FCM server
	        // does not properly handle. We can get around this by replacing internal double quotes with
	        // single quotes.
	        condition = condition.replace(/"/g, '\'');
	        return Promise.resolve()
	            .then(() => {
	            // Validate the contents of the payload and options objects. Because we are now in a
	            // promise, any thrown error will cause this method to return a rejected promise.
	            const payloadCopy = this.validateMessagingPayload(payload);
	            const optionsCopy = this.validateMessagingOptions(options);
	            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
	            (0, deep_copy_1.deepExtend)(request, optionsCopy);
	            request.condition = condition;
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
	        })
	            .then((response) => {
	            // Rename properties on the server response
	            utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);
	            return response;
	        });
	    }
	    /**
	     * Subscribes a device to an FCM topic.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |
	     * Subscribe to a topic}
	     * for code samples and detailed documentation. Optionally, you can provide an
	     * array of tokens to subscribe multiple devices.
	     *
	     * @param registrationTokens - A token or array of registration tokens
	     *   for the devices to subscribe to the topic.
	     * @param topic - The topic to which to subscribe.
	     *
	     * @returns A promise fulfilled with the server's response after the device has been
	     *   subscribed to the topic.
	     */
	    subscribeToTopic(registrationTokenOrTokens, topic) {
	        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);
	    }
	    /**
	     * Unsubscribes a device from an FCM topic.
	     *
	     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |
	     * Unsubscribe from a topic}
	     * for code samples and detailed documentation.  Optionally, you can provide an
	     * array of tokens to unsubscribe multiple devices.
	     *
	     * @param registrationTokens - A device registration token or an array of
	     *   device registration tokens to unsubscribe from the topic.
	     * @param topic - The topic from which to unsubscribe.
	     *
	     * @returns A promise fulfilled with the server's response after the device has been
	     *   unsubscribed from the topic.
	     */
	    unsubscribeFromTopic(registrationTokenOrTokens, topic) {
	        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);
	    }
	    getUrlPath() {
	        if (this.urlPath) {
	            return Promise.resolve(this.urlPath);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                // Assert for an explicit project ID (either via AppOptions or the cert itself).
	                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the '
	                    + 'SDK with service account credentials or set project ID as an app option. '
	                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');
	            }
	            this.urlPath = `/v1/projects/${projectId}/messages:send`;
	            return this.urlPath;
	        });
	    }
	    /**
	     * Helper method which sends and handles topic subscription management requests.
	     *
	     * @param registrationTokenOrTokens - The registration token or an array of
	     *     registration tokens to unsubscribe from the topic.
	     * @param topic - The topic to which to subscribe.
	     * @param methodName - The name of the original method called.
	     * @param path - The endpoint path to use for the request.
	     *
	     * @returns A Promise fulfilled with the parsed server
	     *   response.
	     */
	    sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) {
	        this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);
	        this.validateTopicType(topic, methodName);
	        // Prepend the topic with /topics/ if necessary.
	        topic = this.normalizeTopic(topic);
	        return Promise.resolve()
	            .then(() => {
	            // Validate the contents of the input arguments. Because we are now in a promise, any thrown
	            // error will cause this method to return a rejected promise.
	            this.validateRegistrationTokens(registrationTokenOrTokens, methodName);
	            this.validateTopic(topic, methodName);
	            // Ensure the registration token(s) input argument is an array.
	            let registrationTokensArray = registrationTokenOrTokens;
	            if (validator.isString(registrationTokenOrTokens)) {
	                registrationTokensArray = [registrationTokenOrTokens];
	            }
	            const request = {
	                to: topic,
	                registration_tokens: registrationTokensArray,
	            };
	            return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);
	        })
	            .then((response) => {
	            return mapRawResponseToTopicManagementResponse(response);
	        });
	    }
	    /**
	     * Validates the types of the messaging payload and options. If invalid, an error will be thrown.
	     *
	     * @param payload - The messaging payload to validate.
	     * @param options - The messaging options to validate.
	     */
	    validateMessagingPayloadAndOptionsTypes(payload, options) {
	        // Validate the payload is an object
	        if (!validator.isNonNullObject(payload)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the "data" or "notification" properties.');
	        }
	        // Validate the options argument is an object
	        if (!validator.isNonNullObject(options)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');
	        }
	    }
	    /**
	     * Validates the messaging payload. If invalid, an error will be thrown.
	     *
	     * @param payload - The messaging payload to validate.
	     *
	     * @returns A copy of the provided payload with whitelisted properties switched
	     *     from camelCase to underscore_case.
	     */
	    validateMessagingPayload(payload) {
	        const payloadCopy = (0, deep_copy_1.deepCopy)(payload);
	        const payloadKeys = Object.keys(payloadCopy);
	        const validPayloadKeys = ['data', 'notification'];
	        let containsDataOrNotificationKey = false;
	        payloadKeys.forEach((payloadKey) => {
	            // Validate the payload does not contain any invalid keys
	            if (validPayloadKeys.indexOf(payloadKey) === -1) {
	                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid "${payloadKey}" property. Valid properties are ` +
	                    '"data" and "notification".');
	            }
	            else {
	                containsDataOrNotificationKey = true;
	            }
	        });
	        // Validate the payload contains at least one of the "data" and "notification" keys
	        if (!containsDataOrNotificationKey) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the "data" or "notification" properties.');
	        }
	        const validatePayload = (payloadKey, value) => {
	            // Validate each top-level key in the payload is an object
	            if (!validator.isNonNullObject(value)) {
	                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the "${payloadKey}" property. ` +
	                    'Value must be an object.');
	            }
	            Object.keys(value).forEach((subKey) => {
	                if (!validator.isString(value[subKey])) {
	                    // Validate all sub-keys have a string value
	                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the "${payloadKey}.${subKey}" ` +
	                        'property. Values must be strings.');
	                }
	                else if (payloadKey === 'data' && /^google\./.test(subKey)) {
	                    // Validate the data payload does not contain keys which start with 'google.'.
	                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted "data.${subKey}" property.`);
	                }
	            });
	        };
	        if (payloadCopy.data !== undefined) {
	            validatePayload('data', payloadCopy.data);
	        }
	        if (payloadCopy.notification !== undefined) {
	            validatePayload('notification', payloadCopy.notification);
	        }
	        // Validate the data payload object does not contain blacklisted properties
	        if ('data' in payloadCopy) {
	            messaging_internal_1.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach((blacklistedKey) => {
	                if (blacklistedKey in payloadCopy.data) {
	                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted "data.${blacklistedKey}" property.`);
	                }
	            });
	        }
	        // Convert whitelisted camelCase keys to underscore_case
	        if (payloadCopy.notification) {
	            utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);
	        }
	        return payloadCopy;
	    }
	    /**
	     * Validates the messaging options. If invalid, an error will be thrown.
	     *
	     * @param options - The messaging options to validate.
	     *
	     * @returns A copy of the provided options with whitelisted properties switched
	     *   from camelCase to underscore_case.
	     */
	    validateMessagingOptions(options) {
	        const optionsCopy = (0, deep_copy_1.deepCopy)(options);
	        // Validate the options object does not contain blacklisted properties
	        messaging_internal_1.BLACKLISTED_OPTIONS_KEYS.forEach((blacklistedKey) => {
	            if (blacklistedKey in optionsCopy) {
	                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains the blacklisted "${blacklistedKey}" property.`);
	            }
	        });
	        // Convert whitelisted camelCase keys to underscore_case
	        utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP);
	        // Validate the options object contains valid values for whitelisted properties
	        if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) {
	            const keyName = ('collapseKey' in options) ? 'collapseKey' : 'collapse_key';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a non-empty string.');
	        }
	        else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) {
	            const keyName = ('dryRun' in options) ? 'dryRun' : 'dry_run';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a boolean.');
	        }
	        else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) {
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the "priority" property. Value must ' +
	                'be a non-empty string.');
	        }
	        else if ('restricted_package_name' in optionsCopy &&
	            !validator.isNonEmptyString(optionsCopy.restricted_package_name)) {
	            const keyName = ('restrictedPackageName' in options) ? 'restrictedPackageName' : 'restricted_package_name';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a non-empty string.');
	        }
	        else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) {
	            const keyName = ('timeToLive' in options) ? 'timeToLive' : 'time_to_live';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a number.');
	        }
	        else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) {
	            const keyName = ('contentAvailable' in options) ? 'contentAvailable' : 'content_available';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a boolean.');
	        }
	        else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) {
	            const keyName = ('mutableContent' in options) ? 'mutableContent' : 'mutable_content';
	            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "${keyName}" property. Value must ` +
	                'be a boolean.');
	        }
	        return optionsCopy;
	    }
	    /**
	     * Validates the type of the provided registration token(s). If invalid, an error will be thrown.
	     *
	     * @param registrationTokenOrTokens - The registration token(s) to validate.
	     * @param method - The method name to use in error messages.
	     * @param errorInfo - The error info to use if the registration tokens are invalid.
	     */
	    validateRegistrationTokensType(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {
	        if (!validator.isNonEmptyArray(registrationTokenOrTokens) &&
	            !validator.isNonEmptyString(registrationTokenOrTokens)) {
	            throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to ${methodName}() must be a non-empty string or a ` +
	                'non-empty array.');
	        }
	    }
	    /**
	     * Validates the provided registration tokens. If invalid, an error will be thrown.
	     *
	     * @param registrationTokenOrTokens - The registration token or an array of
	     *     registration tokens to validate.
	     * @param method - The method name to use in error messages.
	     * @param errorInfo - The error info to use if the registration tokens are invalid.
	     */
	    validateRegistrationTokens(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {
	        if (validator.isArray(registrationTokenOrTokens)) {
	            // Validate the array contains no more than 1,000 registration tokens.
	            if (registrationTokenOrTokens.length > 1000) {
	                throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to ${methodName}(). Batch ` +
	                    'your requests to contain no more than 1,000 registration tokens per request.');
	            }
	            // Validate the array contains registration tokens which are non-empty strings.
	            registrationTokenOrTokens.forEach((registrationToken, index) => {
	                if (!validator.isNonEmptyString(registrationToken)) {
	                    throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to ${methodName}() at index ${index} must be a ` +
	                        'non-empty string.');
	                }
	            });
	        }
	    }
	    /**
	     * Validates the type of the provided topic. If invalid, an error will be thrown.
	     *
	     * @param topic - The topic to validate.
	     * @param method - The method name to use in error messages.
	     * @param errorInfo - The error info to use if the topic is invalid.
	     */
	    validateTopicType(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {
	        if (!validator.isNonEmptyString(topic)) {
	            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +
	                '"/topics/[a-zA-Z0-9-_.~%]+".');
	        }
	    }
	    /**
	     * Validates the provided topic. If invalid, an error will be thrown.
	     *
	     * @param topic - The topic to validate.
	     * @param method - The method name to use in error messages.
	     * @param errorInfo - The error info to use if the topic is invalid.
	     */
	    validateTopic(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {
	        if (!validator.isTopic(topic)) {
	            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +
	                '"/topics/[a-zA-Z0-9-_.~%]+".');
	        }
	    }
	    /**
	     * Normalizes the provided topic name by prepending it with '/topics/', if necessary.
	     *
	     * @param topic - The topic name to normalize.
	     *
	     * @returns The normalized topic name.
	     */
	    normalizeTopic(topic) {
	        if (!/^\/topics\//.test(topic)) {
	            topic = `/topics/${topic}`;
	        }
	        return topic;
	    }
	}
	messaging$1.Messaging = Messaging;
	return messaging$1;
}

var storage$1 = {};

/*! firebase-admin v12.7.0 */

var hasRequiredStorage$1;

function requireStorage$1 () {
	if (hasRequiredStorage$1) return storage$1;
	hasRequiredStorage$1 = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(storage$1, "__esModule", { value: true });
	storage$1.Storage = void 0;
	const error_1 = error;
	const credential_internal_1 = credentialInternal;
	const utils = utils$1;
	const validator = validator$2;
	/**
	 * The default `Storage` service if no
	 * app is provided or the `Storage` service associated with the provided
	 * app.
	 */
	class Storage {
	    /**
	     * @param app - The app for this Storage service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseError({
	                code: 'storage/invalid-argument',
	                message: 'First argument passed to admin.storage() must be a valid Firebase app instance.',
	            });
	        }
	        if (!process.env.STORAGE_EMULATOR_HOST && process.env.FIREBASE_STORAGE_EMULATOR_HOST) {
	            const firebaseStorageEmulatorHost = process.env.FIREBASE_STORAGE_EMULATOR_HOST;
	            if (firebaseStorageEmulatorHost.match(/https?:\/\//)) {
	                throw new error_1.FirebaseError({
	                    code: 'storage/invalid-emulator-host',
	                    message: 'FIREBASE_STORAGE_EMULATOR_HOST should not contain a protocol (http or https).',
	                });
	            }
	            process.env.STORAGE_EMULATOR_HOST = `http://${process.env.FIREBASE_STORAGE_EMULATOR_HOST}`;
	        }
	        let storage;
	        try {
	            storage = require('@google-cloud/storage').Storage;
	        }
	        catch (err) {
	            throw new error_1.FirebaseError({
	                code: 'storage/missing-dependencies',
	                message: 'Failed to import the Cloud Storage client library for Node.js. '
	                    + 'Make sure to install the "@google-cloud/storage" npm package. '
	                    + `Original error: ${err}`,
	            });
	        }
	        const projectId = utils.getExplicitProjectId(app);
	        const credential = app.options.credential;
	        if (credential instanceof credential_internal_1.ServiceAccountCredential) {
	            this.storageClient = new storage({
	                // When the SDK is initialized with ServiceAccountCredentials an explicit projectId is
	                // guaranteed to be available.
	                projectId: projectId,
	                credentials: {
	                    private_key: credential.privateKey,
	                    client_email: credential.clientEmail,
	                },
	            });
	        }
	        else if ((0, credential_internal_1.isApplicationDefault)(app.options.credential)) {
	            // Try to use the Google application default credentials.
	            this.storageClient = new storage();
	        }
	        else {
	            throw new error_1.FirebaseError({
	                code: 'storage/invalid-credential',
	                message: 'Failed to initialize Google Cloud Storage client with the available credential. ' +
	                    'Must initialize the SDK with a certificate credential or application default credentials ' +
	                    'to use Cloud Storage API.',
	            });
	        }
	        this.appInternal = app;
	    }
	    /**
	     * Gets a reference to a Cloud Storage bucket.
	     *
	     * @param name - Optional name of the bucket to be retrieved. If name is not specified,
	     * retrieves a reference to the default bucket.
	     * @returns A {@link https://cloud.google.com/nodejs/docs/reference/storage/latest/Bucket | Bucket}
	     * instance as defined in the `@google-cloud/storage` package.
	     */
	    bucket(name) {
	        const bucketName = (typeof name !== 'undefined')
	            ? name : this.appInternal.options.storageBucket;
	        if (validator.isNonEmptyString(bucketName)) {
	            return this.storageClient.bucket(bucketName);
	        }
	        throw new error_1.FirebaseError({
	            code: 'storage/invalid-argument',
	            message: 'Bucket name not specified or invalid. Specify a valid bucket name via the ' +
	                'storageBucket option when initializing the app, or specify the bucket name ' +
	                'explicitly when calling the getBucket() method.',
	        });
	    }
	    /**
	     * Optional app whose `Storage` service to
	     * return. If not provided, the default `Storage` service will be returned.
	     */
	    get app() {
	        return this.appInternal;
	    }
	}
	storage$1.Storage = Storage;
	return storage$1;
}

const require$$7 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(firestore$1);

var machineLearning$1 = {};

var storage = {};

var app = {};

/*! firebase-admin v12.7.0 */

var hasRequiredApp;

function requireApp () {
	if (hasRequiredApp) return app;
	hasRequiredApp = 1;
	(function (exports) {
		/*!
		 * @license
		 * Copyright 2021 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SDK_VERSION = exports.AppErrorCodes = exports.FirebaseAppError = exports.refreshToken = exports.cert = exports.applicationDefault = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = void 0;
		const utils_1 = utils$1;
		var lifecycle_1 = lifecycle;
		Object.defineProperty(exports, "initializeApp", { enumerable: true, get: function () { return lifecycle_1.initializeApp; } });
		Object.defineProperty(exports, "getApp", { enumerable: true, get: function () { return lifecycle_1.getApp; } });
		Object.defineProperty(exports, "getApps", { enumerable: true, get: function () { return lifecycle_1.getApps; } });
		Object.defineProperty(exports, "deleteApp", { enumerable: true, get: function () { return lifecycle_1.deleteApp; } });
		var credential_factory_1 = credentialFactory;
		Object.defineProperty(exports, "applicationDefault", { enumerable: true, get: function () { return credential_factory_1.applicationDefault; } });
		Object.defineProperty(exports, "cert", { enumerable: true, get: function () { return credential_factory_1.cert; } });
		Object.defineProperty(exports, "refreshToken", { enumerable: true, get: function () { return credential_factory_1.refreshToken; } });
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseAppError", { enumerable: true, get: function () { return error_1.FirebaseAppError; } });
		Object.defineProperty(exports, "AppErrorCodes", { enumerable: true, get: function () { return error_1.AppErrorCodes; } });
		exports.SDK_VERSION = (0, utils_1.getSdkVersion)(); 
	} (app));
	return app;
}

var utils = {};

/*! firebase-admin v12.7.0 */

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.getFirebaseMetadata = void 0;
	function getFirebaseMetadata(endpoint, file) {
	    const uri = `${endpoint}/b/${file.bucket.name}/o/${encodeURIComponent(file.name)}`;
	    return new Promise((resolve, reject) => {
	        file.storage.makeAuthenticatedRequest({
	            method: 'GET',
	            uri,
	        }, (err, body) => {
	            if (err) {
	                reject(err);
	            }
	            else {
	                resolve(body);
	            }
	        });
	    });
	}
	utils.getFirebaseMetadata = getFirebaseMetadata;
	return utils;
}

/*! firebase-admin v12.7.0 */

var hasRequiredStorage;

function requireStorage () {
	if (hasRequiredStorage) return storage;
	hasRequiredStorage = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getDownloadURL = exports.getStorage = exports.Storage = void 0;
		const app_1 = /*@__PURE__*/ requireApp();
		const storage_1 = /*@__PURE__*/ requireStorage$1();
		const error_1 = error;
		const utils_1 = /*@__PURE__*/ requireUtils();
		var storage_2 = /*@__PURE__*/ requireStorage$1();
		Object.defineProperty(exports, "Storage", { enumerable: true, get: function () { return storage_2.Storage; } });
		/**
		 * Gets the {@link Storage} service for the default app or a given app.
		 *
		 * `getStorage()` can be called with no arguments to access the default
		 * app's `Storage` service or as `getStorage(app)` to access the
		 * `Storage` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Storage service for the default app
		 * const defaultStorage = getStorage();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Storage service for a given app
		 * const otherStorage = getStorage(otherApp);
		 * ```
		 */
		function getStorage(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('storage', (app) => new storage_1.Storage(app));
		}
		exports.getStorage = getStorage;
		/**
		 * Gets the download URL for the given {@link https://cloud.google.com/nodejs/docs/reference/storage/latest/storage/file | File}.
		 *
		 * @example
		 * ```javascript
		 * // Get the downloadUrl for a given file ref
		 * const storage = getStorage();
		 * const myRef = ref(storage, 'images/mountains.jpg');
		 * const downloadUrl = await getDownloadURL(myRef);
		 * ```
		 */
		async function getDownloadURL(file) {
		    const endpoint = (process.env.STORAGE_EMULATOR_HOST ||
		        'https://firebasestorage.googleapis.com') + '/v0';
		    const { downloadTokens } = await (0, utils_1.getFirebaseMetadata)(endpoint, file);
		    if (!downloadTokens) {
		        throw new error_1.FirebaseError({
		            code: 'storage/no-download-token',
		            message: 'No download token available. Please create one in the Firebase Console.',
		        });
		    }
		    const [token] = downloadTokens.split(',');
		    return `${endpoint}/b/${file.bucket.name}/o/${encodeURIComponent(file.name)}?alt=media&token=${token}`;
		}
		exports.getDownloadURL = getDownloadURL; 
	} (storage));
	return storage;
}

var machineLearningApiClient = {};

var machineLearningUtils = {};

/*! firebase-admin v12.7.0 */

var hasRequiredMachineLearningUtils;

function requireMachineLearningUtils () {
	if (hasRequiredMachineLearningUtils) return machineLearningUtils;
	hasRequiredMachineLearningUtils = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(machineLearningUtils, "__esModule", { value: true });
	machineLearningUtils.FirebaseMachineLearningError = void 0;
	const error_1 = error;
	class FirebaseMachineLearningError extends error_1.PrefixedFirebaseError {
	    static fromOperationError(code, message) {
	        switch (code) {
	            case 1: return new FirebaseMachineLearningError('cancelled', message);
	            case 2: return new FirebaseMachineLearningError('unknown-error', message);
	            case 3: return new FirebaseMachineLearningError('invalid-argument', message);
	            case 4: return new FirebaseMachineLearningError('deadline-exceeded', message);
	            case 5: return new FirebaseMachineLearningError('not-found', message);
	            case 6: return new FirebaseMachineLearningError('already-exists', message);
	            case 7: return new FirebaseMachineLearningError('permission-denied', message);
	            case 8: return new FirebaseMachineLearningError('resource-exhausted', message);
	            case 9: return new FirebaseMachineLearningError('failed-precondition', message);
	            case 10: return new FirebaseMachineLearningError('aborted', message);
	            case 11: return new FirebaseMachineLearningError('out-of-range', message);
	            case 13: return new FirebaseMachineLearningError('internal-error', message);
	            case 14: return new FirebaseMachineLearningError('service-unavailable', message);
	            case 15: return new FirebaseMachineLearningError('data-loss', message);
	            case 16: return new FirebaseMachineLearningError('unauthenticated', message);
	            default:
	                return new FirebaseMachineLearningError('unknown-error', message);
	        }
	    }
	    constructor(code, message) {
	        super('machine-learning', code, message);
	    }
	}
	machineLearningUtils.FirebaseMachineLearningError = FirebaseMachineLearningError;
	return machineLearningUtils;
}

/*! firebase-admin v12.7.0 */

var hasRequiredMachineLearningApiClient;

function requireMachineLearningApiClient () {
	if (hasRequiredMachineLearningApiClient) return machineLearningApiClient;
	hasRequiredMachineLearningApiClient = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(machineLearningApiClient, "__esModule", { value: true });
	machineLearningApiClient.MachineLearningApiClient = machineLearningApiClient.isGcsTfliteModelOptions = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const error_1 = error;
	const utils = utils$1;
	const validator = validator$2;
	const machine_learning_utils_1 = /*@__PURE__*/ requireMachineLearningUtils();
	const ML_V1BETA2_API = 'https://firebaseml.googleapis.com/v1beta2';
	const FIREBASE_VERSION_HEADER = {
	    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,
	};
	// Operation polling defaults
	const POLL_DEFAULT_MAX_TIME_MILLISECONDS = 120000; // Maximum overall 2 minutes
	const POLL_BASE_WAIT_TIME_MILLISECONDS = 3000; // Start with 3 second delay
	const POLL_MAX_WAIT_TIME_MILLISECONDS = 30000; // Maximum 30 second delay
	function isGcsTfliteModelOptions(options) {
	    const gcsUri = options?.tfliteModel?.gcsTfliteUri;
	    return typeof gcsUri !== 'undefined';
	}
	machineLearningApiClient.isGcsTfliteModelOptions = isGcsTfliteModelOptions;
	/**
	 * Class that facilitates sending requests to the Firebase ML backend API.
	 *
	 * @internal
	 */
	class MachineLearningApiClient {
	    constructor(app) {
	        this.app = app;
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'First argument passed to admin.machineLearning() must be a valid '
	                + 'Firebase app instance.');
	        }
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    createModel(model) {
	        if (!validator.isNonNullObject(model) ||
	            !validator.isNonEmptyString(model.displayName)) {
	            const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid model content.');
	            return Promise.reject(err);
	        }
	        return this.getProjectUrl()
	            .then((url) => {
	            const request = {
	                method: 'POST',
	                url: `${url}/models`,
	                data: model,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    updateModel(modelId, model, updateMask) {
	        if (!validator.isNonEmptyString(modelId) ||
	            !validator.isNonNullObject(model) ||
	            !validator.isNonEmptyArray(updateMask)) {
	            const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid model or mask content.');
	            return Promise.reject(err);
	        }
	        return this.getProjectUrl()
	            .then((url) => {
	            const request = {
	                method: 'PATCH',
	                url: `${url}/models/${modelId}?updateMask=${updateMask.join()}`,
	                data: model,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    getModel(modelId) {
	        return Promise.resolve()
	            .then(() => {
	            return this.getModelName(modelId);
	        })
	            .then((modelName) => {
	            return this.getResourceWithShortName(modelName);
	        });
	    }
	    getOperation(operationName) {
	        return Promise.resolve()
	            .then(() => {
	            return this.getResourceWithFullName(operationName);
	        });
	    }
	    listModels(options = {}) {
	        if (!validator.isNonNullObject(options)) {
	            const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid ListModelsOptions');
	            return Promise.reject(err);
	        }
	        if (typeof options.filter !== 'undefined' && !validator.isNonEmptyString(options.filter)) {
	            const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid list filter.');
	            return Promise.reject(err);
	        }
	        if (typeof options.pageSize !== 'undefined') {
	            if (!validator.isNumber(options.pageSize)) {
	                const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid page size.');
	                return Promise.reject(err);
	            }
	            if (options.pageSize < 1 || options.pageSize > 100) {
	                const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Page size must be between 1 and 100.');
	                return Promise.reject(err);
	            }
	        }
	        if (typeof options.pageToken !== 'undefined' && !validator.isNonEmptyString(options.pageToken)) {
	            const err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Next page token must be a non-empty string.');
	            return Promise.reject(err);
	        }
	        return this.getProjectUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/models`,
	                data: options,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    deleteModel(modelId) {
	        return this.getProjectUrl()
	            .then((url) => {
	            const modelName = this.getModelName(modelId);
	            const request = {
	                method: 'DELETE',
	                url: `${url}/${modelName}`,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    /**
	     * Handles a Long Running Operation coming back from the server.
	     *
	     * @param op - The operation to handle
	     * @param options - The options for polling
	     */
	    handleOperation(op, options) {
	        if (op.done) {
	            if (op.response) {
	                return Promise.resolve(op.response);
	            }
	            else if (op.error) {
	                const err = machine_learning_utils_1.FirebaseMachineLearningError.fromOperationError(op.error.code, op.error.message);
	                return Promise.reject(err);
	            }
	            // Done operations must have either a response or an error.
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', 'Invalid operation response.');
	        }
	        // Operation is not done
	        if (options?.wait) {
	            return this.pollOperationWithExponentialBackoff(op.name, options);
	        }
	        const metadata = op.metadata || {};
	        const metadataType = metadata['@type'] || '';
	        if (!metadataType.includes('ModelOperationMetadata')) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', `Unknown Metadata type: ${JSON.stringify(metadata)}`);
	        }
	        return this.getModel(extractModelId(metadata.name));
	    }
	    // baseWaitMillis and maxWaitMillis should only ever be modified by unit tests to run faster.
	    pollOperationWithExponentialBackoff(opName, options) {
	        const maxTimeMilliseconds = options?.maxTimeMillis ?? POLL_DEFAULT_MAX_TIME_MILLISECONDS;
	        const baseWaitMillis = options?.baseWaitMillis ?? POLL_BASE_WAIT_TIME_MILLISECONDS;
	        const maxWaitMillis = options?.maxWaitMillis ?? POLL_MAX_WAIT_TIME_MILLISECONDS;
	        const poller = new api_request_1.ExponentialBackoffPoller(baseWaitMillis, maxWaitMillis, maxTimeMilliseconds);
	        return poller.poll(() => {
	            return this.getOperation(opName)
	                .then((responseData) => {
	                if (!responseData.done) {
	                    return null;
	                }
	                if (responseData.error) {
	                    const err = machine_learning_utils_1.FirebaseMachineLearningError.fromOperationError(responseData.error.code, responseData.error.message);
	                    throw err;
	                }
	                return responseData.response;
	            });
	        });
	    }
	    /**
	     * Gets the specified resource from the ML API. Resource names must be the short names without project
	     * ID prefix (e.g. `models/123456789`).
	     *
	     * @param {string} name Short name of the resource to get. e.g. 'models/12345'
	     * @returns {Promise<T>} A promise that fulfills with the resource.
	     */
	    getResourceWithShortName(name) {
	        return this.getProjectUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/${name}`,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    /**
	     * Gets the specified resource from the ML API. Resource names must be the full names including project
	     * number prefix.
	     * @param fullName - Full resource name of the resource to get. e.g. projects/123465/operations/987654
	     * @returns {Promise<T>} A promise that fulfulls with the resource.
	     */
	    getResourceWithFullName(fullName) {
	        const request = {
	            method: 'GET',
	            url: `${ML_V1BETA2_API}/${fullName}`
	        };
	        return this.sendRequest(request);
	    }
	    sendRequest(request) {
	        request.headers = FIREBASE_VERSION_HEADER;
	        return this.httpClient.send(request)
	            .then((resp) => {
	            return resp.data;
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    toFirebaseError(err) {
	        if (err instanceof error_1.PrefixedFirebaseError) {
	            return err;
	        }
	        const response = err.response;
	        if (!response.isJson()) {
	            return new machine_learning_utils_1.FirebaseMachineLearningError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);
	        }
	        const error = response.data.error || {};
	        let code = 'unknown-error';
	        if (error.status && error.status in ERROR_CODE_MAPPING) {
	            code = ERROR_CODE_MAPPING[error.status];
	        }
	        const message = error.message || `Unknown server error: ${response.text}`;
	        return new machine_learning_utils_1.FirebaseMachineLearningError(code, message);
	    }
	    getProjectUrl() {
	        return this.getProjectIdPrefix()
	            .then((projectIdPrefix) => {
	            return `${ML_V1BETA2_API}/${projectIdPrefix}`;
	        });
	    }
	    getProjectIdPrefix() {
	        if (this.projectIdPrefix) {
	            return Promise.resolve(this.projectIdPrefix);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
	                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
	                    + 'environment variable.');
	            }
	            this.projectIdPrefix = `projects/${projectId}`;
	            return this.projectIdPrefix;
	        });
	    }
	    getModelName(modelId) {
	        if (!validator.isNonEmptyString(modelId)) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Model ID must be a non-empty string.');
	        }
	        if (modelId.indexOf('/') !== -1) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Model ID must not contain any "/" characters.');
	        }
	        return `models/${modelId}`;
	    }
	}
	machineLearningApiClient.MachineLearningApiClient = MachineLearningApiClient;
	const ERROR_CODE_MAPPING = {
	    INVALID_ARGUMENT: 'invalid-argument',
	    NOT_FOUND: 'not-found',
	    RESOURCE_EXHAUSTED: 'resource-exhausted',
	    UNAUTHENTICATED: 'authentication-error',
	    UNKNOWN: 'unknown-error',
	};
	function extractModelId(resourceName) {
	    return resourceName.split('/').pop();
	}
	return machineLearningApiClient;
}

/*! firebase-admin v12.7.0 */

var hasRequiredMachineLearning$1;

function requireMachineLearning$1 () {
	if (hasRequiredMachineLearning$1) return machineLearning$1;
	hasRequiredMachineLearning$1 = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(machineLearning$1, "__esModule", { value: true });
	machineLearning$1.Model = machineLearning$1.MachineLearning = void 0;
	const index_1 = /*@__PURE__*/ requireStorage();
	const error_1 = error;
	const validator = validator$2;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	const utils = utils$1;
	const machine_learning_api_client_1 = /*@__PURE__*/ requireMachineLearningApiClient();
	const machine_learning_utils_1 = /*@__PURE__*/ requireMachineLearningUtils();
	/**
	 * The Firebase `MachineLearning` service interface.
	 */
	class MachineLearning {
	    /**
	     * @param app - The app for this ML service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseError({
	                code: 'machine-learning/invalid-argument',
	                message: 'First argument passed to admin.machineLearning() must be a ' +
	                    'valid Firebase app instance.',
	            });
	        }
	        this.appInternal = app;
	        this.client = new machine_learning_api_client_1.MachineLearningApiClient(app);
	    }
	    /**
	     *  The {@link firebase-admin.app#App} associated with the current `MachineLearning`
	     *  service instance.
	     */
	    get app() {
	        return this.appInternal;
	    }
	    /**
	     * Creates a model in the current Firebase project.
	     *
	     * @param model - The model to create.
	     *
	     * @returns A Promise fulfilled with the created model.
	     */
	    createModel(model) {
	        return this.signUrlIfPresent(model)
	            .then((modelContent) => this.client.createModel(modelContent))
	            .then((operation) => this.client.handleOperation(operation))
	            .then((modelResponse) => new Model(modelResponse, this.client));
	    }
	    /**
	     * Updates a model's metadata or model file.
	     *
	     * @param modelId - The ID of the model to update.
	     * @param model - The model fields to update.
	     *
	     * @returns A Promise fulfilled with the updated model.
	     */
	    updateModel(modelId, model) {
	        const updateMask = utils.generateUpdateMask(model);
	        return this.signUrlIfPresent(model)
	            .then((modelContent) => this.client.updateModel(modelId, modelContent, updateMask))
	            .then((operation) => this.client.handleOperation(operation))
	            .then((modelResponse) => new Model(modelResponse, this.client));
	    }
	    /**
	     * Publishes a Firebase ML model.
	     *
	     * A published model can be downloaded to client apps.
	     *
	     * @param modelId - The ID of the model to publish.
	     *
	     * @returns A Promise fulfilled with the published model.
	     */
	    publishModel(modelId) {
	        return this.setPublishStatus(modelId, true);
	    }
	    /**
	     * Unpublishes a Firebase ML model.
	     *
	     * @param modelId - The ID of the model to unpublish.
	     *
	     * @returns A Promise fulfilled with the unpublished model.
	     */
	    unpublishModel(modelId) {
	        return this.setPublishStatus(modelId, false);
	    }
	    /**
	     * Gets the model specified by the given ID.
	     *
	     * @param modelId - The ID of the model to get.
	     *
	     * @returns A Promise fulfilled with the model object.
	     */
	    getModel(modelId) {
	        return this.client.getModel(modelId)
	            .then((modelResponse) => new Model(modelResponse, this.client));
	    }
	    /**
	     * Lists the current project's models.
	     *
	     * @param options - The listing options.
	     *
	     * @returns A promise that
	     *     resolves with the current (filtered) list of models and the next page
	     *     token. For the last page, an empty list of models and no page token
	     *     are returned.
	     */
	    listModels(options = {}) {
	        return this.client.listModels(options)
	            .then((resp) => {
	            if (!validator.isNonNullObject(resp)) {
	                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid ListModels response: ${JSON.stringify(resp)}`);
	            }
	            let models = [];
	            if (resp.models) {
	                models = resp.models.map((rs) => new Model(rs, this.client));
	            }
	            const result = { models };
	            if (resp.nextPageToken) {
	                result.pageToken = resp.nextPageToken;
	            }
	            return result;
	        });
	    }
	    /**
	     * Deletes a model from the current project.
	     *
	     * @param modelId - The ID of the model to delete.
	     */
	    deleteModel(modelId) {
	        return this.client.deleteModel(modelId);
	    }
	    setPublishStatus(modelId, publish) {
	        const updateMask = ['state.published'];
	        const options = { state: { published: publish } };
	        return this.client.updateModel(modelId, options, updateMask)
	            .then((operation) => this.client.handleOperation(operation))
	            .then((modelResponse) => new Model(modelResponse, this.client));
	    }
	    signUrlIfPresent(options) {
	        const modelOptions = (0, deep_copy_1.deepCopy)(options);
	        if ((0, machine_learning_api_client_1.isGcsTfliteModelOptions)(modelOptions)) {
	            return this.signUrl(modelOptions.tfliteModel.gcsTfliteUri)
	                .then((uri) => {
	                modelOptions.tfliteModel.gcsTfliteUri = uri;
	                return modelOptions;
	            })
	                .catch((err) => {
	                throw new machine_learning_utils_1.FirebaseMachineLearningError('internal-error', `Error during signing upload url: ${err.message}`);
	            });
	        }
	        return Promise.resolve(modelOptions);
	    }
	    signUrl(unsignedUrl) {
	        const MINUTES_IN_MILLIS = 60 * 1000;
	        const URL_VALID_DURATION = 10 * MINUTES_IN_MILLIS;
	        const gcsRegex = /^gs:\/\/([a-z0-9_.-]{3,63})\/(.+)$/;
	        const matches = gcsRegex.exec(unsignedUrl);
	        if (!matches) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid unsigned url: ${unsignedUrl}`);
	        }
	        const bucketName = matches[1];
	        const blobName = matches[2];
	        const bucket = (0, index_1.getStorage)(this.app).bucket(bucketName);
	        const blob = bucket.file(blobName);
	        return blob.getSignedUrl({
	            action: 'read',
	            expires: Date.now() + URL_VALID_DURATION,
	        }).then((signUrl) => signUrl[0]);
	    }
	}
	machineLearning$1.MachineLearning = MachineLearning;
	/**
	 * A Firebase ML Model output object.
	 */
	class Model {
	    /**
	     * @internal
	     */
	    constructor(model, client) {
	        this.model = Model.validateAndClone(model);
	        this.client = client;
	    }
	    /** The ID of the model. */
	    get modelId() {
	        return extractModelId(this.model.name);
	    }
	    /**
	     * The model's name. This is the name you use from your app to load the
	     * model.
	     */
	    get displayName() {
	        return this.model.displayName;
	    }
	    /**
	     * The model's tags, which can be used to group or filter models in list
	     * operations.
	     */
	    get tags() {
	        return this.model.tags || [];
	    }
	    /** The timestamp of the model's creation. */
	    get createTime() {
	        return new Date(this.model.createTime).toUTCString();
	    }
	    /** The timestamp of the model's most recent update. */
	    get updateTime() {
	        return new Date(this.model.updateTime).toUTCString();
	    }
	    /** Error message when model validation fails. */
	    get validationError() {
	        return this.model.state?.validationError?.message;
	    }
	    /** True if the model is published. */
	    get published() {
	        return this.model.state?.published || false;
	    }
	    /**
	     * The ETag identifier of the current version of the model. This value
	     * changes whenever you update any of the model's properties.
	     */
	    get etag() {
	        return this.model.etag;
	    }
	    /**
	     * The hash of the model's `tflite` file. This value changes only when
	     * you upload a new TensorFlow Lite model.
	     */
	    get modelHash() {
	        return this.model.modelHash;
	    }
	    /** Metadata about the model's TensorFlow Lite model file. */
	    get tfliteModel() {
	        // Make a copy so people can't directly modify the private this.model object.
	        return (0, deep_copy_1.deepCopy)(this.model.tfliteModel);
	    }
	    /**
	     * True if the model is locked by a server-side operation. You can't make
	     * changes to a locked model. See {@link Model.waitForUnlocked}.
	     */
	    get locked() {
	        return (this.model.activeOperations?.length ?? 0) > 0;
	    }
	    /**
	     * Return the model as a JSON object.
	     */
	    toJSON() {
	        // We can't just return this.model because it has extra fields and
	        // different formats etc. So we build the expected model object.
	        const jsonModel = {
	            modelId: this.modelId,
	            displayName: this.displayName,
	            tags: this.tags,
	            createTime: this.createTime,
	            updateTime: this.updateTime,
	            published: this.published,
	            etag: this.etag,
	            locked: this.locked,
	        };
	        // Also add possibly undefined fields if they exist.
	        if (this.validationError) {
	            jsonModel['validationError'] = this.validationError;
	        }
	        if (this.modelHash) {
	            jsonModel['modelHash'] = this.modelHash;
	        }
	        if (this.tfliteModel) {
	            jsonModel['tfliteModel'] = this.tfliteModel;
	        }
	        return jsonModel;
	    }
	    /**
	     * Wait for the model to be unlocked.
	     *
	     * @param maxTimeMillis - The maximum time in milliseconds to wait.
	     *     If not specified, a default maximum of 2 minutes is used.
	     *
	     * @returns A promise that resolves when the model is unlocked
	     *   or the maximum wait time has passed.
	     */
	    waitForUnlocked(maxTimeMillis) {
	        if ((this.model.activeOperations?.length ?? 0) > 0) {
	            // The client will always be defined on Models that have activeOperations
	            // because models with active operations came back from the server and
	            // were constructed with a non-empty client.
	            return this.client.handleOperation(this.model.activeOperations[0], { wait: true, maxTimeMillis })
	                .then((modelResponse) => {
	                this.model = Model.validateAndClone(modelResponse);
	            });
	        }
	        return Promise.resolve();
	    }
	    static validateAndClone(model) {
	        if (!validator.isNonNullObject(model) ||
	            !validator.isNonEmptyString(model.name) ||
	            !validator.isNonEmptyString(model.createTime) ||
	            !validator.isNonEmptyString(model.updateTime) ||
	            !validator.isNonEmptyString(model.displayName) ||
	            !validator.isNonEmptyString(model.etag)) {
	            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', `Invalid Model response: ${JSON.stringify(model)}`);
	        }
	        const tmpModel = (0, deep_copy_1.deepCopy)(model);
	        // If tflite Model is specified, it must have a source of {gcsTfliteUri}
	        if (model.tfliteModel &&
	            !validator.isNonEmptyString(model.tfliteModel.gcsTfliteUri)) {
	            // If we have some other source, ignore the whole tfliteModel.
	            delete tmpModel.tfliteModel;
	        }
	        // Remove '@type' field. We don't need it.
	        if (tmpModel['@type']) {
	            delete tmpModel['@type'];
	        }
	        return tmpModel;
	    }
	}
	machineLearning$1.Model = Model;
	function extractModelId(resourceName) {
	    return resourceName.split('/').pop();
	}
	return machineLearning$1;
}

var installations$1 = {};

var installationsRequestHandler = {};

/*! firebase-admin v12.7.0 */

var hasRequiredInstallationsRequestHandler;

function requireInstallationsRequestHandler () {
	if (hasRequiredInstallationsRequestHandler) return installationsRequestHandler;
	hasRequiredInstallationsRequestHandler = 1;
	/*!
	 * @license
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(installationsRequestHandler, "__esModule", { value: true });
	installationsRequestHandler.FirebaseInstallationsRequestHandler = void 0;
	const error_1 = error;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const utils = utils$1;
	const validator = validator$2;
	/** Firebase IID backend host. */
	const FIREBASE_IID_HOST = 'console.firebase.google.com';
	/** Firebase IID backend path. */
	const FIREBASE_IID_PATH = '/v1/';
	/** Firebase IID request timeout duration in milliseconds. */
	const FIREBASE_IID_TIMEOUT = 10000;
	/** HTTP error codes raised by the backend server. */
	const ERROR_CODES = {
	    400: 'Malformed installation ID argument.',
	    401: 'Request not authorized.',
	    403: 'Project does not match installation ID or the client does not have sufficient privileges.',
	    404: 'Failed to find the installation ID.',
	    409: 'Already deleted.',
	    429: 'Request throttled out by the backend server.',
	    500: 'Internal server error.',
	    503: 'Backend servers are over capacity. Try again later.',
	};
	/**
	 * Class that provides mechanism to send requests to the FIS backend endpoints.
	 */
	class FirebaseInstallationsRequestHandler {
	    /**
	     * @param app - The app used to fetch access tokens to sign API requests.
	     *
	     * @constructor
	     */
	    constructor(app) {
	        this.app = app;
	        this.host = FIREBASE_IID_HOST;
	        this.timeout = FIREBASE_IID_TIMEOUT;
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    deleteInstallation(fid) {
	        if (!validator.isNonEmptyString(fid)) {
	            return Promise.reject(new error_1.FirebaseInstallationsError(error_1.InstallationsClientErrorCode.INVALID_INSTALLATION_ID, 'Installation ID must be a non-empty string.'));
	        }
	        return this.invokeRequestHandler(new api_request_1.ApiSettings(fid, 'DELETE'));
	    }
	    /**
	     * Invokes the request handler based on the API settings object passed.
	     *
	     * @param apiSettings - The API endpoint settings to apply to request and response.
	     * @returns A promise that resolves when the request is complete.
	     */
	    invokeRequestHandler(apiSettings) {
	        return this.getPathPrefix()
	            .then((path) => {
	            const req = {
	                url: `https://${this.host}${path}${apiSettings.getEndpoint()}`,
	                method: apiSettings.getHttpMethod(),
	                timeout: this.timeout,
	            };
	            return this.httpClient.send(req);
	        })
	            .then(() => {
	            // return nothing on success
	        })
	            .catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                const response = err.response;
	                const errorMessage = (response.isJson() && 'error' in response.data) ?
	                    response.data.error : response.text;
	                const template = ERROR_CODES[response.status];
	                const message = template ?
	                    `Installation ID "${apiSettings.getEndpoint()}": ${template}` : errorMessage;
	                throw new error_1.FirebaseInstallationsError(error_1.InstallationsClientErrorCode.API_ERROR, message);
	            }
	            // In case of timeouts and other network errors, the HttpClient returns a
	            // FirebaseError wrapped in the response. Simply throw it here.
	            throw err;
	        });
	    }
	    getPathPrefix() {
	        if (this.path) {
	            return Promise.resolve(this.path);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                // Assert for an explicit projct ID (either via AppOptions or the cert itself).
	                throw new error_1.FirebaseInstallationsError(error_1.InstallationsClientErrorCode.INVALID_PROJECT_ID, 'Failed to determine project ID for Installations. Initialize the '
	                    + 'SDK with service account credentials or set project ID as an app option. '
	                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');
	            }
	            this.path = FIREBASE_IID_PATH + `project/${projectId}/instanceId/`;
	            return this.path;
	        });
	    }
	}
	installationsRequestHandler.FirebaseInstallationsRequestHandler = FirebaseInstallationsRequestHandler;
	return installationsRequestHandler;
}

/*! firebase-admin v12.7.0 */

var hasRequiredInstallations$1;

function requireInstallations$1 () {
	if (hasRequiredInstallations$1) return installations$1;
	hasRequiredInstallations$1 = 1;
	/*!
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(installations$1, "__esModule", { value: true });
	installations$1.Installations = void 0;
	const error_1 = error;
	const installations_request_handler_1 = /*@__PURE__*/ requireInstallationsRequestHandler();
	const validator = validator$2;
	/**
	 * The `Installations` service for the current app.
	 */
	class Installations {
	    /**
	     * @param app - The app for this Installations service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseInstallationsError(error_1.InstallationsClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.installations() must be a valid Firebase app instance.');
	        }
	        this.app_ = app;
	        this.requestHandler = new installations_request_handler_1.FirebaseInstallationsRequestHandler(app);
	    }
	    /**
	     * Deletes the specified installation ID and the associated data from Firebase.
	     *
	     * @param fid - The Firebase installation ID to be deleted.
	     *
	     * @returns A promise fulfilled when the installation ID is deleted.
	     */
	    deleteInstallation(fid) {
	        return this.requestHandler.deleteInstallation(fid);
	    }
	    /**
	     * Returns the app associated with this Installations instance.
	     *
	     * @returns The app associated with this Installations instance.
	     */
	    get app() {
	        return this.app_;
	    }
	}
	installations$1.Installations = Installations;
	return installations$1;
}

var instanceId$1 = {};

var installations = {};

/*! firebase-admin v12.7.0 */

var hasRequiredInstallations;

function requireInstallations () {
	if (hasRequiredInstallations) return installations;
	hasRequiredInstallations = 1;
	(function (exports) {
		/*!
		 * Copyright 2021 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.InstallationsClientErrorCode = exports.FirebaseInstallationsError = exports.getInstallations = exports.Installations = void 0;
		/**
		 * Firebase Instance ID service.
		 *
		 * @packageDocumentation
		 */
		const index_1 = /*@__PURE__*/ requireApp();
		const installations_1 = /*@__PURE__*/ requireInstallations$1();
		Object.defineProperty(exports, "Installations", { enumerable: true, get: function () { return installations_1.Installations; } });
		/**
		  * Gets the {@link Installations} service for the default app or a given app.
		  *
		  * `getInstallations()` can be called with no arguments to access the default
		  * app's `Installations` service or as `getInstallations(app)` to access the
		  * `Installations` service associated with a specific app.
		  *
		  * @example
		  * ```javascript
		  * // Get the Installations service for the default app
		  * const defaultInstallations = getInstallations();
		  * ```
		  *
		  * @example
		  * ```javascript
		  * // Get the Installations service for a given app
		  * const otherInstallations = getInstallations(otherApp);
		  *```
		  *
		  * @param app - Optional app whose `Installations` service to
		  *   return. If not provided, the default `Installations` service will be
		  *   returned.
		  *
		  * @returns The default `Installations` service if
		  *   no app is provided or the `Installations` service associated with the
		  *   provided app.
		  */
		function getInstallations(app) {
		    if (typeof app === 'undefined') {
		        app = (0, index_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('installations', (app) => new installations_1.Installations(app));
		}
		exports.getInstallations = getInstallations;
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseInstallationsError", { enumerable: true, get: function () { return error_1.FirebaseInstallationsError; } });
		Object.defineProperty(exports, "InstallationsClientErrorCode", { enumerable: true, get: function () { return error_1.InstallationsClientErrorCode; } }); 
	} (installations));
	return installations;
}

/*! firebase-admin v12.7.0 */

var hasRequiredInstanceId$1;

function requireInstanceId$1 () {
	if (hasRequiredInstanceId$1) return instanceId$1;
	hasRequiredInstanceId$1 = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(instanceId$1, "__esModule", { value: true });
	instanceId$1.InstanceId = void 0;
	const installations_1 = /*@__PURE__*/ requireInstallations();
	const error_1 = error;
	const validator = validator$2;
	/**
	 * The `InstanceId` service enables deleting the Firebase instance IDs
	 * associated with Firebase client app instances.
	 *
	 * @deprecated Use {@link firebase-admin.installations#Installations} instead.
	 */
	class InstanceId {
	    /**
	     * @param app - The app for this InstanceId service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseInstanceIdError(error_1.InstanceIdClientErrorCode.INVALID_ARGUMENT, 'First argument passed to instanceId() must be a valid Firebase app instance.');
	        }
	        this.app_ = app;
	    }
	    /**
	     * Deletes the specified instance ID and the associated data from Firebase.
	     *
	     * Note that Google Analytics for Firebase uses its own form of Instance ID to
	     * keep track of analytics data. Therefore deleting a Firebase Instance ID does
	     * not delete Analytics data. See
	     * {@link https://firebase.google.com/support/privacy/manage-iids#delete_an_instance_id |
	     * Delete an Instance ID}
	     * for more information.
	     *
	     * @param instanceId - The instance ID to be deleted.
	     *
	     * @returns A promise fulfilled when the instance ID is deleted.
	     */
	    deleteInstanceId(instanceId) {
	        return (0, installations_1.getInstallations)(this.app).deleteInstallation(instanceId)
	            .catch((err) => {
	            if (err instanceof error_1.FirebaseInstallationsError) {
	                let code = err.code.replace('installations/', '');
	                if (code === error_1.InstallationsClientErrorCode.INVALID_INSTALLATION_ID.code) {
	                    code = error_1.InstanceIdClientErrorCode.INVALID_INSTANCE_ID.code;
	                }
	                throw new error_1.FirebaseInstanceIdError({ code, message: err.message });
	            }
	            throw err;
	        });
	    }
	    /**
	     * Returns the app associated with this InstanceId instance.
	     *
	     * @returns The app associated with this InstanceId instance.
	     */
	    get app() {
	        return this.app_;
	    }
	}
	instanceId$1.InstanceId = InstanceId;
	return instanceId$1;
}

var projectManagement$1 = {};

var androidApp = {};

var projectManagementApiRequestInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredProjectManagementApiRequestInternal;

function requireProjectManagementApiRequestInternal () {
	if (hasRequiredProjectManagementApiRequestInternal) return projectManagementApiRequestInternal;
	hasRequiredProjectManagementApiRequestInternal = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(projectManagementApiRequestInternal, "__esModule", { value: true });
	projectManagementApiRequestInternal.ProjectManagementRequestHandler = projectManagementApiRequestInternal.assertServerResponse = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const error_1 = error;
	const index_1 = utils$1;
	const validator = validator$2;
	/** Project management backend host and port. */
	const PROJECT_MANAGEMENT_HOST_AND_PORT = 'firebase.googleapis.com:443';
	/** Project management backend path. */
	const PROJECT_MANAGEMENT_PATH = '/v1/';
	/** Project management beta backend path. */
	const PROJECT_MANAGEMENT_BETA_PATH = '/v1beta1/';
	/** Project management request header. */
	const PROJECT_MANAGEMENT_HEADERS = {
	    'X-Client-Version': `Node/Admin/${(0, index_1.getSdkVersion)()}`,
	};
	/** Project management request timeout duration in milliseconds. */
	const PROJECT_MANAGEMENT_TIMEOUT_MILLIS = 10000;
	const LIST_APPS_MAX_PAGE_SIZE = 100;
	const CERT_TYPE_API_MAP = {
	    sha1: 'SHA_1',
	    sha256: 'SHA_256',
	};
	function assertServerResponse(condition, responseData, message) {
	    if (!condition) {
	        throw new error_1.FirebaseProjectManagementError('invalid-server-response', `${message} Response data: ${JSON.stringify(responseData, null, 2)}`);
	    }
	}
	projectManagementApiRequestInternal.assertServerResponse = assertServerResponse;
	/**
	 * Class that provides mechanism to send requests to the Firebase project management backend
	 * endpoints.
	 *
	 * @internal
	 */
	class ProjectManagementRequestHandler {
	    static wrapAndRethrowHttpError(errStatusCode, errText) {
	        let errorCode;
	        let errorMessage;
	        switch (errStatusCode) {
	            case 400:
	                errorCode = 'invalid-argument';
	                errorMessage = 'Invalid argument provided.';
	                break;
	            case 401:
	            case 403:
	                errorCode = 'authentication-error';
	                errorMessage = 'An error occurred when trying to authenticate. Make sure the credential '
	                    + 'used to authenticate this SDK has the proper permissions. See '
	                    + 'https://firebase.google.com/docs/admin/setup for setup instructions.';
	                break;
	            case 404:
	                errorCode = 'not-found';
	                errorMessage = 'The specified entity could not be found.';
	                break;
	            case 409:
	                errorCode = 'already-exists';
	                errorMessage = 'The specified entity already exists.';
	                break;
	            case 500:
	                errorCode = 'internal-error';
	                errorMessage = 'An internal error has occurred. Please retry the request.';
	                break;
	            case 503:
	                errorCode = 'service-unavailable';
	                errorMessage = 'The server could not process the request in time. See the error '
	                    + 'documentation for more details.';
	                break;
	            default:
	                errorCode = 'unknown-error';
	                errorMessage = 'An unknown server error was returned.';
	        }
	        if (!errText) {
	            errText = '<missing>';
	        }
	        throw new error_1.FirebaseProjectManagementError(errorCode, `${errorMessage} Status code: ${errStatusCode}. Raw server response: "${errText}".`);
	    }
	    /**
	     * @param app - The app used to fetch access tokens to sign API requests.
	     * @constructor
	     */
	    constructor(app) {
	        this.baseUrl = `https://${PROJECT_MANAGEMENT_HOST_AND_PORT}${PROJECT_MANAGEMENT_PATH}`;
	        this.baseBetaUrl = `https://${PROJECT_MANAGEMENT_HOST_AND_PORT}${PROJECT_MANAGEMENT_BETA_PATH}`;
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the project whose Android
	     *     apps you want to list.
	     */
	    listAndroidApps(parentResourceName) {
	        return this.invokeRequestHandler('GET', `${parentResourceName}/androidApps?page_size=${LIST_APPS_MAX_PAGE_SIZE}`, 
	        /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the project whose iOS apps
	     *     you want to list.
	     */
	    listIosApps(parentResourceName) {
	        return this.invokeRequestHandler('GET', `${parentResourceName}/iosApps?page_size=${LIST_APPS_MAX_PAGE_SIZE}`, 
	        /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the project whose iOS apps
	     *     you want to list.
	     */
	    listAppMetadata(parentResourceName) {
	        return this.invokeRequestHandler('GET', `${parentResourceName}:searchApps?page_size=${LIST_APPS_MAX_PAGE_SIZE}`, 
	        /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the project that you want
	     *     to create the Android app within.
	     */
	    createAndroidApp(parentResourceName, packageName, displayName) {
	        const requestData = {
	            packageName,
	        };
	        if (validator.isNonEmptyString(displayName)) {
	            requestData.displayName = displayName;
	        }
	        return this
	            .invokeRequestHandler('POST', `${parentResourceName}/androidApps`, requestData, 'v1beta1')
	            .then((responseData) => {
	            assertServerResponse(validator.isNonNullObject(responseData), responseData, 'createAndroidApp\'s responseData must be a non-null object.');
	            assertServerResponse(validator.isNonEmptyString(responseData.name), responseData, 'createAndroidApp\'s responseData.name must be a non-empty string.');
	            return this.pollRemoteOperationWithExponentialBackoff(responseData.name);
	        });
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the project that you want
	     *     to create the iOS app within.
	     */
	    createIosApp(parentResourceName, bundleId, displayName) {
	        const requestData = {
	            bundleId,
	        };
	        if (validator.isNonEmptyString(displayName)) {
	            requestData.displayName = displayName;
	        }
	        return this
	            .invokeRequestHandler('POST', `${parentResourceName}/iosApps`, requestData, 'v1beta1')
	            .then((responseData) => {
	            assertServerResponse(validator.isNonNullObject(responseData), responseData, 'createIosApp\'s responseData must be a non-null object.');
	            assertServerResponse(validator.isNonEmptyString(responseData.name), responseData, 'createIosApp\'s responseData.name must be a non-empty string.');
	            return this.pollRemoteOperationWithExponentialBackoff(responseData.name);
	        });
	    }
	    /**
	     * @param resourceName - Fully-qualified resource name of the entity whose display name you
	     *     want to set.
	     */
	    setDisplayName(resourceName, newDisplayName) {
	        const requestData = {
	            displayName: newDisplayName,
	        };
	        return this
	            .invokeRequestHandler('PATCH', `${resourceName}?update_mask=display_name`, requestData, 'v1beta1')
	            .then(() => undefined);
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the Android app whose SHA
	     *     certificates you want to get.
	     */
	    getAndroidShaCertificates(parentResourceName) {
	        return this.invokeRequestHandler('GET', `${parentResourceName}/sha`, /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the Android app that you
	     *     want to add the given SHA certificate to.
	     */
	    addAndroidShaCertificate(parentResourceName, certificate) {
	        const requestData = {
	            shaHash: certificate.shaHash,
	            certType: CERT_TYPE_API_MAP[certificate.certType],
	        };
	        return this
	            .invokeRequestHandler('POST', `${parentResourceName}/sha`, requestData, 'v1beta1')
	            .then(() => undefined);
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the app whose config you
	     *     want to get.
	     */
	    getConfig(parentResourceName) {
	        return this.invokeRequestHandler('GET', `${parentResourceName}/config`, /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param parentResourceName - Fully-qualified resource name of the entity that you want to
	     *     get.
	     */
	    getResource(parentResourceName) {
	        return this.invokeRequestHandler('GET', parentResourceName, /* requestData */ null, 'v1beta1');
	    }
	    /**
	     * @param resourceName - Fully-qualified resource name of the entity that you want to
	     *     delete.
	     */
	    deleteResource(resourceName) {
	        return this
	            .invokeRequestHandler('DELETE', resourceName, /* requestData */ null, 'v1beta1')
	            .then(() => undefined);
	    }
	    pollRemoteOperationWithExponentialBackoff(operationResourceName) {
	        const poller = new api_request_1.ExponentialBackoffPoller();
	        return poller.poll(() => {
	            return this.invokeRequestHandler('GET', operationResourceName, /* requestData */ null)
	                .then((responseData) => {
	                if (responseData.error) {
	                    const errStatusCode = responseData.error.code || 500;
	                    const errText = responseData.error.message || JSON.stringify(responseData.error);
	                    ProjectManagementRequestHandler.wrapAndRethrowHttpError(errStatusCode, errText);
	                }
	                if (!responseData.done) {
	                    // Continue polling.
	                    return null;
	                }
	                // Polling complete. Resolve with operation response JSON.
	                return responseData.response;
	            });
	        });
	    }
	    /**
	     * Invokes the request handler with the provided request data.
	     */
	    invokeRequestHandler(method, path, requestData, apiVersion = 'v1') {
	        const baseUrlToUse = (apiVersion === 'v1') ? this.baseUrl : this.baseBetaUrl;
	        const request = {
	            method,
	            url: `${baseUrlToUse}${path}`,
	            headers: PROJECT_MANAGEMENT_HEADERS,
	            data: requestData,
	            timeout: PROJECT_MANAGEMENT_TIMEOUT_MILLIS,
	        };
	        return this.httpClient.send(request)
	            .then((response) => {
	            // Send non-JSON responses to the catch() below, where they will be treated as errors.
	            if (!response.isJson()) {
	                throw new api_request_1.RequestResponseError(response);
	            }
	            return response.data;
	        })
	            .catch((err) => {
	            if (err instanceof api_request_1.RequestResponseError) {
	                ProjectManagementRequestHandler.wrapAndRethrowHttpError(err.response.status, err.response.text);
	            }
	            throw err;
	        });
	    }
	}
	projectManagementApiRequestInternal.ProjectManagementRequestHandler = ProjectManagementRequestHandler;
	return projectManagementApiRequestInternal;
}

var appMetadata = {};

/*! firebase-admin v12.7.0 */

var hasRequiredAppMetadata;

function requireAppMetadata () {
	if (hasRequiredAppMetadata) return appMetadata;
	hasRequiredAppMetadata = 1;
	/*!
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(appMetadata, "__esModule", { value: true });
	appMetadata.AppPlatform = void 0;
	/**
	 * Platforms with which a Firebase App can be associated.
	 */
	var AppPlatform;
	(function (AppPlatform) {
	    /**
	     * Unknown state. This is only used for distinguishing unset values.
	     */
	    AppPlatform["PLATFORM_UNKNOWN"] = "PLATFORM_UNKNOWN";
	    /**
	     * The Firebase App is associated with iOS.
	     */
	    AppPlatform["IOS"] = "IOS";
	    /**
	     * The Firebase App is associated with Android.
	     */
	    AppPlatform["ANDROID"] = "ANDROID";
	})(AppPlatform || (appMetadata.AppPlatform = AppPlatform = {}));
	return appMetadata;
}

/*! firebase-admin v12.7.0 */

var hasRequiredAndroidApp;

function requireAndroidApp () {
	if (hasRequiredAndroidApp) return androidApp;
	hasRequiredAndroidApp = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(androidApp, "__esModule", { value: true });
	androidApp.ShaCertificate = androidApp.AndroidApp = void 0;
	const error_1 = error;
	const validator = validator$2;
	const project_management_api_request_internal_1 = /*@__PURE__*/ requireProjectManagementApiRequestInternal();
	const app_metadata_1 = /*@__PURE__*/ requireAppMetadata();
	/**
	 * A reference to a Firebase Android app.
	 *
	 * Do not call this constructor directly. Instead, use {@link ProjectManagement.androidApp}.
	 */
	class AndroidApp {
	    /**
	     * @internal
	     */
	    constructor(appId, requestHandler) {
	        this.appId = appId;
	        this.requestHandler = requestHandler;
	        if (!validator.isNonEmptyString(appId)) {
	            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'appId must be a non-empty string.');
	        }
	        this.resourceName = `projects/-/androidApps/${appId}`;
	    }
	    /**
	     * Retrieves metadata about this Android app.
	     *
	     * @returns A promise that resolves to the retrieved metadata about this Android app.
	     */
	    getMetadata() {
	        return this.requestHandler.getResource(this.resourceName)
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getMetadata()\'s responseData must be a non-null object.');
	            const requiredFieldsList = ['name', 'appId', 'projectId', 'packageName'];
	            requiredFieldsList.forEach((requiredField) => {
	                (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(responseData[requiredField]), responseData, `getMetadata()'s responseData.${requiredField} must be a non-empty string.`);
	            });
	            const metadata = {
	                platform: app_metadata_1.AppPlatform.ANDROID,
	                resourceName: responseData.name,
	                appId: responseData.appId,
	                displayName: responseData.displayName || null,
	                projectId: responseData.projectId,
	                packageName: responseData.packageName,
	            };
	            return metadata;
	        });
	    }
	    /**
	     * Sets the optional user-assigned display name of the app.
	     *
	     * @param newDisplayName - The new display name to set.
	     *
	     * @returns A promise that resolves when the display name has been set.
	     */
	    setDisplayName(newDisplayName) {
	        return this.requestHandler.setDisplayName(this.resourceName, newDisplayName);
	    }
	    /**
	     * Gets the list of SHA certificates associated with this Android app in Firebase.
	     *
	     * @returns The list of SHA-1 and SHA-256 certificates associated with this Android app in
	     *     Firebase.
	     */
	    getShaCertificates() {
	        return this.requestHandler.getAndroidShaCertificates(this.resourceName)
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getShaCertificates()\'s responseData must be a non-null object.');
	            if (!responseData.certificates) {
	                return [];
	            }
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isArray(responseData.certificates), responseData, '"certificates" field must be present in the getShaCertificates() response data.');
	            const requiredFieldsList = ['name', 'shaHash'];
	            return responseData.certificates.map((certificateJson) => {
	                requiredFieldsList.forEach((requiredField) => {
	                    (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(certificateJson[requiredField]), responseData, `getShaCertificates()'s responseData.certificates[].${requiredField} must be a `
	                        + 'non-empty string.');
	                });
	                return new ShaCertificate(certificateJson.shaHash, certificateJson.name);
	            });
	        });
	    }
	    /**
	     * Adds the given SHA certificate to this Android app.
	     *
	     * @param certificateToAdd - The SHA certificate to add.
	     *
	     * @returns A promise that resolves when the given certificate
	     *     has been added to the Android app.
	     */
	    addShaCertificate(certificateToAdd) {
	        return this.requestHandler.addAndroidShaCertificate(this.resourceName, certificateToAdd);
	    }
	    /**
	     * Deletes the specified SHA certificate from this Android app.
	     *
	     * @param certificateToDelete - The SHA certificate to delete.
	     *
	     * @returns A promise that resolves when the specified
	     *     certificate has been removed from the Android app.
	     */
	    deleteShaCertificate(certificateToDelete) {
	        if (!certificateToDelete.resourceName) {
	            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'Specified certificate does not include a resourceName. (Use AndroidApp.getShaCertificates() to retrieve ' +
	                'certificates with a resourceName.');
	        }
	        return this.requestHandler.deleteResource(certificateToDelete.resourceName);
	    }
	    /**
	     * Gets the configuration artifact associated with this app.
	     *
	     * @returns A promise that resolves to the Android app's
	     *     Firebase config file, in UTF-8 string format. This string is typically
	     *     intended to be written to a JSON file that gets shipped with your Android
	     *     app.
	     */
	    getConfig() {
	        return this.requestHandler.getConfig(this.resourceName)
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getConfig()\'s responseData must be a non-null object.');
	            const base64ConfigFileContents = responseData.configFileContents;
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isBase64String(base64ConfigFileContents), responseData, 'getConfig()\'s responseData.configFileContents must be a base64 string.');
	            return Buffer.from(base64ConfigFileContents, 'base64').toString('utf8');
	        });
	    }
	}
	androidApp.AndroidApp = AndroidApp;
	/**
	 * A SHA-1 or SHA-256 certificate.
	 *
	 * Do not call this constructor directly. Instead, use
	 * [`projectManagement.shaCertificate()`](projectManagement.ProjectManagement#shaCertificate).
	 */
	class ShaCertificate {
	    /**
	     * Creates a ShaCertificate using the given hash. The ShaCertificate's type (eg. 'sha256') is
	     * automatically determined from the hash itself.
	     *
	     * @param shaHash - The sha256 or sha1 hash for this certificate.
	     * @example
	     * ```javascript
	     * var shaHash = shaCertificate.shaHash;
	     * ```
	     * @param resourceName - The Firebase resource name for this certificate. This does not need to be
	     *     set when creating a new certificate.
	     * @example
	     * ```javascript
	     * var resourceName = shaCertificate.resourceName;
	     * ```
	     *
	     * @internal
	     */
	    constructor(shaHash, resourceName) {
	        this.shaHash = shaHash;
	        this.resourceName = resourceName;
	        if (/^[a-fA-F0-9]{40}$/.test(shaHash)) {
	            this.certType = 'sha1';
	        }
	        else if (/^[a-fA-F0-9]{64}$/.test(shaHash)) {
	            this.certType = 'sha256';
	        }
	        else {
	            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'shaHash must be either a sha256 hash or a sha1 hash.');
	        }
	    }
	}
	androidApp.ShaCertificate = ShaCertificate;
	return androidApp;
}

var iosApp = {};

/*! firebase-admin v12.7.0 */

var hasRequiredIosApp;

function requireIosApp () {
	if (hasRequiredIosApp) return iosApp;
	hasRequiredIosApp = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(iosApp, "__esModule", { value: true });
	iosApp.IosApp = void 0;
	const error_1 = error;
	const validator = validator$2;
	const project_management_api_request_internal_1 = /*@__PURE__*/ requireProjectManagementApiRequestInternal();
	const app_metadata_1 = /*@__PURE__*/ requireAppMetadata();
	/**
	 * A reference to a Firebase iOS app.
	 *
	 * Do not call this constructor directly. Instead, use {@link ProjectManagement.iosApp}.
	 */
	class IosApp {
	    /**
	     * @internal
	     */
	    constructor(appId, requestHandler) {
	        this.appId = appId;
	        this.requestHandler = requestHandler;
	        if (!validator.isNonEmptyString(appId)) {
	            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'appId must be a non-empty string.');
	        }
	        this.resourceName = `projects/-/iosApps/${appId}`;
	    }
	    /**
	     * Retrieves metadata about this iOS app.
	     *
	     * @returns A promise that
	     *     resolves to the retrieved metadata about this iOS app.
	     */
	    getMetadata() {
	        return this.requestHandler.getResource(this.resourceName)
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getMetadata()\'s responseData must be a non-null object.');
	            const requiredFieldsList = ['name', 'appId', 'projectId', 'bundleId'];
	            requiredFieldsList.forEach((requiredField) => {
	                (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(responseData[requiredField]), responseData, `getMetadata()'s responseData.${requiredField} must be a non-empty string.`);
	            });
	            const metadata = {
	                platform: app_metadata_1.AppPlatform.IOS,
	                resourceName: responseData.name,
	                appId: responseData.appId,
	                displayName: responseData.displayName || null,
	                projectId: responseData.projectId,
	                bundleId: responseData.bundleId,
	            };
	            return metadata;
	        });
	    }
	    /**
	     * Sets the optional user-assigned display name of the app.
	     *
	     * @param newDisplayName - The new display name to set.
	     *
	     * @returns A promise that resolves when the display name has
	     *     been set.
	     */
	    setDisplayName(newDisplayName) {
	        return this.requestHandler.setDisplayName(this.resourceName, newDisplayName);
	    }
	    /**
	     * Gets the configuration artifact associated with this app.
	     *
	     * @returns A promise that resolves to the iOS app's Firebase
	     *     config file, in UTF-8 string format. This string is typically intended to
	     *     be written to a plist file that gets shipped with your iOS app.
	     */
	    getConfig() {
	        return this.requestHandler.getConfig(this.resourceName)
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getConfig()\'s responseData must be a non-null object.');
	            const base64ConfigFileContents = responseData.configFileContents;
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isBase64String(base64ConfigFileContents), responseData, 'getConfig()\'s responseData.configFileContents must be a base64 string.');
	            return Buffer.from(base64ConfigFileContents, 'base64').toString('utf8');
	        });
	    }
	}
	iosApp.IosApp = IosApp;
	return iosApp;
}

/*! firebase-admin v12.7.0 */

var hasRequiredProjectManagement$1;

function requireProjectManagement$1 () {
	if (hasRequiredProjectManagement$1) return projectManagement$1;
	hasRequiredProjectManagement$1 = 1;
	/*!
	 * Copyright 2018 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(projectManagement$1, "__esModule", { value: true });
	projectManagement$1.ProjectManagement = void 0;
	const error_1 = error;
	const utils = utils$1;
	const validator = validator$2;
	const android_app_1 = /*@__PURE__*/ requireAndroidApp();
	const ios_app_1 = /*@__PURE__*/ requireIosApp();
	const project_management_api_request_internal_1 = /*@__PURE__*/ requireProjectManagementApiRequestInternal();
	const app_metadata_1 = /*@__PURE__*/ requireAppMetadata();
	/**
	 * The Firebase ProjectManagement service interface.
	 */
	class ProjectManagement {
	    /**
	     * @param app - The app for this ProjectManagement service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.app = app;
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'First argument passed to admin.projectManagement() must be a valid Firebase app '
	                + 'instance.');
	        }
	        this.requestHandler = new project_management_api_request_internal_1.ProjectManagementRequestHandler(app);
	    }
	    /**
	     * Lists up to 100 Firebase Android apps associated with this Firebase project.
	     *
	     * @returns The list of Android apps.
	     */
	    listAndroidApps() {
	        return this.listPlatformApps('android', 'listAndroidApps()');
	    }
	    /**
	     * Lists up to 100 Firebase iOS apps associated with this Firebase project.
	     *
	     * @returns The list of iOS apps.
	     */
	    listIosApps() {
	        return this.listPlatformApps('ios', 'listIosApps()');
	    }
	    /**
	     * Creates an `AndroidApp` object, referencing the specified Android app within
	     * this Firebase project.
	     *
	     * This method does not perform an RPC.
	     *
	     * @param appId - The `appId` of the Android app to reference.
	     *
	     * @returns An `AndroidApp` object that references the specified Firebase Android app.
	     */
	    androidApp(appId) {
	        return new android_app_1.AndroidApp(appId, this.requestHandler);
	    }
	    /**
	     * Creates an `iOSApp` object, referencing the specified iOS app within
	     * this Firebase project.
	     *
	     * This method does not perform an RPC.
	     *
	     * @param appId - The `appId` of the iOS app to reference.
	     *
	     * @returns An `iOSApp` object that references the specified Firebase iOS app.
	     */
	    iosApp(appId) {
	        return new ios_app_1.IosApp(appId, this.requestHandler);
	    }
	    /**
	     * Creates a `ShaCertificate` object.
	     *
	     * This method does not perform an RPC.
	     *
	     * @param shaHash - The SHA-1 or SHA-256 hash for this certificate.
	     *
	     * @returns A `ShaCertificate` object contains the specified SHA hash.
	     */
	    shaCertificate(shaHash) {
	        return new android_app_1.ShaCertificate(shaHash);
	    }
	    /**
	     * Creates a new Firebase Android app associated with this Firebase project.
	     *
	     * @param packageName - The canonical package name of the Android App,
	     *     as would appear in the Google Play Developer Console.
	     * @param displayName - An optional user-assigned display name for this
	     *     new app.
	     *
	     * @returns A promise that resolves to the newly created Android app.
	     */
	    createAndroidApp(packageName, displayName) {
	        return this.getResourceName()
	            .then((resourceName) => {
	            return this.requestHandler.createAndroidApp(resourceName, packageName, displayName);
	        })
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'createAndroidApp()\'s responseData must be a non-null object.');
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(responseData.appId), responseData, '"responseData.appId" field must be present in createAndroidApp()\'s response data.');
	            return new android_app_1.AndroidApp(responseData.appId, this.requestHandler);
	        });
	    }
	    /**
	     * Creates a new Firebase iOS app associated with this Firebase project.
	     *
	     * @param bundleId - The iOS app bundle ID to use for this new app.
	     * @param displayName - An optional user-assigned display name for this
	     *     new app.
	     *
	     * @returns A promise that resolves to the newly created iOS app.
	     */
	    createIosApp(bundleId, displayName) {
	        return this.getResourceName()
	            .then((resourceName) => {
	            return this.requestHandler.createIosApp(resourceName, bundleId, displayName);
	        })
	            .then((responseData) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'createIosApp()\'s responseData must be a non-null object.');
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(responseData.appId), responseData, '"responseData.appId" field must be present in createIosApp()\'s response data.');
	            return new ios_app_1.IosApp(responseData.appId, this.requestHandler);
	        });
	    }
	    /**
	     * Lists up to 100 Firebase apps associated with this Firebase project.
	     *
	     * @returns A promise that resolves to the metadata list of the apps.
	     */
	    listAppMetadata() {
	        return this.getResourceName()
	            .then((resourceName) => {
	            return this.requestHandler.listAppMetadata(resourceName);
	        })
	            .then((responseData) => {
	            return this.getProjectId()
	                .then((projectId) => {
	                return this.transformResponseToAppMetadata(responseData, projectId);
	            });
	        });
	    }
	    /**
	     * Update the display name of this Firebase project.
	     *
	     * @param newDisplayName - The new display name to be updated.
	     *
	     * @returns A promise that resolves when the project display name has been updated.
	     */
	    setDisplayName(newDisplayName) {
	        return this.getResourceName()
	            .then((resourceName) => {
	            return this.requestHandler.setDisplayName(resourceName, newDisplayName);
	        });
	    }
	    transformResponseToAppMetadata(responseData, projectId) {
	        this.assertListAppsResponseData(responseData, 'listAppMetadata()');
	        if (!responseData.apps) {
	            return [];
	        }
	        return responseData.apps.map((appJson) => {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(appJson.appId), responseData, '"apps[].appId" field must be present in the listAppMetadata() response data.');
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(appJson.platform), responseData, '"apps[].platform" field must be present in the listAppMetadata() response data.');
	            const metadata = {
	                appId: appJson.appId,
	                platform: app_metadata_1.AppPlatform[appJson.platform] || app_metadata_1.AppPlatform.PLATFORM_UNKNOWN,
	                projectId,
	                resourceName: appJson.name,
	            };
	            if (appJson.displayName) {
	                metadata.displayName = appJson.displayName;
	            }
	            return metadata;
	        });
	    }
	    getResourceName() {
	        return this.getProjectId()
	            .then((projectId) => {
	            return `projects/${projectId}`;
	        });
	    }
	    getProjectId() {
	        if (this.projectId) {
	            return Promise.resolve(this.projectId);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            // Assert that a specific project ID was provided within the app.
	            if (!validator.isNonEmptyString(projectId)) {
	                throw new error_1.FirebaseProjectManagementError('invalid-project-id', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
	                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
	                    + 'environment variable.');
	            }
	            this.projectId = projectId;
	            return this.projectId;
	        });
	    }
	    /**
	     * Lists up to 100 Firebase apps for a specified platform, associated with this Firebase project.
	     */
	    listPlatformApps(platform, callerName) {
	        return this.getResourceName()
	            .then((resourceName) => {
	            return (platform === 'android') ?
	                this.requestHandler.listAndroidApps(resourceName)
	                : this.requestHandler.listIosApps(resourceName);
	        })
	            .then((responseData) => {
	            this.assertListAppsResponseData(responseData, callerName);
	            if (!responseData.apps) {
	                return [];
	            }
	            return responseData.apps.map((appJson) => {
	                (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonEmptyString(appJson.appId), responseData, `"apps[].appId" field must be present in the ${callerName} response data.`);
	                if (platform === 'android') {
	                    return new android_app_1.AndroidApp(appJson.appId, this.requestHandler);
	                }
	                else {
	                    return new ios_app_1.IosApp(appJson.appId, this.requestHandler);
	                }
	            });
	        });
	    }
	    assertListAppsResponseData(responseData, callerName) {
	        (0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, `${callerName}'s responseData must be a non-null object.`);
	        if (responseData.apps) {
	            (0, project_management_api_request_internal_1.assertServerResponse)(validator.isArray(responseData.apps), responseData, `"apps" field must be present in the ${callerName} response data.`);
	        }
	    }
	}
	projectManagement$1.ProjectManagement = ProjectManagement;
	return projectManagement$1;
}

var securityRules$1 = {};

var securityRulesApiClientInternal = {};

var securityRulesInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredSecurityRulesInternal;

function requireSecurityRulesInternal () {
	if (hasRequiredSecurityRulesInternal) return securityRulesInternal;
	hasRequiredSecurityRulesInternal = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(securityRulesInternal, "__esModule", { value: true });
	securityRulesInternal.FirebaseSecurityRulesError = void 0;
	const error_1 = error;
	class FirebaseSecurityRulesError extends error_1.PrefixedFirebaseError {
	    constructor(code, message) {
	        super('security-rules', code, message);
	    }
	}
	securityRulesInternal.FirebaseSecurityRulesError = FirebaseSecurityRulesError;
	return securityRulesInternal;
}

/*! firebase-admin v12.7.0 */

var hasRequiredSecurityRulesApiClientInternal;

function requireSecurityRulesApiClientInternal () {
	if (hasRequiredSecurityRulesApiClientInternal) return securityRulesApiClientInternal;
	hasRequiredSecurityRulesApiClientInternal = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(securityRulesApiClientInternal, "__esModule", { value: true });
	securityRulesApiClientInternal.SecurityRulesApiClient = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const error_1 = error;
	const security_rules_internal_1 = /*@__PURE__*/ requireSecurityRulesInternal();
	const utils = utils$1;
	const validator = validator$2;
	const RULES_V1_API = 'https://firebaserules.googleapis.com/v1';
	const FIREBASE_VERSION_HEADER = {
	    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,
	};
	/**
	 * Class that facilitates sending requests to the Firebase security rules backend API.
	 *
	 * @private
	 */
	class SecurityRulesApiClient {
	    constructor(app) {
	        this.app = app;
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'First argument passed to admin.securityRules() must be a valid Firebase app '
	                + 'instance.');
	        }
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    getRuleset(name) {
	        return Promise.resolve()
	            .then(() => {
	            return this.getRulesetName(name);
	        })
	            .then((rulesetName) => {
	            return this.getResource(rulesetName);
	        });
	    }
	    createRuleset(ruleset) {
	        if (!validator.isNonNullObject(ruleset) ||
	            !validator.isNonNullObject(ruleset.source) ||
	            !validator.isNonEmptyArray(ruleset.source.files)) {
	            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid rules content.');
	            return Promise.reject(err);
	        }
	        for (const rf of ruleset.source.files) {
	            if (!validator.isNonNullObject(rf) ||
	                !validator.isNonEmptyString(rf.name) ||
	                !validator.isNonEmptyString(rf.content)) {
	                const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid rules file argument: ${JSON.stringify(rf)}`);
	                return Promise.reject(err);
	            }
	        }
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'POST',
	                url: `${url}/rulesets`,
	                data: ruleset,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    deleteRuleset(name) {
	        return this.getUrl()
	            .then((url) => {
	            const rulesetName = this.getRulesetName(name);
	            const request = {
	                method: 'DELETE',
	                url: `${url}/${rulesetName}`,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    listRulesets(pageSize = 100, pageToken) {
	        if (!validator.isNumber(pageSize)) {
	            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid page size.');
	            return Promise.reject(err);
	        }
	        if (pageSize < 1 || pageSize > 100) {
	            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Page size must be between 1 and 100.');
	            return Promise.reject(err);
	        }
	        if (typeof pageToken !== 'undefined' && !validator.isNonEmptyString(pageToken)) {
	            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Next page token must be a non-empty string.');
	            return Promise.reject(err);
	        }
	        const data = {
	            pageSize,
	            pageToken,
	        };
	        if (!pageToken) {
	            delete data.pageToken;
	        }
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/rulesets`,
	                data,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    getRelease(name) {
	        return this.getResource(`releases/${name}`);
	    }
	    updateOrCreateRelease(name, rulesetName) {
	        return this.updateRelease(name, rulesetName).catch((error) => {
	            // if ruleset update failed with a NOT_FOUND error, attempt to create instead.
	            if (error.code === `security-rules/${ERROR_CODE_MAPPING.NOT_FOUND}`) {
	                return this.createRelease(name, rulesetName);
	            }
	            throw error;
	        });
	    }
	    updateRelease(name, rulesetName) {
	        return this.getUrl()
	            .then((url) => {
	            return this.getReleaseDescription(name, rulesetName)
	                .then((release) => {
	                const request = {
	                    method: 'PATCH',
	                    url: `${url}/releases/${name}`,
	                    data: { release },
	                };
	                return this.sendRequest(request);
	            });
	        });
	    }
	    createRelease(name, rulesetName) {
	        return this.getUrl()
	            .then((url) => {
	            return this.getReleaseDescription(name, rulesetName)
	                .then((release) => {
	                const request = {
	                    method: 'POST',
	                    url: `${url}/releases`,
	                    data: release,
	                };
	                return this.sendRequest(request);
	            });
	        });
	    }
	    getUrl() {
	        return this.getProjectIdPrefix()
	            .then((projectIdPrefix) => {
	            return `${RULES_V1_API}/${projectIdPrefix}`;
	        });
	    }
	    getProjectIdPrefix() {
	        if (this.projectIdPrefix) {
	            return Promise.resolve(this.projectIdPrefix);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
	                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
	                    + 'environment variable.');
	            }
	            this.projectIdPrefix = `projects/${projectId}`;
	            return this.projectIdPrefix;
	        });
	    }
	    /**
	     * Gets the specified resource from the rules API. Resource names must be the short names without project
	     * ID prefix (e.g. `rulesets/ruleset-name`).
	     *
	     * @param {string} name Full qualified name of the resource to get.
	     * @returns {Promise<T>} A promise that fulfills with the resource.
	     */
	    getResource(name) {
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/${name}`,
	            };
	            return this.sendRequest(request);
	        });
	    }
	    getReleaseDescription(name, rulesetName) {
	        return this.getProjectIdPrefix()
	            .then((projectIdPrefix) => {
	            return {
	                name: `${projectIdPrefix}/releases/${name}`,
	                rulesetName: `${projectIdPrefix}/${this.getRulesetName(rulesetName)}`,
	            };
	        });
	    }
	    getRulesetName(name) {
	        if (!validator.isNonEmptyString(name)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must be a non-empty string.');
	        }
	        if (name.indexOf('/') !== -1) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must not contain any "/" characters.');
	        }
	        return `rulesets/${name}`;
	    }
	    sendRequest(request) {
	        request.headers = FIREBASE_VERSION_HEADER;
	        return this.httpClient.send(request)
	            .then((resp) => {
	            return resp.data;
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    toFirebaseError(err) {
	        if (err instanceof error_1.PrefixedFirebaseError) {
	            return err;
	        }
	        const response = err.response;
	        if (!response.isJson()) {
	            return new security_rules_internal_1.FirebaseSecurityRulesError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);
	        }
	        const error = response.data.error || {};
	        let code = 'unknown-error';
	        if (error.status && error.status in ERROR_CODE_MAPPING) {
	            code = ERROR_CODE_MAPPING[error.status];
	        }
	        const message = error.message || `Unknown server error: ${response.text}`;
	        return new security_rules_internal_1.FirebaseSecurityRulesError(code, message);
	    }
	}
	securityRulesApiClientInternal.SecurityRulesApiClient = SecurityRulesApiClient;
	const ERROR_CODE_MAPPING = {
	    INVALID_ARGUMENT: 'invalid-argument',
	    NOT_FOUND: 'not-found',
	    RESOURCE_EXHAUSTED: 'resource-exhausted',
	    UNAUTHENTICATED: 'authentication-error',
	    UNKNOWN: 'unknown-error',
	};
	return securityRulesApiClientInternal;
}

/*! firebase-admin v12.7.0 */

var hasRequiredSecurityRules$1;

function requireSecurityRules$1 () {
	if (hasRequiredSecurityRules$1) return securityRules$1;
	hasRequiredSecurityRules$1 = 1;
	/*!
	 * Copyright 2019 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(securityRules$1, "__esModule", { value: true });
	securityRules$1.SecurityRules = securityRules$1.Ruleset = securityRules$1.RulesetMetadataList = void 0;
	const validator = validator$2;
	const security_rules_api_client_internal_1 = /*@__PURE__*/ requireSecurityRulesApiClientInternal();
	const security_rules_internal_1 = /*@__PURE__*/ requireSecurityRulesInternal();
	/**
	 * A page of ruleset metadata.
	 */
	class RulesetMetadataList {
	    /**
	     * @internal
	     */
	    constructor(response) {
	        if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: ${JSON.stringify(response)}`);
	        }
	        this.rulesets = response.rulesets.map((rs) => {
	            return {
	                name: stripProjectIdPrefix(rs.name),
	                createTime: new Date(rs.createTime).toUTCString(),
	            };
	        });
	        if (response.nextPageToken) {
	            this.nextPageToken = response.nextPageToken;
	        }
	    }
	}
	securityRules$1.RulesetMetadataList = RulesetMetadataList;
	/**
	 * A set of Firebase security rules.
	 */
	class Ruleset {
	    /**
	     * @internal
	     */
	    constructor(ruleset) {
	        if (!validator.isNonNullObject(ruleset) ||
	            !validator.isNonEmptyString(ruleset.name) ||
	            !validator.isNonEmptyString(ruleset.createTime) ||
	            !validator.isNonNullObject(ruleset.source)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: ${JSON.stringify(ruleset)}`);
	        }
	        this.name = stripProjectIdPrefix(ruleset.name);
	        this.createTime = new Date(ruleset.createTime).toUTCString();
	        this.source = ruleset.source.files || [];
	    }
	}
	securityRules$1.Ruleset = Ruleset;
	/**
	 * The Firebase `SecurityRules` service interface.
	 */
	class SecurityRules {
	    /**
	     * @param app - The app for this SecurityRules service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.app = app;
	        this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);
	    }
	    /**
	     * Gets the {@link Ruleset} identified by the given
	     * name. The input name should be the short name string without the project ID
	     * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,
	     * pass the short name "my-ruleset". Rejects with a `not-found` error if the
	     * specified `Ruleset` cannot be found.
	     *
	     * @param name - Name of the `Ruleset` to retrieve.
	     * @returns A promise that fulfills with the specified `Ruleset`.
	     */
	    getRuleset(name) {
	        return this.client.getRuleset(name)
	            .then((rulesetResponse) => {
	            return new Ruleset(rulesetResponse);
	        });
	    }
	    /**
	     * Gets the {@link Ruleset} currently applied to
	     * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied
	     * on Firestore.
	     *
	     * @returns A promise that fulfills with the Firestore ruleset.
	     */
	    getFirestoreRuleset() {
	        return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);
	    }
	    /**
	     * Creates a new {@link Ruleset} from the given
	     * source, and applies it to Cloud Firestore.
	     *
	     * @param source - Rules source to apply.
	     * @returns A promise that fulfills when the ruleset is created and released.
	     */
	    releaseFirestoreRulesetFromSource(source) {
	        return Promise.resolve()
	            .then(() => {
	            const rulesFile = this.createRulesFileFromSource('firestore.rules', source);
	            return this.createRuleset(rulesFile);
	        })
	            .then((ruleset) => {
	            return this.releaseFirestoreRuleset(ruleset)
	                .then(() => {
	                return ruleset;
	            });
	        });
	    }
	    /**
	     * Applies the specified {@link Ruleset} ruleset
	     * to Cloud Firestore.
	     *
	     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object
	     *   containing the name.
	     * @returns A promise that fulfills when the ruleset is released.
	     */
	    releaseFirestoreRuleset(ruleset) {
	        return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);
	    }
	    /**
	     * Gets the {@link Ruleset} currently applied to a
	     * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied
	     * on the bucket.
	     *
	     * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not
	     *   specified, retrieves the ruleset applied on the default bucket configured via
	     *   `AppOptions`.
	     * @returns A promise that fulfills with the Cloud Storage ruleset.
	     */
	    getStorageRuleset(bucket) {
	        return Promise.resolve()
	            .then(() => {
	            return this.getBucketName(bucket);
	        })
	            .then((bucketName) => {
	            return this.getRulesetForRelease(`${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);
	        });
	    }
	    /**
	     * Creates a new {@link Ruleset} from the given
	     * source, and applies it to a Cloud Storage bucket.
	     *
	     * @param source - Rules source to apply.
	     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If
	     *   not specified, applies the ruleset on the default bucket configured via
	     *   {@link firebase-admin.app#AppOptions}.
	     * @returns A promise that fulfills when the ruleset is created and released.
	     */
	    releaseStorageRulesetFromSource(source, bucket) {
	        return Promise.resolve()
	            .then(() => {
	            // Bucket name is not required until the last step. But since there's a createRuleset step
	            // before then, make sure to run this check and fail early if the bucket name is invalid.
	            this.getBucketName(bucket);
	            const rulesFile = this.createRulesFileFromSource('storage.rules', source);
	            return this.createRuleset(rulesFile);
	        })
	            .then((ruleset) => {
	            return this.releaseStorageRuleset(ruleset, bucket)
	                .then(() => {
	                return ruleset;
	            });
	        });
	    }
	    /**
	     * Applies the specified {@link Ruleset} ruleset
	     * to a Cloud Storage bucket.
	     *
	     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object
	     *   containing the name.
	     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If
	     *   not specified, applies the ruleset on the default bucket configured via
	     *   {@link firebase-admin.app#AppOptions}.
	     * @returns A promise that fulfills when the ruleset is released.
	     */
	    releaseStorageRuleset(ruleset, bucket) {
	        return Promise.resolve()
	            .then(() => {
	            return this.getBucketName(bucket);
	        })
	            .then((bucketName) => {
	            return this.releaseRuleset(ruleset, `${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);
	        });
	    }
	    /**
	     * Creates a {@link RulesFile} with the given name
	     * and source. Throws an error if any of the arguments are invalid. This is a local
	     * operation, and does not involve any network API calls.
	     *
	     * @example
	     * ```javascript
	     * const source = '// Some rules source';
	     * const rulesFile = admin.securityRules().createRulesFileFromSource(
	     *   'firestore.rules', source);
	     * ```
	     *
	     * @param name - Name to assign to the rules file. This is usually a short file name that
	     *   helps identify the file in a ruleset.
	     * @param source - Contents of the rules file.
	     * @returns A new rules file instance.
	     */
	    createRulesFileFromSource(name, source) {
	        if (!validator.isNonEmptyString(name)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');
	        }
	        let content;
	        if (validator.isNonEmptyString(source)) {
	            content = source;
	        }
	        else if (validator.isBuffer(source)) {
	            content = source.toString('utf-8');
	        }
	        else {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');
	        }
	        return {
	            name,
	            content,
	        };
	    }
	    /**
	     * Creates a new {@link Ruleset} from the given {@link RulesFile}.
	     *
	     * @param file - Rules file to include in the new `Ruleset`.
	     * @returns A promise that fulfills with the newly created `Ruleset`.
	     */
	    createRuleset(file) {
	        const ruleset = {
	            source: {
	                files: [file],
	            },
	        };
	        return this.client.createRuleset(ruleset)
	            .then((rulesetResponse) => {
	            return new Ruleset(rulesetResponse);
	        });
	    }
	    /**
	     * Deletes the {@link Ruleset} identified by the given
	     * name. The input name should be the short name string without the project ID
	     * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,
	     * pass the  short name "my-ruleset". Rejects with a `not-found` error if the
	     * specified `Ruleset` cannot be found.
	     *
	     * @param name - Name of the `Ruleset` to delete.
	     * @returns A promise that fulfills when the `Ruleset` is deleted.
	     */
	    deleteRuleset(name) {
	        return this.client.deleteRuleset(name);
	    }
	    /**
	     * Retrieves a page of ruleset metadata.
	     *
	     * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed
	     *   limit.
	     * @param nextPageToken - The next page token. If not specified, returns rulesets
	     *   starting without any offset.
	     * @returns A promise that fulfills with a page of rulesets.
	     */
	    listRulesetMetadata(pageSize = 100, nextPageToken) {
	        return this.client.listRulesets(pageSize, nextPageToken)
	            .then((response) => {
	            return new RulesetMetadataList(response);
	        });
	    }
	    getRulesetForRelease(releaseName) {
	        return this.client.getRelease(releaseName)
	            .then((release) => {
	            const rulesetName = release.rulesetName;
	            if (!validator.isNonEmptyString(rulesetName)) {
	                throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for ${releaseName}.`);
	            }
	            return this.getRuleset(stripProjectIdPrefix(rulesetName));
	        });
	    }
	    releaseRuleset(ruleset, releaseName) {
	        if (!validator.isNonEmptyString(ruleset) &&
	            (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {
	            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');
	            return Promise.reject(err);
	        }
	        const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;
	        return this.client.updateOrCreateRelease(releaseName, rulesetName)
	            .then(() => {
	            return;
	        });
	    }
	    getBucketName(bucket) {
	        const bucketName = (typeof bucket !== 'undefined') ? bucket : this.app.options.storageBucket;
	        if (!validator.isNonEmptyString(bucketName)) {
	            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' +
	                'storageBucket option when initializing the app, or specify the bucket name ' +
	                'explicitly when calling the rules API.');
	        }
	        return bucketName;
	    }
	}
	securityRules$1.SecurityRules = SecurityRules;
	SecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';
	SecurityRules.FIREBASE_STORAGE = 'firebase.storage';
	function stripProjectIdPrefix(name) {
	    return name.split('/').pop();
	}
	return securityRules$1;
}

var remoteConfig$1 = {};

var remoteConfigApiClientInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredRemoteConfigApiClientInternal;

function requireRemoteConfigApiClientInternal () {
	if (hasRequiredRemoteConfigApiClientInternal) return remoteConfigApiClientInternal;
	hasRequiredRemoteConfigApiClientInternal = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(remoteConfigApiClientInternal, "__esModule", { value: true });
	remoteConfigApiClientInternal.FirebaseRemoteConfigError = remoteConfigApiClientInternal.RemoteConfigApiClient = void 0;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const error_1 = error;
	const utils = utils$1;
	const validator = validator$2;
	const deep_copy_1 = /*@__PURE__*/ requireDeepCopy();
	// Remote Config backend constants
	/**
	  * Allows the `FIREBASE_REMOTE_CONFIG_URL_BASE` environment
	  * variable to override the default API endpoint URL.
	  */
	const FIREBASE_REMOTE_CONFIG_URL_BASE = process.env.FIREBASE_REMOTE_CONFIG_URL_BASE || 'https://firebaseremoteconfig.googleapis.com';
	const FIREBASE_REMOTE_CONFIG_HEADERS = {
	    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,
	    // There is a known issue in which the ETag is not properly returned in cases where the request
	    // does not specify a compression type. Currently, it is required to include the header
	    // `Accept-Encoding: gzip` or equivalent in all requests.
	    // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates
	    'Accept-Encoding': 'gzip',
	};
	/**
	 * Class that facilitates sending requests to the Firebase Remote Config backend API.
	 *
	 * @internal
	 */
	class RemoteConfigApiClient {
	    constructor(app) {
	        this.app = app;
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');
	        }
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    getTemplate() {
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/remoteConfig`,
	                headers: FIREBASE_REMOTE_CONFIG_HEADERS
	            };
	            return this.httpClient.send(request);
	        })
	            .then((resp) => {
	            return this.toRemoteConfigTemplate(resp);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    getTemplateAtVersion(versionNumber) {
	        const data = { versionNumber: this.validateVersionNumber(versionNumber) };
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/remoteConfig`,
	                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
	                data
	            };
	            return this.httpClient.send(request);
	        })
	            .then((resp) => {
	            return this.toRemoteConfigTemplate(resp);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    validateTemplate(template) {
	        template = this.validateInputRemoteConfigTemplate(template);
	        return this.sendPutRequest(template, template.etag, true)
	            .then((resp) => {
	            // validating a template returns an etag with the suffix -0 means that your update
	            // was successfully validated. We set the etag back to the original etag of the template
	            // to allow future operations.
	            this.validateEtag(resp.headers['etag']);
	            return this.toRemoteConfigTemplate(resp, template.etag);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    publishTemplate(template, options) {
	        template = this.validateInputRemoteConfigTemplate(template);
	        let ifMatch = template.etag;
	        if (options && options.force === true) {
	            // setting `If-Match: *` forces the Remote Config template to be updated
	            // and circumvent the ETag, and the protection from that it provides.
	            ifMatch = '*';
	        }
	        return this.sendPutRequest(template, ifMatch)
	            .then((resp) => {
	            return this.toRemoteConfigTemplate(resp);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    rollback(versionNumber) {
	        const data = { versionNumber: this.validateVersionNumber(versionNumber) };
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'POST',
	                url: `${url}/remoteConfig:rollback`,
	                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
	                data
	            };
	            return this.httpClient.send(request);
	        })
	            .then((resp) => {
	            return this.toRemoteConfigTemplate(resp);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    listVersions(options) {
	        if (typeof options !== 'undefined') {
	            options = this.validateListVersionsOptions(options);
	        }
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/remoteConfig:listVersions`,
	                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
	                data: options
	            };
	            return this.httpClient.send(request);
	        })
	            .then((resp) => {
	            return resp.data;
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    getServerTemplate() {
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'GET',
	                url: `${url}/namespaces/firebase-server/serverRemoteConfig`,
	                headers: FIREBASE_REMOTE_CONFIG_HEADERS
	            };
	            return this.httpClient.send(request);
	        })
	            .then((resp) => {
	            return this.toRemoteConfigServerTemplate(resp);
	        })
	            .catch((err) => {
	            throw this.toFirebaseError(err);
	        });
	    }
	    sendPutRequest(template, etag, validateOnly) {
	        let path = 'remoteConfig';
	        if (validateOnly) {
	            path += '?validate_only=true';
	        }
	        return this.getUrl()
	            .then((url) => {
	            const request = {
	                method: 'PUT',
	                url: `${url}/${path}`,
	                headers: { ...FIREBASE_REMOTE_CONFIG_HEADERS, 'If-Match': etag },
	                data: {
	                    conditions: template.conditions,
	                    parameters: template.parameters,
	                    parameterGroups: template.parameterGroups,
	                    version: template.version,
	                }
	            };
	            return this.httpClient.send(request);
	        });
	    }
	    getUrl() {
	        return this.getProjectIdPrefix()
	            .then((projectIdPrefix) => {
	            return `${FIREBASE_REMOTE_CONFIG_URL_BASE}/v1/${projectIdPrefix}`;
	        });
	    }
	    getProjectIdPrefix() {
	        if (this.projectIdPrefix) {
	            return Promise.resolve(this.projectIdPrefix);
	        }
	        return utils.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
	                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
	                    + 'environment variable.');
	            }
	            this.projectIdPrefix = `projects/${projectId}`;
	            return this.projectIdPrefix;
	        });
	    }
	    toFirebaseError(err) {
	        if (err instanceof error_1.PrefixedFirebaseError) {
	            return err;
	        }
	        const response = err.response;
	        if (!response.isJson()) {
	            return new FirebaseRemoteConfigError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);
	        }
	        const error = response.data.error || {};
	        let code = 'unknown-error';
	        if (error.status && error.status in ERROR_CODE_MAPPING) {
	            code = ERROR_CODE_MAPPING[error.status];
	        }
	        const message = error.message || `Unknown server error: ${response.text}`;
	        return new FirebaseRemoteConfigError(code, message);
	    }
	    /**
	     * Creates a RemoteConfigTemplate from the API response.
	     * If provided, customEtag is used instead of the etag returned in the API response.
	     *
	     * @param {HttpResponse} resp API response object.
	     * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).
	     */
	    toRemoteConfigTemplate(resp, customEtag) {
	        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;
	        this.validateEtag(etag);
	        return {
	            conditions: resp.data.conditions,
	            parameters: resp.data.parameters,
	            parameterGroups: resp.data.parameterGroups,
	            etag,
	            version: resp.data.version,
	        };
	    }
	    /**
	     * Creates a RemoteConfigServerTemplate from the API response.
	     * If provided, customEtag is used instead of the etag returned in the API response.
	     *
	     * @param {HttpResponse} resp API response object.
	     * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).
	     */
	    toRemoteConfigServerTemplate(resp, customEtag) {
	        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;
	        this.validateEtag(etag);
	        return {
	            conditions: resp.data.conditions,
	            parameters: resp.data.parameters,
	            etag,
	            version: resp.data.version,
	        };
	    }
	    /**
	     * Checks if the given RemoteConfigTemplate object is valid.
	     * The object must have valid parameters, parameter groups, conditions, and an etag.
	     * Removes output only properties from version metadata.
	     *
	     * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.
	     *
	     * @returns {RemoteConfigTemplate} The validated RemoteConfigTemplate object.
	     */
	    validateInputRemoteConfigTemplate(template) {
	        const templateCopy = (0, deep_copy_1.deepCopy)(template);
	        if (!validator.isNonNullObject(templateCopy)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(templateCopy)}`);
	        }
	        if (!validator.isNonEmptyString(templateCopy.etag)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');
	        }
	        if (!validator.isNonNullObject(templateCopy.parameters)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
	        }
	        if (!validator.isNonNullObject(templateCopy.parameterGroups)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');
	        }
	        if (!validator.isArray(templateCopy.conditions)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
	        }
	        if (typeof templateCopy.version !== 'undefined') {
	            // exclude output only properties and keep the only input property: description
	            templateCopy.version = { description: templateCopy.version.description };
	        }
	        return templateCopy;
	    }
	    /**
	     * Checks if a given version number is valid.
	     * A version number must be an integer or a string in int64 format.
	     * If valid, returns the string representation of the provided version number.
	     *
	     * @param {string|number} versionNumber A version number to be validated.
	     *
	     * @returns {string} The validated version number as a string.
	     */
	    validateVersionNumber(versionNumber, propertyName = 'versionNumber') {
	        if (!validator.isNonEmptyString(versionNumber) &&
	            !validator.isNumber(versionNumber)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be a non-empty string in int64 format or a number`);
	        }
	        if (!Number.isInteger(Number(versionNumber))) {
	            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be an integer or a string in int64 format`);
	        }
	        return versionNumber.toString();
	    }
	    validateEtag(etag) {
	        if (!validator.isNonEmptyString(etag)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');
	        }
	    }
	    /**
	     * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the
	     * options object and convert `startTime` and `endTime` to RFC3339 UTC "Zulu" format, if present.
	     *
	     * @param {ListVersionsOptions} options An options object to be validated.
	     *
	     * @returns {ListVersionsOptions} A copy of the provided options object with timestamps converted
	     * to UTC Zulu format.
	     */
	    validateListVersionsOptions(options) {
	        const optionsCopy = (0, deep_copy_1.deepCopy)(options);
	        if (!validator.isNonNullObject(optionsCopy)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');
	        }
	        if (typeof optionsCopy.pageSize !== 'undefined') {
	            if (!validator.isNumber(optionsCopy.pageSize)) {
	                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');
	            }
	            if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {
	                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');
	            }
	        }
	        if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {
	            throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');
	        }
	        if (typeof optionsCopy.endVersionNumber !== 'undefined') {
	            optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');
	        }
	        if (typeof optionsCopy.startTime !== 'undefined') {
	            if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {
	                throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');
	            }
	            // Convert startTime to RFC3339 UTC "Zulu" format.
	            if (optionsCopy.startTime instanceof Date) {
	                optionsCopy.startTime = optionsCopy.startTime.toISOString();
	            }
	            else {
	                optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();
	            }
	        }
	        if (typeof optionsCopy.endTime !== 'undefined') {
	            if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {
	                throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');
	            }
	            // Convert endTime to RFC3339 UTC "Zulu" format.
	            if (optionsCopy.endTime instanceof Date) {
	                optionsCopy.endTime = optionsCopy.endTime.toISOString();
	            }
	            else {
	                optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();
	            }
	        }
	        // Remove undefined fields from optionsCopy
	        Object.keys(optionsCopy).forEach(key => (typeof optionsCopy[key] === 'undefined') && delete optionsCopy[key]);
	        return optionsCopy;
	    }
	}
	remoteConfigApiClientInternal.RemoteConfigApiClient = RemoteConfigApiClient;
	const ERROR_CODE_MAPPING = {
	    ABORTED: 'aborted',
	    ALREADY_EXISTS: 'already-exists',
	    INVALID_ARGUMENT: 'invalid-argument',
	    INTERNAL: 'internal-error',
	    FAILED_PRECONDITION: 'failed-precondition',
	    NOT_FOUND: 'not-found',
	    OUT_OF_RANGE: 'out-of-range',
	    PERMISSION_DENIED: 'permission-denied',
	    RESOURCE_EXHAUSTED: 'resource-exhausted',
	    UNAUTHENTICATED: 'unauthenticated',
	    UNKNOWN: 'unknown-error',
	};
	/**
	 * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.
	 *
	 * @param {RemoteConfigErrorCode} code The error code.
	 * @param {string} message The error message.
	 * @constructor
	 */
	class FirebaseRemoteConfigError extends error_1.PrefixedFirebaseError {
	    constructor(code, message) {
	        super('remote-config', code, message);
	    }
	}
	remoteConfigApiClientInternal.FirebaseRemoteConfigError = FirebaseRemoteConfigError;
	return remoteConfigApiClientInternal;
}

var conditionEvaluatorInternal = {};

var remoteConfigApi = {};

/*! firebase-admin v12.7.0 */

var hasRequiredRemoteConfigApi;

function requireRemoteConfigApi () {
	if (hasRequiredRemoteConfigApi) return remoteConfigApi;
	hasRequiredRemoteConfigApi = 1;
	/*!
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(remoteConfigApi, "__esModule", { value: true });
	remoteConfigApi.CustomSignalOperator = remoteConfigApi.PercentConditionOperator = void 0;
	/**
	 * Defines supported operators for percent conditions.
	 */
	var PercentConditionOperator;
	(function (PercentConditionOperator) {
	    /**
	     * A catchall error case.
	     */
	    PercentConditionOperator["UNKNOWN"] = "UNKNOWN";
	    /**
	     * Target percentiles less than or equal to the target percent.
	     * A condition using this operator must specify microPercent.
	     */
	    PercentConditionOperator["LESS_OR_EQUAL"] = "LESS_OR_EQUAL";
	    /**
	     * Target percentiles greater than the target percent.
	     * A condition using this operator must specify microPercent.
	     */
	    PercentConditionOperator["GREATER_THAN"] = "GREATER_THAN";
	    /**
	     * Target percentiles within an interval defined by a lower bound and an
	     * upper bound. The lower bound is an exclusive (open) bound and the
	     * micro_percent_range_upper_bound is an inclusive (closed) bound.
	     * A condition using this operator must specify microPercentRange.
	     */
	    PercentConditionOperator["BETWEEN"] = "BETWEEN";
	})(PercentConditionOperator || (remoteConfigApi.PercentConditionOperator = PercentConditionOperator = {}));
	/**
	 * Defines supported operators for custom signal conditions.
	 */
	var CustomSignalOperator;
	(function (CustomSignalOperator) {
	    /**
	     * A catchall error case.
	     */
	    CustomSignalOperator["UNKNOWN"] = "UNKNOWN";
	    /**
	     * Matches a numeric value less than the target value.
	     */
	    CustomSignalOperator["NUMERIC_LESS_THAN"] = "NUMERIC_LESS_THAN";
	    /**
	     * Matches a numeric value less than or equal to the target value.
	     */
	    CustomSignalOperator["NUMERIC_LESS_EQUAL"] = "NUMERIC_LESS_EQUAL";
	    /**
	     * Matches a numeric value equal to the target value.
	     */
	    CustomSignalOperator["NUMERIC_EQUAL"] = "NUMERIC_EQUAL";
	    /**
	     * Matches a numeric value not equal to the target value.
	     */
	    CustomSignalOperator["NUMERIC_NOT_EQUAL"] = "NUMERIC_NOT_EQUAL";
	    /**
	     * Matches a numeric value greater than the target value.
	     */
	    CustomSignalOperator["NUMERIC_GREATER_THAN"] = "NUMERIC_GREATER_THAN";
	    /**
	     * Matches a numeric value greater than or equal to the target value.
	     */
	    CustomSignalOperator["NUMERIC_GREATER_EQUAL"] = "NUMERIC_GREATER_EQUAL";
	    /**
	     * Matches if at least one of the target values is a substring of the actual custom
	     * signal value (e.g. "abc" contains the string "a", "bc").
	     */
	    CustomSignalOperator["STRING_CONTAINS"] = "STRING_CONTAINS";
	    /**
	     * Matches if none of the target values is a substring of the actual custom signal value.
	     */
	    CustomSignalOperator["STRING_DOES_NOT_CONTAIN"] = "STRING_DOES_NOT_CONTAIN";
	    /**
	     * Matches if the actual value exactly matches at least one of the target values.
	     */
	    CustomSignalOperator["STRING_EXACTLY_MATCHES"] = "STRING_EXACTLY_MATCHES";
	    /**
	     * The target regular expression matches at least one of the actual values.
	     * The regex conforms to RE2 format. See https://github.com/google/re2/wiki/Syntax
	     */
	    CustomSignalOperator["STRING_CONTAINS_REGEX"] = "STRING_CONTAINS_REGEX";
	    /**
	     * Matches if the actual version value is less than the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_LESS_THAN"] = "SEMANTIC_VERSION_LESS_THAN";
	    /**
	     * Matches if the actual version value is less than or equal to the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_LESS_EQUAL"] = "SEMANTIC_VERSION_LESS_EQUAL";
	    /**
	     * Matches if the actual version value is equal to the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_EQUAL"] = "SEMANTIC_VERSION_EQUAL";
	    /**
	     * Matches if the actual version value is not equal to the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_NOT_EQUAL"] = "SEMANTIC_VERSION_NOT_EQUAL";
	    /**
	     * Matches if the actual version value is greater than the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_GREATER_THAN"] = "SEMANTIC_VERSION_GREATER_THAN";
	    /**
	     * Matches if the actual version value is greater than or equal to the target value.
	     */
	    CustomSignalOperator["SEMANTIC_VERSION_GREATER_EQUAL"] = "SEMANTIC_VERSION_GREATER_EQUAL";
	})(CustomSignalOperator || (remoteConfigApi.CustomSignalOperator = CustomSignalOperator = {}));
	return remoteConfigApi;
}

const require$$1$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(farmhashModern);

/*! firebase-admin v12.7.0 */

var hasRequiredConditionEvaluatorInternal;

function requireConditionEvaluatorInternal () {
	if (hasRequiredConditionEvaluatorInternal) return conditionEvaluatorInternal;
	hasRequiredConditionEvaluatorInternal = 1;
	Object.defineProperty(conditionEvaluatorInternal, "__esModule", { value: true });
	conditionEvaluatorInternal.ConditionEvaluator = void 0;
	const remote_config_api_1 = /*@__PURE__*/ requireRemoteConfigApi();
	const farmhash = require$$1$1;
	/**
	 * Encapsulates condition evaluation logic to simplify organization and
	 * facilitate testing.
	 *
	 * @internal
	 */
	class ConditionEvaluator {
	    evaluateConditions(namedConditions, context) {
	        // The order of the conditions is significant.
	        // A JS Map preserves the order of insertion ("Iteration happens in insertion order"
	        // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#description).
	        const evaluatedConditions = new Map();
	        for (const namedCondition of namedConditions) {
	            evaluatedConditions.set(namedCondition.name, this.evaluateCondition(namedCondition.condition, context));
	        }
	        return evaluatedConditions;
	    }
	    evaluateCondition(condition, context, nestingLevel = 0) {
	        if (nestingLevel >= ConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH) {
	            // TODO: add logging once we have a wrapped logger.
	            return false;
	        }
	        if (condition.orCondition) {
	            return this.evaluateOrCondition(condition.orCondition, context, nestingLevel + 1);
	        }
	        if (condition.andCondition) {
	            return this.evaluateAndCondition(condition.andCondition, context, nestingLevel + 1);
	        }
	        if (condition.true) {
	            return true;
	        }
	        if (condition.false) {
	            return false;
	        }
	        if (condition.percent) {
	            return this.evaluatePercentCondition(condition.percent, context);
	        }
	        if (condition.customSignal) {
	            return this.evaluateCustomSignalCondition(condition.customSignal, context);
	        }
	        // TODO: add logging once we have a wrapped logger.
	        return false;
	    }
	    evaluateOrCondition(orCondition, context, nestingLevel) {
	        const subConditions = orCondition.conditions || [];
	        for (const subCondition of subConditions) {
	            // Recursive call.
	            const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);
	            // Short-circuit the evaluation result for true.
	            if (result) {
	                return result;
	            }
	        }
	        return false;
	    }
	    evaluateAndCondition(andCondition, context, nestingLevel) {
	        const subConditions = andCondition.conditions || [];
	        for (const subCondition of subConditions) {
	            // Recursive call.
	            const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);
	            // Short-circuit the evaluation result for false.
	            if (!result) {
	                return result;
	            }
	        }
	        return true;
	    }
	    evaluatePercentCondition(percentCondition, context) {
	        if (!context.randomizationId) {
	            // TODO: add logging once we have a wrapped logger.
	            return false;
	        }
	        // This is the entry point for processing percent condition data from the response.
	        // We're not using a proto library, so we can't assume undefined fields have
	        // default values.
	        const { seed, percentOperator, microPercent, microPercentRange } = percentCondition;
	        if (!percentOperator) {
	            // TODO: add logging once we have a wrapped logger.
	            return false;
	        }
	        const normalizedMicroPercent = microPercent || 0;
	        const normalizedMicroPercentUpperBound = microPercentRange?.microPercentUpperBound || 0;
	        const normalizedMicroPercentLowerBound = microPercentRange?.microPercentLowerBound || 0;
	        const seedPrefix = seed && seed.length > 0 ? `${seed}.` : '';
	        const stringToHash = `${seedPrefix}${context.randomizationId}`;
	        const hash64 = ConditionEvaluator.hashSeededRandomizationId(stringToHash);
	        const instanceMicroPercentile = hash64 % BigInt(100 * 1000000);
	        switch (percentOperator) {
	            case remote_config_api_1.PercentConditionOperator.LESS_OR_EQUAL:
	                return instanceMicroPercentile <= normalizedMicroPercent;
	            case remote_config_api_1.PercentConditionOperator.GREATER_THAN:
	                return instanceMicroPercentile > normalizedMicroPercent;
	            case remote_config_api_1.PercentConditionOperator.BETWEEN:
	                return instanceMicroPercentile > normalizedMicroPercentLowerBound
	                    && instanceMicroPercentile <= normalizedMicroPercentUpperBound;
	            case remote_config_api_1.PercentConditionOperator.UNKNOWN:
	        }
	        // TODO: add logging once we have a wrapped logger.
	        return false;
	    }
	    static hashSeededRandomizationId(seededRandomizationId) {
	        // For consistency with the Remote Config fetch endpoint's percent condition behavior
	        // we use Farmhash's fingerprint64 algorithm and interpret the resulting unsigned value
	        // as a signed value.
	        let hash64 = BigInt.asIntN(64, farmhash.fingerprint64(seededRandomizationId));
	        // Manually negate the hash if its value is less than 0, since Math.abs doesn't
	        // support BigInt.
	        if (hash64 < 0) {
	            hash64 = -hash64;
	        }
	        return hash64;
	    }
	    evaluateCustomSignalCondition(customSignalCondition, context) {
	        const { customSignalOperator, customSignalKey, targetCustomSignalValues, } = customSignalCondition;
	        if (!customSignalOperator || !customSignalKey || !targetCustomSignalValues) {
	            // TODO: add logging once we have a wrapped logger.
	            return false;
	        }
	        if (!targetCustomSignalValues.length) {
	            return false;
	        }
	        // Extract the value of the signal from the evaluation context.
	        const actualCustomSignalValue = context[customSignalKey];
	        if (actualCustomSignalValue == undefined) {
	            return false;
	        }
	        switch (customSignalOperator) {
	            case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS:
	                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));
	            case remote_config_api_1.CustomSignalOperator.STRING_DOES_NOT_CONTAIN:
	                return !compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));
	            case remote_config_api_1.CustomSignalOperator.STRING_EXACTLY_MATCHES:
	                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.trim() === target.trim());
	            case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS_REGEX:
	                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => new RegExp(target).test(actual));
	            // For numeric operators only one target value is allowed.
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_THAN:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r < 0);
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_EQUAL:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r <= 0);
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_EQUAL:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r === 0);
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_NOT_EQUAL:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r !== 0);
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_THAN:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r > 0);
	            case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_EQUAL:
	                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r >= 0);
	            // For semantic operators only one target value is allowed.
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_THAN:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r < 0);
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_EQUAL:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r <= 0);
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_EQUAL:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r === 0);
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_NOT_EQUAL:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r !== 0);
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_THAN:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r > 0);
	            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_EQUAL:
	                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r >= 0);
	        }
	        // TODO: add logging once we have a wrapped logger.
	        return false;
	    }
	}
	conditionEvaluatorInternal.ConditionEvaluator = ConditionEvaluator;
	ConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH = 10;
	// Compares the actual string value of a signal against a list of target
	// values. If any of the target values are a match, returns true.
	function compareStrings(targetValues, actualValue, predicateFn) {
	    const actual = String(actualValue);
	    return targetValues.some((target) => predicateFn(target, actual));
	}
	// Compares two numbers against each other.
	// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.
	function compareNumbers(actualValue, targetValue, predicateFn) {
	    const target = Number(targetValue);
	    const actual = Number(actualValue);
	    if (isNaN(target) || isNaN(actual)) {
	        return false;
	    }
	    return predicateFn(actual < target ? -1 : actual > target ? 1 : 0);
	}
	// Max number of segments a numeric version can have. This is enforced by the server as well.
	const MAX_LENGTH = 5;
	// Compares semantic version strings against each other.
	// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.
	function compareSemanticVersions(actualValue, targetValue, predicateFn) {
	    const version1 = String(actualValue).split('.').map(Number);
	    const version2 = targetValue.split('.').map(Number);
	    for (let i = 0; i < MAX_LENGTH; i++) {
	        // Check to see if segments are present. Note that these may be present and be NaN.
	        const version1HasSegment = version1[i] !== undefined;
	        const version2HasSegment = version2[i] !== undefined;
	        // If both are undefined, we've consumed everything and they're equal.
	        if (!version1HasSegment && !version2HasSegment)
	            return predicateFn(0);
	        // Insert zeros if undefined for easier comparison.
	        if (!version1HasSegment)
	            version1[i] = 0;
	        if (!version2HasSegment)
	            version2[i] = 0;
	        // At this point, if either segment is NaN, we return false directly.
	        if (isNaN(version1[i]) || isNaN(version2[i]))
	            return false;
	        // Check if we have a difference in segments. Otherwise continue to next segment.
	        if (version1[i] < version2[i])
	            return predicateFn(-1);
	        if (version1[i] > version2[i])
	            return predicateFn(1);
	    }
	    return false;
	}
	return conditionEvaluatorInternal;
}

var valueImpl = {};

/*! firebase-admin v12.7.0 */

var hasRequiredValueImpl;

function requireValueImpl () {
	if (hasRequiredValueImpl) return valueImpl;
	hasRequiredValueImpl = 1;
	Object.defineProperty(valueImpl, "__esModule", { value: true });
	valueImpl.ValueImpl = void 0;
	/**
	 * Implements type-safe getters for parameter values.
	 *
	 * Visible for testing.
	 *
	 * @internal
	 */
	class ValueImpl {
	    constructor(source, value = ValueImpl.DEFAULT_VALUE_FOR_STRING) {
	        this.source = source;
	        this.value = value;
	    }
	    asString() {
	        return this.value;
	    }
	    asBoolean() {
	        if (this.source === 'static') {
	            return ValueImpl.DEFAULT_VALUE_FOR_BOOLEAN;
	        }
	        return ValueImpl.BOOLEAN_TRUTHY_VALUES.indexOf(this.value.toLowerCase()) >= 0;
	    }
	    asNumber() {
	        if (this.source === 'static') {
	            return ValueImpl.DEFAULT_VALUE_FOR_NUMBER;
	        }
	        const num = Number(this.value);
	        if (isNaN(num)) {
	            return ValueImpl.DEFAULT_VALUE_FOR_NUMBER;
	        }
	        return num;
	    }
	    getSource() {
	        return this.source;
	    }
	}
	valueImpl.ValueImpl = ValueImpl;
	ValueImpl.DEFAULT_VALUE_FOR_BOOLEAN = false;
	ValueImpl.DEFAULT_VALUE_FOR_STRING = '';
	ValueImpl.DEFAULT_VALUE_FOR_NUMBER = 0;
	ValueImpl.BOOLEAN_TRUTHY_VALUES = ['1', 'true', 't', 'yes', 'y', 'on'];
	return valueImpl;
}

/*! firebase-admin v12.7.0 */

var hasRequiredRemoteConfig$1;

function requireRemoteConfig$1 () {
	if (hasRequiredRemoteConfig$1) return remoteConfig$1;
	hasRequiredRemoteConfig$1 = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(remoteConfig$1, "__esModule", { value: true });
	remoteConfig$1.RemoteConfig = void 0;
	const validator = validator$2;
	const remote_config_api_client_internal_1 = /*@__PURE__*/ requireRemoteConfigApiClientInternal();
	const condition_evaluator_internal_1 = /*@__PURE__*/ requireConditionEvaluatorInternal();
	const value_impl_1 = /*@__PURE__*/ requireValueImpl();
	/**
	 * The Firebase `RemoteConfig` service interface.
	 */
	class RemoteConfig {
	    /**
	     * @param app - The app for this RemoteConfig service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.app = app;
	        this.client = new remote_config_api_client_internal_1.RemoteConfigApiClient(app);
	    }
	    /**
	     * Gets the current active version of the {@link RemoteConfigTemplate} of the project.
	     *
	     * @returns A promise that fulfills with a `RemoteConfigTemplate`.
	     */
	    getTemplate() {
	        return this.client.getTemplate()
	            .then((templateResponse) => {
	            return new RemoteConfigTemplateImpl(templateResponse);
	        });
	    }
	    /**
	     * Gets the requested version of the {@link RemoteConfigTemplate} of the project.
	     *
	     * @param versionNumber - Version number of the Remote Config template to look up.
	     *
	     * @returns A promise that fulfills with a `RemoteConfigTemplate`.
	     */
	    getTemplateAtVersion(versionNumber) {
	        return this.client.getTemplateAtVersion(versionNumber)
	            .then((templateResponse) => {
	            return new RemoteConfigTemplateImpl(templateResponse);
	        });
	    }
	    /**
	     * Validates a {@link RemoteConfigTemplate}.
	     *
	     * @param template - The Remote Config template to be validated.
	     * @returns A promise that fulfills with the validated `RemoteConfigTemplate`.
	     */
	    validateTemplate(template) {
	        return this.client.validateTemplate(template)
	            .then((templateResponse) => {
	            return new RemoteConfigTemplateImpl(templateResponse);
	        });
	    }
	    /**
	     * Publishes a Remote Config template.
	     *
	     * @param template - The Remote Config template to be published.
	     * @param options - Optional options object when publishing a Remote Config template:
	     *    - `force`: Setting this to `true` forces the Remote Config template to
	     *      be updated and circumvent the ETag. This approach is not recommended
	     *      because it risks causing the loss of updates to your Remote Config
	     *      template if multiple clients are updating the Remote Config template.
	     *      See {@link https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates |
	     *      ETag usage and forced updates}.
	     *
	     * @returns A Promise that fulfills with the published `RemoteConfigTemplate`.
	     */
	    publishTemplate(template, options) {
	        return this.client.publishTemplate(template, options)
	            .then((templateResponse) => {
	            return new RemoteConfigTemplateImpl(templateResponse);
	        });
	    }
	    /**
	     * Rolls back a project's published Remote Config template to the specified version.
	     * A rollback is equivalent to getting a previously published Remote Config
	     * template and re-publishing it using a force update.
	     *
	     * @param versionNumber - The version number of the Remote Config template to roll back to.
	     *    The specified version number must be lower than the current version number, and not have
	     *    been deleted due to staleness. Only the last 300 versions are stored.
	     *    All versions that correspond to non-active Remote Config templates (that is, all except the
	     *    template that is being fetched by clients) are also deleted if they are more than 90 days old.
	     * @returns A promise that fulfills with the published `RemoteConfigTemplate`.
	     */
	    rollback(versionNumber) {
	        return this.client.rollback(versionNumber)
	            .then((templateResponse) => {
	            return new RemoteConfigTemplateImpl(templateResponse);
	        });
	    }
	    /**
	     * Gets a list of Remote Config template versions that have been published, sorted in reverse
	     * chronological order. Only the last 300 versions are stored.
	     * All versions that correspond to non-active Remote Config templates (i.e., all except the
	     * template that is being fetched by clients) are also deleted if they are older than 90 days.
	     *
	     * @param options - Optional options object for getting a list of versions.
	     * @returns A promise that fulfills with a `ListVersionsResult`.
	     */
	    listVersions(options) {
	        return this.client.listVersions(options)
	            .then((listVersionsResponse) => {
	            return {
	                versions: listVersionsResponse.versions?.map(version => new VersionImpl(version)) ?? [],
	                nextPageToken: listVersionsResponse.nextPageToken,
	            };
	        });
	    }
	    /**
	     * Creates and returns a new Remote Config template from a JSON string.
	     *
	     * @param json - The JSON string to populate a Remote Config template.
	     *
	     * @returns A new template instance.
	     */
	    createTemplateFromJSON(json) {
	        if (!validator.isNonEmptyString(json)) {
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'JSON string must be a valid non-empty string');
	        }
	        let template;
	        try {
	            template = JSON.parse(json);
	        }
	        catch (e) {
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Failed to parse the JSON string: ${json}. ` + e);
	        }
	        return new RemoteConfigTemplateImpl(template);
	    }
	    /**
	     * Instantiates {@link ServerTemplate} and then fetches and caches the latest
	     * template version of the project.
	     */
	    async getServerTemplate(options) {
	        const template = this.initServerTemplate(options);
	        await template.load();
	        return template;
	    }
	    /**
	     * Synchronously instantiates {@link ServerTemplate}.
	     */
	    initServerTemplate(options) {
	        const template = new ServerTemplateImpl(this.client, new condition_evaluator_internal_1.ConditionEvaluator(), options?.defaultConfig);
	        if (options?.template) {
	            template.set(options?.template);
	        }
	        return template;
	    }
	}
	remoteConfig$1.RemoteConfig = RemoteConfig;
	/**
	 * Remote Config template internal implementation.
	 */
	class RemoteConfigTemplateImpl {
	    constructor(config) {
	        if (!validator.isNonNullObject(config) ||
	            !validator.isNonEmptyString(config.etag)) {
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(config)}`);
	        }
	        this.etagInternal = config.etag;
	        if (typeof config.parameters !== 'undefined') {
	            if (!validator.isNonNullObject(config.parameters)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
	            }
	            this.parameters = config.parameters;
	        }
	        else {
	            this.parameters = {};
	        }
	        if (typeof config.parameterGroups !== 'undefined') {
	            if (!validator.isNonNullObject(config.parameterGroups)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');
	            }
	            this.parameterGroups = config.parameterGroups;
	        }
	        else {
	            this.parameterGroups = {};
	        }
	        if (typeof config.conditions !== 'undefined') {
	            if (!validator.isArray(config.conditions)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
	            }
	            this.conditions = config.conditions;
	        }
	        else {
	            this.conditions = [];
	        }
	        if (typeof config.version !== 'undefined') {
	            this.version = new VersionImpl(config.version);
	        }
	    }
	    /**
	     * Gets the ETag of the template.
	     *
	     * @returns The ETag of the Remote Config template.
	     */
	    get etag() {
	        return this.etagInternal;
	    }
	    /**
	     * Returns a JSON-serializable representation of this object.
	     *
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        return {
	            conditions: this.conditions,
	            parameters: this.parameters,
	            parameterGroups: this.parameterGroups,
	            etag: this.etag,
	            version: this.version,
	        };
	    }
	}
	/**
	 * Remote Config dataplane template data implementation.
	 */
	class ServerTemplateImpl {
	    constructor(apiClient, conditionEvaluator, defaultConfig = {}) {
	        this.apiClient = apiClient;
	        this.conditionEvaluator = conditionEvaluator;
	        this.defaultConfig = defaultConfig;
	        this.stringifiedDefaultConfig = {};
	        // RC stores all remote values as string, but it's more intuitive
	        // to declare default values with specific types, so this converts
	        // the external declaration to an internal string representation.
	        for (const key in defaultConfig) {
	            this.stringifiedDefaultConfig[key] = String(defaultConfig[key]);
	        }
	    }
	    /**
	     * Fetches and caches the current active version of the project's {@link ServerTemplate}.
	     */
	    load() {
	        return this.apiClient.getServerTemplate()
	            .then((template) => {
	            this.cache = new ServerTemplateDataImpl(template);
	        });
	    }
	    /**
	     * Parses a {@link ServerTemplateDataType} and caches it.
	     */
	    set(template) {
	        let parsed;
	        if (validator.isString(template)) {
	            try {
	                parsed = JSON.parse(template);
	            }
	            catch (e) {
	                // Transforms JSON parse errors to Firebase error.
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Failed to parse the JSON string: ${template}. ` + e);
	            }
	        }
	        else {
	            parsed = template;
	        }
	        // Throws template parse errors.
	        this.cache = new ServerTemplateDataImpl(parsed);
	    }
	    /**
	     * Evaluates the current template in cache to produce a {@link ServerConfig}.
	     */
	    evaluate(context = {}) {
	        if (!this.cache) {
	            // This is the only place we should throw during evaluation, since it's under the
	            // control of application logic. To preserve forward-compatibility, we should only
	            // return false in cases where the SDK is unsure how to evaluate the fetched template.
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('failed-precondition', 'No Remote Config Server template in cache. Call load() before calling evaluate().');
	        }
	        const evaluatedConditions = this.conditionEvaluator.evaluateConditions(this.cache.conditions, context);
	        const configValues = {};
	        // Initializes config Value objects with default values.
	        for (const key in this.stringifiedDefaultConfig) {
	            configValues[key] = new value_impl_1.ValueImpl('default', this.stringifiedDefaultConfig[key]);
	        }
	        // Overlays config Value objects derived by evaluating the template.
	        for (const [key, parameter] of Object.entries(this.cache.parameters)) {
	            const { conditionalValues, defaultValue } = parameter;
	            // Supports parameters with no conditional values.
	            const normalizedConditionalValues = conditionalValues || {};
	            let parameterValueWrapper = undefined;
	            // Iterates in order over condition list. If there is a value associated
	            // with a condition, this checks if the condition is true.
	            for (const [conditionName, conditionEvaluation] of evaluatedConditions) {
	                if (normalizedConditionalValues[conditionName] && conditionEvaluation) {
	                    parameterValueWrapper = normalizedConditionalValues[conditionName];
	                    break;
	                }
	            }
	            if (parameterValueWrapper && parameterValueWrapper.useInAppDefault) {
	                // TODO: add logging once we have a wrapped logger.
	                continue;
	            }
	            if (parameterValueWrapper) {
	                const parameterValue = parameterValueWrapper.value;
	                configValues[key] = new value_impl_1.ValueImpl('remote', parameterValue);
	                continue;
	            }
	            if (!defaultValue) {
	                // TODO: add logging once we have a wrapped logger.
	                continue;
	            }
	            if (defaultValue.useInAppDefault) {
	                // TODO: add logging once we have a wrapped logger.
	                continue;
	            }
	            const parameterDefaultValue = defaultValue.value;
	            configValues[key] = new value_impl_1.ValueImpl('remote', parameterDefaultValue);
	        }
	        return new ServerConfigImpl(configValues);
	    }
	    /**
	     * @returns JSON representation of the server template
	     */
	    toJSON() {
	        return this.cache;
	    }
	}
	class ServerConfigImpl {
	    constructor(configValues) {
	        this.configValues = configValues;
	    }
	    getBoolean(key) {
	        return this.getValue(key).asBoolean();
	    }
	    getNumber(key) {
	        return this.getValue(key).asNumber();
	    }
	    getString(key) {
	        return this.getValue(key).asString();
	    }
	    getValue(key) {
	        return this.configValues[key] || new value_impl_1.ValueImpl('static');
	    }
	}
	/**
	 * Remote Config dataplane template data implementation.
	 */
	class ServerTemplateDataImpl {
	    constructor(template) {
	        if (!validator.isNonNullObject(template) ||
	            !validator.isNonEmptyString(template.etag)) {
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(template)}`);
	        }
	        this.etag = template.etag;
	        if (typeof template.parameters !== 'undefined') {
	            if (!validator.isNonNullObject(template.parameters)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
	            }
	            this.parameters = template.parameters;
	        }
	        else {
	            this.parameters = {};
	        }
	        if (typeof template.conditions !== 'undefined') {
	            if (!validator.isArray(template.conditions)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
	            }
	            this.conditions = template.conditions;
	        }
	        else {
	            this.conditions = [];
	        }
	        if (typeof template.version !== 'undefined') {
	            this.version = new VersionImpl(template.version);
	        }
	    }
	}
	/**
	* Remote Config Version internal implementation.
	*/
	class VersionImpl {
	    constructor(version) {
	        if (!validator.isNonNullObject(version)) {
	            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config version instance: ${JSON.stringify(version)}`);
	        }
	        if (typeof version.versionNumber !== 'undefined') {
	            if (!validator.isNonEmptyString(version.versionNumber) &&
	                !validator.isNumber(version.versionNumber)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be a non-empty string in int64 format or a number');
	            }
	            if (!Number.isInteger(Number(version.versionNumber))) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be an integer or a string in int64 format');
	            }
	            this.versionNumber = version.versionNumber;
	        }
	        if (typeof version.updateOrigin !== 'undefined') {
	            if (!validator.isNonEmptyString(version.updateOrigin)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update origin must be a non-empty string');
	            }
	            this.updateOrigin = version.updateOrigin;
	        }
	        if (typeof version.updateType !== 'undefined') {
	            if (!validator.isNonEmptyString(version.updateType)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update type must be a non-empty string');
	            }
	            this.updateType = version.updateType;
	        }
	        if (typeof version.updateUser !== 'undefined') {
	            if (!validator.isNonNullObject(version.updateUser)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update user must be a non-null object');
	            }
	            this.updateUser = version.updateUser;
	        }
	        if (typeof version.description !== 'undefined') {
	            if (!validator.isNonEmptyString(version.description)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version description must be a non-empty string');
	            }
	            this.description = version.description;
	        }
	        if (typeof version.rollbackSource !== 'undefined') {
	            if (!validator.isNonEmptyString(version.rollbackSource)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version rollback source must be a non-empty string');
	            }
	            this.rollbackSource = version.rollbackSource;
	        }
	        if (typeof version.isLegacy !== 'undefined') {
	            if (!validator.isBoolean(version.isLegacy)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version.isLegacy must be a boolean');
	            }
	            this.isLegacy = version.isLegacy;
	        }
	        // The backend API provides timestamps in ISO date strings. The Admin SDK exposes timestamps
	        // in UTC date strings. If a developer uses a previously obtained template with UTC timestamps
	        // we could still validate it below.
	        if (typeof version.updateTime !== 'undefined') {
	            if (!this.isValidTimestamp(version.updateTime)) {
	                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update time must be a valid date string');
	            }
	            this.updateTime = new Date(version.updateTime).toUTCString();
	        }
	    }
	    /**
	     * @returns A JSON-serializable representation of this object.
	     */
	    toJSON() {
	        return {
	            versionNumber: this.versionNumber,
	            updateOrigin: this.updateOrigin,
	            updateType: this.updateType,
	            updateUser: this.updateUser,
	            description: this.description,
	            rollbackSource: this.rollbackSource,
	            isLegacy: this.isLegacy,
	            updateTime: this.updateTime,
	        };
	    }
	    isValidTimestamp(timestamp) {
	        // This validation fails for timestamps earlier than January 1, 1970 and considers strings
	        // such as "1.2" as valid timestamps.
	        return validator.isNonEmptyString(timestamp) && (new Date(timestamp)).getTime() > 0;
	    }
	}
	return remoteConfig$1;
}

var appCheck$1 = {};

var appCheckApiClientInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredAppCheckApiClientInternal;

function requireAppCheckApiClientInternal () {
	if (hasRequiredAppCheckApiClientInternal) return appCheckApiClientInternal;
	hasRequiredAppCheckApiClientInternal = 1;
	(function (exports) {
		/*!
		 * @license
		 * Copyright 2021 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FirebaseAppCheckError = exports.APP_CHECK_ERROR_CODE_MAPPING = exports.AppCheckApiClient = void 0;
		const api_request_1 = /*@__PURE__*/ requireApiRequest();
		const error_1 = error;
		const utils = utils$1;
		const validator = validator$2;
		// App Check backend constants
		const FIREBASE_APP_CHECK_V1_API_URL_FORMAT = 'https://firebaseappcheck.googleapis.com/v1/projects/{projectId}/apps/{appId}:exchangeCustomToken';
		const ONE_TIME_USE_TOKEN_VERIFICATION_URL_FORMAT = 'https://firebaseappcheck.googleapis.com/v1beta/projects/{projectId}:verifyAppCheckToken';
		const FIREBASE_APP_CHECK_CONFIG_HEADERS = {
		    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`
		};
		/**
		 * Class that facilitates sending requests to the Firebase App Check backend API.
		 *
		 * @internal
		 */
		class AppCheckApiClient {
		    constructor(app) {
		        this.app = app;
		        if (!validator.isNonNullObject(app) || !('options' in app)) {
		            throw new FirebaseAppCheckError('invalid-argument', 'First argument passed to admin.appCheck() must be a valid Firebase app instance.');
		        }
		        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
		    }
		    /**
		     * Exchange a signed custom token to App Check token
		     *
		     * @param customToken - The custom token to be exchanged.
		     * @param appId - The mobile App ID.
		     * @returns A promise that fulfills with a `AppCheckToken`.
		     */
		    exchangeToken(customToken, appId) {
		        if (!validator.isNonEmptyString(appId)) {
		            throw new FirebaseAppCheckError('invalid-argument', '`appId` must be a non-empty string.');
		        }
		        if (!validator.isNonEmptyString(customToken)) {
		            throw new FirebaseAppCheckError('invalid-argument', '`customToken` must be a non-empty string.');
		        }
		        return this.getUrl(appId)
		            .then((url) => {
		            const request = {
		                method: 'POST',
		                url,
		                headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
		                data: { customToken }
		            };
		            return this.httpClient.send(request);
		        })
		            .then((resp) => {
		            return this.toAppCheckToken(resp);
		        })
		            .catch((err) => {
		            throw this.toFirebaseError(err);
		        });
		    }
		    verifyReplayProtection(token) {
		        if (!validator.isNonEmptyString(token)) {
		            throw new FirebaseAppCheckError('invalid-argument', '`token` must be a non-empty string.');
		        }
		        return this.getVerifyTokenUrl()
		            .then((url) => {
		            const request = {
		                method: 'POST',
		                url,
		                headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
		                data: { app_check_token: token }
		            };
		            return this.httpClient.send(request);
		        })
		            .then((resp) => {
		            if (typeof resp.data.alreadyConsumed !== 'undefined'
		                && !validator.isBoolean(resp.data?.alreadyConsumed)) {
		                throw new FirebaseAppCheckError('invalid-argument', '`alreadyConsumed` must be a boolean value.');
		            }
		            return resp.data.alreadyConsumed || false;
		        })
		            .catch((err) => {
		            throw this.toFirebaseError(err);
		        });
		    }
		    getUrl(appId) {
		        return this.getProjectId()
		            .then((projectId) => {
		            const urlParams = {
		                projectId,
		                appId,
		            };
		            const baseUrl = utils.formatString(FIREBASE_APP_CHECK_V1_API_URL_FORMAT, urlParams);
		            return utils.formatString(baseUrl);
		        });
		    }
		    getVerifyTokenUrl() {
		        return this.getProjectId()
		            .then((projectId) => {
		            const urlParams = {
		                projectId
		            };
		            const baseUrl = utils.formatString(ONE_TIME_USE_TOKEN_VERIFICATION_URL_FORMAT, urlParams);
		            return utils.formatString(baseUrl);
		        });
		    }
		    getProjectId() {
		        if (this.projectId) {
		            return Promise.resolve(this.projectId);
		        }
		        return utils.findProjectId(this.app)
		            .then((projectId) => {
		            if (!validator.isNonEmptyString(projectId)) {
		                throw new FirebaseAppCheckError('unknown-error', 'Failed to determine project ID. Initialize the '
		                    + 'SDK with service account credentials or set project ID as an app option. '
		                    + 'Alternatively, set the GOOGLE_CLOUD_PROJECT environment variable.');
		            }
		            this.projectId = projectId;
		            return projectId;
		        });
		    }
		    toFirebaseError(err) {
		        if (err instanceof error_1.PrefixedFirebaseError) {
		            return err;
		        }
		        const response = err.response;
		        if (!response.isJson()) {
		            return new FirebaseAppCheckError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);
		        }
		        const error = response.data.error || {};
		        let code = 'unknown-error';
		        if (error.status && error.status in exports.APP_CHECK_ERROR_CODE_MAPPING) {
		            code = exports.APP_CHECK_ERROR_CODE_MAPPING[error.status];
		        }
		        const message = error.message || `Unknown server error: ${response.text}`;
		        return new FirebaseAppCheckError(code, message);
		    }
		    /**
		     * Creates an AppCheckToken from the API response.
		     *
		     * @param resp - API response object.
		     * @returns An AppCheckToken instance.
		     */
		    toAppCheckToken(resp) {
		        const token = resp.data.token;
		        // `ttl` is a string with the suffix "s" preceded by the number of seconds,
		        // with nanoseconds expressed as fractional seconds.
		        const ttlMillis = this.stringToMilliseconds(resp.data.ttl);
		        return {
		            token,
		            ttlMillis
		        };
		    }
		    /**
		     * Converts a duration string with the suffix `s` to milliseconds.
		     *
		     * @param duration - The duration as a string with the suffix "s" preceded by the
		     * number of seconds, with fractional seconds. For example, 3 seconds with 0 nanoseconds
		     * is expressed as "3s", while 3 seconds and 1 nanosecond is expressed as "3.000000001s",
		     * and 3 seconds and 1 microsecond is expressed as "3.000001s".
		     *
		     * @returns The duration in milliseconds.
		     */
		    stringToMilliseconds(duration) {
		        if (!validator.isNonEmptyString(duration) || !duration.endsWith('s')) {
		            throw new FirebaseAppCheckError('invalid-argument', '`ttl` must be a valid duration string with the suffix `s`.');
		        }
		        const seconds = duration.slice(0, -1);
		        return Math.floor(Number(seconds) * 1000);
		    }
		}
		exports.AppCheckApiClient = AppCheckApiClient;
		exports.APP_CHECK_ERROR_CODE_MAPPING = {
		    ABORTED: 'aborted',
		    INVALID_ARGUMENT: 'invalid-argument',
		    INVALID_CREDENTIAL: 'invalid-credential',
		    INTERNAL: 'internal-error',
		    PERMISSION_DENIED: 'permission-denied',
		    UNAUTHENTICATED: 'unauthenticated',
		    NOT_FOUND: 'not-found',
		    UNKNOWN: 'unknown-error',
		};
		/**
		 * Firebase App Check error code structure. This extends PrefixedFirebaseError.
		 *
		 * @param code - The error code.
		 * @param message - The error message.
		 * @constructor
		 */
		class FirebaseAppCheckError extends error_1.PrefixedFirebaseError {
		    constructor(code, message) {
		        super('app-check', code, message);
		        /* tslint:disable:max-line-length */
		        // Set the prototype explicitly. See the following link for more details:
		        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
		        /* tslint:enable:max-line-length */
		        this.__proto__ = FirebaseAppCheckError.prototype;
		    }
		}
		exports.FirebaseAppCheckError = FirebaseAppCheckError; 
	} (appCheckApiClientInternal));
	return appCheckApiClientInternal;
}

var tokenGenerator = {};

/*! firebase-admin v12.7.0 */

var hasRequiredTokenGenerator;

function requireTokenGenerator () {
	if (hasRequiredTokenGenerator) return tokenGenerator;
	hasRequiredTokenGenerator = 1;
	/*!
	 * @license
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tokenGenerator, "__esModule", { value: true });
	tokenGenerator.appCheckErrorFromCryptoSignerError = tokenGenerator.AppCheckTokenGenerator = void 0;
	const validator = validator$2;
	const utils_1 = utils$1;
	const crypto_signer_1 = /*@__PURE__*/ requireCryptoSigner();
	const app_check_api_client_internal_1 = /*@__PURE__*/ requireAppCheckApiClientInternal();
	const ONE_MINUTE_IN_SECONDS = 60;
	const ONE_MINUTE_IN_MILLIS = ONE_MINUTE_IN_SECONDS * 1000;
	const ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1000;
	// Audience to use for Firebase App Check Custom tokens
	const FIREBASE_APP_CHECK_AUDIENCE = 'https://firebaseappcheck.googleapis.com/google.firebase.appcheck.v1.TokenExchangeService';
	/**
	 * Class for generating Firebase App Check tokens.
	 *
	 * @internal
	 */
	class AppCheckTokenGenerator {
	    /**
	     * The AppCheckTokenGenerator class constructor.
	     *
	     * @param signer - The CryptoSigner instance for this token generator.
	     * @constructor
	     */
	    constructor(signer) {
	        if (!validator.isNonNullObject(signer)) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'INTERNAL ASSERT: Must provide a CryptoSigner to use AppCheckTokenGenerator.');
	        }
	        this.signer = signer;
	    }
	    /**
	     * Creates a new custom token that can be exchanged to an App Check token.
	     *
	     * @param appId - The Application ID to use for the generated token.
	     *
	     * @returns A Promise fulfilled with a custom token signed with a service account key
	     * that can be exchanged to an App Check token.
	     */
	    createCustomToken(appId, options) {
	        if (!validator.isNonEmptyString(appId)) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', '`appId` must be a non-empty string.');
	        }
	        let customOptions = {};
	        if (typeof options !== 'undefined') {
	            customOptions = this.validateTokenOptions(options);
	        }
	        return this.signer.getAccountId().then((account) => {
	            const header = {
	                alg: this.signer.algorithm,
	                typ: 'JWT',
	            };
	            const iat = Math.floor(Date.now() / 1000);
	            const body = {
	                iss: account,
	                sub: account,
	                app_id: appId,
	                aud: FIREBASE_APP_CHECK_AUDIENCE,
	                exp: iat + (ONE_MINUTE_IN_SECONDS * 5),
	                iat,
	                ...customOptions,
	            };
	            const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;
	            return this.signer.sign(Buffer.from(token))
	                .then((signature) => {
	                return `${token}.${this.encodeSegment(signature)}`;
	            });
	        }).catch((err) => {
	            throw appCheckErrorFromCryptoSignerError(err);
	        });
	    }
	    encodeSegment(segment) {
	        const buffer = (segment instanceof Buffer) ? segment : Buffer.from(JSON.stringify(segment));
	        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');
	    }
	    /**
	     * Checks if a given `AppCheckTokenOptions` object is valid. If successful, returns an object with
	     * custom properties.
	     *
	     * @param options - An options object to be validated.
	     * @returns A custom object with ttl converted to protobuf Duration string format.
	     */
	    validateTokenOptions(options) {
	        if (!validator.isNonNullObject(options)) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'AppCheckTokenOptions must be a non-null object.');
	        }
	        if (typeof options.ttlMillis !== 'undefined') {
	            if (!validator.isNumber(options.ttlMillis)) {
	                throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds.');
	            }
	            // ttlMillis must be between 30 minutes and 7 days (inclusive)
	            if (options.ttlMillis < (ONE_MINUTE_IN_MILLIS * 30) || options.ttlMillis > (ONE_DAY_IN_MILLIS * 7)) {
	                throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds between 30 minutes and 7 days (inclusive).');
	            }
	            return { ttl: (0, utils_1.transformMillisecondsToSecondsString)(options.ttlMillis) };
	        }
	        return {};
	    }
	}
	tokenGenerator.AppCheckTokenGenerator = AppCheckTokenGenerator;
	/**
	 * Creates a new `FirebaseAppCheckError` by extracting the error code, message and other relevant
	 * details from a `CryptoSignerError`.
	 *
	 * @param err - The Error to convert into a `FirebaseAppCheckError` error
	 * @returns A Firebase App Check error that can be returned to the user.
	 */
	function appCheckErrorFromCryptoSignerError(err) {
	    if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
	        return err;
	    }
	    if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
	        const httpError = err.cause;
	        const errorResponse = httpError.response.data;
	        if (errorResponse?.error) {
	            const status = errorResponse.error.status;
	            const description = errorResponse.error.message || JSON.stringify(httpError.response);
	            let code = 'unknown-error';
	            if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {
	                code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];
	            }
	            return new app_check_api_client_internal_1.FirebaseAppCheckError(code, `Error returned from server while signing a custom token: ${description}`);
	        }
	        return new app_check_api_client_internal_1.FirebaseAppCheckError('internal-error', 'Error returned from server: ' + JSON.stringify(errorResponse) + '.');
	    }
	    return new app_check_api_client_internal_1.FirebaseAppCheckError(mapToAppCheckErrorCode(err.code), err.message);
	}
	tokenGenerator.appCheckErrorFromCryptoSignerError = appCheckErrorFromCryptoSignerError;
	function mapToAppCheckErrorCode(code) {
	    switch (code) {
	        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:
	            return 'invalid-credential';
	        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:
	            return 'invalid-argument';
	        default:
	            return 'internal-error';
	    }
	}
	return tokenGenerator;
}

var tokenVerifier = {};

/*! firebase-admin v12.7.0 */

var hasRequiredTokenVerifier;

function requireTokenVerifier () {
	if (hasRequiredTokenVerifier) return tokenVerifier;
	hasRequiredTokenVerifier = 1;
	/*!
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tokenVerifier, "__esModule", { value: true });
	tokenVerifier.AppCheckTokenVerifier = void 0;
	const validator = validator$2;
	const util = utils$1;
	const app_check_api_client_internal_1 = /*@__PURE__*/ requireAppCheckApiClientInternal();
	const jwt_1 = /*@__PURE__*/ requireJwt();
	const APP_CHECK_ISSUER = 'https://firebaseappcheck.googleapis.com/';
	const JWKS_URL = 'https://firebaseappcheck.googleapis.com/v1/jwks';
	/**
	 * Class for verifying Firebase App Check tokens.
	 *
	 * @internal
	 */
	class AppCheckTokenVerifier {
	    constructor(app) {
	        this.app = app;
	        this.signatureVerifier = jwt_1.PublicKeySignatureVerifier.withJwksUrl(JWKS_URL, app.options.httpAgent);
	    }
	    /**
	     * Verifies the format and signature of a Firebase App Check token.
	     *
	     * @param token - The Firebase Auth JWT token to verify.
	     * @returns A promise fulfilled with the decoded claims of the Firebase App Check token.
	     */
	    verifyToken(token) {
	        if (!validator.isString(token)) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'App check token must be a non-null string.');
	        }
	        return this.ensureProjectId()
	            .then((projectId) => {
	            return this.decodeAndVerify(token, projectId);
	        })
	            .then((decoded) => {
	            const decodedAppCheckToken = decoded.payload;
	            decodedAppCheckToken.app_id = decodedAppCheckToken.sub;
	            return decodedAppCheckToken;
	        });
	    }
	    ensureProjectId() {
	        return util.findProjectId(this.app)
	            .then((projectId) => {
	            if (!validator.isNonEmptyString(projectId)) {
	                throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-credential', 'Must initialize app with a cert credential or set your Firebase project ID as the ' +
	                    'GOOGLE_CLOUD_PROJECT environment variable to verify an App Check token.');
	            }
	            return projectId;
	        });
	    }
	    decodeAndVerify(token, projectId) {
	        return this.safeDecode(token)
	            .then((decodedToken) => {
	            this.verifyContent(decodedToken, projectId);
	            return this.verifySignature(token)
	                .then(() => decodedToken);
	        });
	    }
	    safeDecode(jwtToken) {
	        return (0, jwt_1.decodeJwt)(jwtToken)
	            .catch(() => {
	            const errorMessage = 'Decoding App Check token failed. Make sure you passed ' +
	                'the entire string JWT which represents the Firebase App Check token.';
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', errorMessage);
	        });
	    }
	    /**
	     * Verifies the content of a Firebase App Check JWT.
	     *
	     * @param fullDecodedToken - The decoded JWT.
	     * @param projectId - The Firebase Project Id.
	     */
	    verifyContent(fullDecodedToken, projectId) {
	        const header = fullDecodedToken.header;
	        const payload = fullDecodedToken.payload;
	        const projectIdMatchMessage = ' Make sure the App Check token comes from the same ' +
	            'Firebase project as the service account used to authenticate this SDK.';
	        const scopedProjectId = `projects/${projectId}`;
	        let errorMessage;
	        if (header.alg !== jwt_1.ALGORITHM_RS256) {
	            errorMessage = 'The provided App Check token has incorrect algorithm. Expected "' +
	                jwt_1.ALGORITHM_RS256 + '" but got ' + '"' + header.alg + '".';
	        }
	        else if (!validator.isNonEmptyArray(payload.aud) || !payload.aud.includes(scopedProjectId)) {
	            errorMessage = 'The provided App Check token has incorrect "aud" (audience) claim. Expected "' +
	                scopedProjectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage;
	        }
	        else if (typeof payload.iss !== 'string' || !payload.iss.startsWith(APP_CHECK_ISSUER)) {
	            errorMessage = 'The provided App Check token has incorrect "iss" (issuer) claim.';
	        }
	        else if (typeof payload.sub !== 'string') {
	            errorMessage = 'The provided App Check token has no "sub" (subject) claim.';
	        }
	        else if (payload.sub === '') {
	            errorMessage = 'The provided App Check token has an empty string "sub" (subject) claim.';
	        }
	        if (errorMessage) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', errorMessage);
	        }
	    }
	    verifySignature(jwtToken) {
	        return this.signatureVerifier.verify(jwtToken)
	            .catch((error) => {
	            throw this.mapJwtErrorToAppCheckError(error);
	        });
	    }
	    /**
	     * Maps JwtError to FirebaseAppCheckError
	     *
	     * @param error - JwtError to be mapped.
	     * @returns FirebaseAppCheckError instance.
	     */
	    mapJwtErrorToAppCheckError(error) {
	        if (error.code === jwt_1.JwtErrorCode.TOKEN_EXPIRED) {
	            const errorMessage = 'The provided App Check token has expired. Get a fresh App Check token' +
	                ' from your client app and try again.';
	            return new app_check_api_client_internal_1.FirebaseAppCheckError('app-check-token-expired', errorMessage);
	        }
	        else if (error.code === jwt_1.JwtErrorCode.INVALID_SIGNATURE) {
	            const errorMessage = 'The provided App Check token has invalid signature.';
	            return new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', errorMessage);
	        }
	        else if (error.code === jwt_1.JwtErrorCode.NO_MATCHING_KID) {
	            const errorMessage = 'The provided App Check token has "kid" claim which does not ' +
	                'correspond to a known public key. Most likely the provided App Check token ' +
	                'is expired, so get a fresh token from your client app and try again.';
	            return new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', errorMessage);
	        }
	        return new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', error.message);
	    }
	}
	tokenVerifier.AppCheckTokenVerifier = AppCheckTokenVerifier;
	return tokenVerifier;
}

/*! firebase-admin v12.7.0 */

var hasRequiredAppCheck$1;

function requireAppCheck$1 () {
	if (hasRequiredAppCheck$1) return appCheck$1;
	hasRequiredAppCheck$1 = 1;
	/*!
	 * @license
	 * Copyright 2021 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(appCheck$1, "__esModule", { value: true });
	appCheck$1.AppCheck = void 0;
	const validator = validator$2;
	const app_check_api_client_internal_1 = /*@__PURE__*/ requireAppCheckApiClientInternal();
	const token_generator_1 = /*@__PURE__*/ requireTokenGenerator();
	const token_verifier_1 = /*@__PURE__*/ requireTokenVerifier();
	const crypto_signer_1 = /*@__PURE__*/ requireCryptoSigner();
	/**
	 * The Firebase `AppCheck` service interface.
	 */
	class AppCheck {
	    /**
	     * @param app - The app for this AppCheck service.
	     * @constructor
	     * @internal
	     */
	    constructor(app) {
	        this.app = app;
	        this.client = new app_check_api_client_internal_1.AppCheckApiClient(app);
	        try {
	            this.tokenGenerator = new token_generator_1.AppCheckTokenGenerator((0, crypto_signer_1.cryptoSignerFromApp)(app));
	        }
	        catch (err) {
	            throw (0, token_generator_1.appCheckErrorFromCryptoSignerError)(err);
	        }
	        this.appCheckTokenVerifier = new token_verifier_1.AppCheckTokenVerifier(app);
	    }
	    /**
	     * Creates a new {@link AppCheckToken} that can be sent
	     * back to a client.
	     *
	     * @param appId - The app ID to use as the JWT app_id.
	     * @param options - Optional options object when creating a new App Check Token.
	     *
	     * @returns A promise that fulfills with a `AppCheckToken`.
	     */
	    createToken(appId, options) {
	        return this.tokenGenerator.createCustomToken(appId, options)
	            .then((customToken) => {
	            return this.client.exchangeToken(customToken, appId);
	        });
	    }
	    /**
	     * Verifies a Firebase App Check token (JWT). If the token is valid, the promise is
	     * fulfilled with the token's decoded claims; otherwise, the promise is
	     * rejected.
	     *
	     * @param appCheckToken - The App Check token to verify.
	     * @param options - Optional {@link VerifyAppCheckTokenOptions} object when verifying an App Check Token.
	     *
	     * @returns A promise fulfilled with the token's decoded claims
	     *   if the App Check token is valid; otherwise, a rejected promise.
	     */
	    verifyToken(appCheckToken, options) {
	        this.validateVerifyAppCheckTokenOptions(options);
	        return this.appCheckTokenVerifier.verifyToken(appCheckToken)
	            .then((decodedToken) => {
	            if (options?.consume) {
	                return this.client.verifyReplayProtection(appCheckToken)
	                    .then((alreadyConsumed) => {
	                    return {
	                        alreadyConsumed,
	                        appId: decodedToken.app_id,
	                        token: decodedToken,
	                    };
	                });
	            }
	            return {
	                appId: decodedToken.app_id,
	                token: decodedToken,
	            };
	        });
	    }
	    validateVerifyAppCheckTokenOptions(options) {
	        if (typeof options === 'undefined') {
	            return;
	        }
	        if (!validator.isNonNullObject(options)) {
	            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'VerifyAppCheckTokenOptions must be a non-null object.');
	        }
	    }
	}
	appCheck$1.AppCheck = AppCheck;
	return appCheck$1;
}

var auth = {};

/*! firebase-admin v12.7.0 */

var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth;
	hasRequiredAuth = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AuthClientErrorCode = exports.FirebaseAuthError = exports.UserRecord = exports.UserMetadata = exports.UserInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorSettings = exports.MultiFactorInfo = exports.ProjectConfigManager = exports.ProjectConfig = exports.TenantManager = exports.TenantAwareAuth = exports.Tenant = exports.BaseAuth = exports.Auth = exports.getAuth = void 0;
		/**
		 * Firebase Authentication.
		 *
		 * @packageDocumentation
		 */
		const index_1 = /*@__PURE__*/ requireApp();
		const auth_1 = /*@__PURE__*/ requireAuth$1();
		/**
		 * Gets the {@link Auth} service for the default app or a
		 * given app.
		 *
		 * `getAuth()` can be called with no arguments to access the default app's
		 * {@link Auth} service or as `getAuth(app)` to access the
		 * {@link Auth} service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Auth service for the default app
		 * const defaultAuth = getAuth();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Auth service for a given app
		 * const otherAuth = getAuth(otherApp);
		 * ```
		 *
		 */
		function getAuth(app) {
		    if (typeof app === 'undefined') {
		        app = (0, index_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('auth', (app) => new auth_1.Auth(app));
		}
		exports.getAuth = getAuth;
		var auth_2 = /*@__PURE__*/ requireAuth$1();
		Object.defineProperty(exports, "Auth", { enumerable: true, get: function () { return auth_2.Auth; } });
		var base_auth_1 = /*@__PURE__*/ requireBaseAuth();
		Object.defineProperty(exports, "BaseAuth", { enumerable: true, get: function () { return base_auth_1.BaseAuth; } });
		var tenant_1 = /*@__PURE__*/ requireTenant();
		Object.defineProperty(exports, "Tenant", { enumerable: true, get: function () { return tenant_1.Tenant; } });
		var tenant_manager_1 = /*@__PURE__*/ requireTenantManager();
		Object.defineProperty(exports, "TenantAwareAuth", { enumerable: true, get: function () { return tenant_manager_1.TenantAwareAuth; } });
		Object.defineProperty(exports, "TenantManager", { enumerable: true, get: function () { return tenant_manager_1.TenantManager; } });
		var project_config_1 = /*@__PURE__*/ requireProjectConfig();
		Object.defineProperty(exports, "ProjectConfig", { enumerable: true, get: function () { return project_config_1.ProjectConfig; } });
		var project_config_manager_1 = /*@__PURE__*/ requireProjectConfigManager();
		Object.defineProperty(exports, "ProjectConfigManager", { enumerable: true, get: function () { return project_config_manager_1.ProjectConfigManager; } });
		var user_record_1 = /*@__PURE__*/ requireUserRecord();
		Object.defineProperty(exports, "MultiFactorInfo", { enumerable: true, get: function () { return user_record_1.MultiFactorInfo; } });
		Object.defineProperty(exports, "MultiFactorSettings", { enumerable: true, get: function () { return user_record_1.MultiFactorSettings; } });
		Object.defineProperty(exports, "PhoneMultiFactorInfo", { enumerable: true, get: function () { return user_record_1.PhoneMultiFactorInfo; } });
		Object.defineProperty(exports, "UserInfo", { enumerable: true, get: function () { return user_record_1.UserInfo; } });
		Object.defineProperty(exports, "UserMetadata", { enumerable: true, get: function () { return user_record_1.UserMetadata; } });
		Object.defineProperty(exports, "UserRecord", { enumerable: true, get: function () { return user_record_1.UserRecord; } });
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseAuthError", { enumerable: true, get: function () { return error_1.FirebaseAuthError; } });
		Object.defineProperty(exports, "AuthClientErrorCode", { enumerable: true, get: function () { return error_1.AuthClientErrorCode; } }); 
	} (auth));
	return auth;
}

var appCheck = {};

/*! firebase-admin v12.7.0 */

var hasRequiredAppCheck;

function requireAppCheck () {
	if (hasRequiredAppCheck) return appCheck;
	hasRequiredAppCheck = 1;
	(function (exports) {
		/*!
		 * @license
		 * Copyright 2021 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getAppCheck = exports.AppCheck = void 0;
		/**
		 * Firebase App Check.
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const app_check_1 = /*@__PURE__*/ requireAppCheck$1();
		var app_check_2 = /*@__PURE__*/ requireAppCheck$1();
		Object.defineProperty(exports, "AppCheck", { enumerable: true, get: function () { return app_check_2.AppCheck; } });
		/**
		 * Gets the {@link AppCheck} service for the default app or a given app.
		 *
		 * `getAppCheck()` can be called with no arguments to access the default
		 * app's `AppCheck` service or as `getAppCheck(app)` to access the
		 * `AppCheck` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the `AppCheck` service for the default app
		 * const defaultAppCheck = getAppCheck();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the `AppCheck` service for a given app
		 * const otherAppCheck = getAppCheck(otherApp);
		 * ```
		 *
		 * @param app - Optional app for which to return the `AppCheck` service.
		 *   If not provided, the default `AppCheck` service is returned.
		 *
		 * @returns The default `AppCheck` service if no
		 *   app is provided, or the `AppCheck` service associated with the provided
		 *   app.
		 */
		function getAppCheck(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('appCheck', (app) => new app_check_1.AppCheck(app));
		}
		exports.getAppCheck = getAppCheck; 
	} (appCheck));
	return appCheck;
}

var database$1 = {};

var database = {};

/*! firebase-admin v12.7.0 */

var hasRequiredDatabase$1;

function requireDatabase$1 () {
	if (hasRequiredDatabase$1) return database;
	hasRequiredDatabase$1 = 1;
	/*!
	 * Copyright 2020 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(database, "__esModule", { value: true });
	database.DatabaseService = void 0;
	const url_1 = require$$0$2;
	const path = require$$1$4;
	const error_1 = error;
	const validator = validator$2;
	const api_request_1 = /*@__PURE__*/ requireApiRequest();
	const index_1 = utils$1;
	const TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;
	class DatabaseService {
	    constructor(app) {
	        this.databases = {};
	        if (!validator.isNonNullObject(app) || !('options' in app)) {
	            throw new error_1.FirebaseDatabaseError({
	                code: 'invalid-argument',
	                message: 'First argument passed to admin.database() must be a valid Firebase app instance.',
	            });
	        }
	        this.appInternal = app;
	    }
	    get firebaseApp() {
	        return this.app;
	    }
	    /**
	     * @internal
	     */
	    delete() {
	        if (this.tokenListener) {
	            this.firebaseApp.INTERNAL.removeAuthTokenListener(this.tokenListener);
	            clearTimeout(this.tokenRefreshTimeout);
	        }
	        const promises = [];
	        for (const dbUrl of Object.keys(this.databases)) {
	            const db = this.databases[dbUrl];
	            promises.push(db.INTERNAL.delete());
	        }
	        return Promise.all(promises).then(() => {
	            this.databases = {};
	        });
	    }
	    /**
	     * Returns the app associated with this DatabaseService instance.
	     *
	     * @returns The app associated with this DatabaseService instance.
	     */
	    get app() {
	        return this.appInternal;
	    }
	    getDatabase(url) {
	        const dbUrl = this.ensureUrl(url);
	        if (!validator.isNonEmptyString(dbUrl)) {
	            throw new error_1.FirebaseDatabaseError({
	                code: 'invalid-argument',
	                message: 'Database URL must be a valid, non-empty URL string.',
	            });
	        }
	        let db = this.databases[dbUrl];
	        if (typeof db === 'undefined') {
	            // eslint-disable-next-line @typescript-eslint/no-var-requires
	            const rtdb = require$$4;
	            db = rtdb.initStandalone(this.appInternal, dbUrl, (0, index_1.getSdkVersion)()).instance;
	            const rulesClient = new DatabaseRulesClient(this.app, dbUrl);
	            db.getRules = () => {
	                return rulesClient.getRules();
	            };
	            db.getRulesJSON = () => {
	                return rulesClient.getRulesJSON();
	            };
	            db.setRules = (source) => {
	                return rulesClient.setRules(source);
	            };
	            this.databases[dbUrl] = db;
	        }
	        if (!this.tokenListener) {
	            this.tokenListener = this.onTokenChange.bind(this);
	            this.firebaseApp.INTERNAL.addAuthTokenListener(this.tokenListener);
	        }
	        return db;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    onTokenChange(_) {
	        const token = this.firebaseApp.INTERNAL.getCachedToken();
	        if (token) {
	            const delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now();
	            // If the new token is set to expire soon (unlikely), do nothing. Somebody will eventually
	            // notice and refresh the token, at which point this callback will fire again.
	            if (delayMillis > 0) {
	                this.scheduleTokenRefresh(delayMillis);
	            }
	        }
	    }
	    scheduleTokenRefresh(delayMillis) {
	        clearTimeout(this.tokenRefreshTimeout);
	        this.tokenRefreshTimeout = setTimeout(() => {
	            this.firebaseApp.INTERNAL.getToken(/*forceRefresh=*/ true)
	                .catch(() => {
	                // Ignore the error since this might just be an intermittent failure. If we really cannot
	                // refresh the token, an error will be logged once the existing token expires and we try
	                // to fetch a fresh one.
	            });
	        }, delayMillis);
	    }
	    ensureUrl(url) {
	        if (typeof url !== 'undefined') {
	            return url;
	        }
	        else if (typeof this.appInternal.options.databaseURL !== 'undefined') {
	            return this.appInternal.options.databaseURL;
	        }
	        throw new error_1.FirebaseDatabaseError({
	            code: 'invalid-argument',
	            message: 'Can\'t determine Firebase Database URL.',
	        });
	    }
	}
	database.DatabaseService = DatabaseService;
	const RULES_URL_PATH = '.settings/rules.json';
	/**
	 * A helper client for managing RTDB security rules.
	 */
	class DatabaseRulesClient {
	    constructor(app, dbUrl) {
	        let parsedUrl = new url_1.URL(dbUrl);
	        const emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;
	        if (emulatorHost) {
	            const namespace = extractNamespace(parsedUrl);
	            parsedUrl = new url_1.URL(`http://${emulatorHost}?ns=${namespace}`);
	        }
	        parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);
	        this.dbUrl = parsedUrl.toString();
	        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
	    }
	    /**
	     * Gets the currently applied security rules as a string. The return value consists of
	     * the rules source including comments.
	     *
	     * @returns A promise fulfilled with the rules as a raw string.
	     */
	    getRules() {
	        const req = {
	            method: 'GET',
	            url: this.dbUrl,
	        };
	        return this.httpClient.send(req)
	            .then((resp) => {
	            if (!resp.text) {
	                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');
	            }
	            return resp.text;
	        })
	            .catch((err) => {
	            throw this.handleError(err);
	        });
	    }
	    /**
	     * Gets the currently applied security rules as a parsed JSON object. Any comments in
	     * the original source are stripped away.
	     *
	     * @returns {Promise<object>} A promise fulfilled with the parsed rules source.
	     */
	    getRulesJSON() {
	        const req = {
	            method: 'GET',
	            url: this.dbUrl,
	            data: { format: 'strict' },
	        };
	        return this.httpClient.send(req)
	            .then((resp) => {
	            return resp.data;
	        })
	            .catch((err) => {
	            throw this.handleError(err);
	        });
	    }
	    /**
	     * Sets the specified rules on the Firebase Database instance. If the rules source is
	     * specified as a string or a Buffer, it may include comments.
	     *
	     * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`
	     *  or empty.
	     * @returns {Promise<void>} Resolves when the rules are set on the Database.
	     */
	    setRules(source) {
	        if (!validator.isNonEmptyString(source) &&
	            !validator.isBuffer(source) &&
	            !validator.isNonNullObject(source)) {
	            const error = new error_1.FirebaseDatabaseError({
	                code: 'invalid-argument',
	                message: 'Source must be a non-empty string, Buffer or an object.',
	            });
	            return Promise.reject(error);
	        }
	        const req = {
	            method: 'PUT',
	            url: this.dbUrl,
	            data: source,
	            headers: {
	                'content-type': 'application/json; charset=utf-8',
	            },
	        };
	        return this.httpClient.send(req)
	            .then(() => {
	            return;
	        })
	            .catch((err) => {
	            throw this.handleError(err);
	        });
	    }
	    handleError(err) {
	        if (err instanceof api_request_1.RequestResponseError) {
	            return new error_1.FirebaseDatabaseError({
	                code: error_1.AppErrorCodes.INTERNAL_ERROR,
	                message: this.getErrorMessage(err),
	            });
	        }
	        return err;
	    }
	    getErrorMessage(err) {
	        const intro = 'Error while accessing security rules';
	        try {
	            const body = err.response.data;
	            if (body && body.error) {
	                return `${intro}: ${body.error.trim()}`;
	            }
	        }
	        catch {
	            // Ignore parsing errors
	        }
	        return `${intro}: ${err.response.text}`;
	    }
	}
	function extractNamespace(parsedUrl) {
	    const ns = parsedUrl.searchParams.get('ns');
	    if (ns) {
	        return ns;
	    }
	    const hostname = parsedUrl.hostname;
	    const dotIndex = hostname.indexOf('.');
	    return hostname.substring(0, dotIndex).toLowerCase();
	}
	return database;
}

/*! firebase-admin v12.7.0 */

var hasRequiredDatabase;

function requireDatabase () {
	if (hasRequiredDatabase) return database$1;
	hasRequiredDatabase = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FirebaseDatabaseError = exports.getDatabaseWithUrl = exports.getDatabase = exports.ServerValue = exports.enableLogging = void 0;
		const standalone_1 = require$$4;
		const app_1 = /*@__PURE__*/ requireApp();
		const database_1 = /*@__PURE__*/ requireDatabase$1();
		// TODO: Remove the following any-cast once the typins in @firebase/database-types are fixed.
		/**
		 * {@link https://firebase.google.com/docs/reference/js/v8/firebase.database#enablelogging | enableLogging}
		 * function from the `@firebase/database-compat` package.
		 */
		exports.enableLogging = standalone_1.enableLogging;
		/**
		 * {@link https://firebase.google.com/docs/reference/js/v8/firebase.database.ServerValue | ServerValue}
		 * constant from the `@firebase/database-compat` package.
		 */
		// eslint-disable-next-line @typescript-eslint/naming-convention
		exports.ServerValue = standalone_1.ServerValue;
		/**
		 * Gets the {@link Database} service for the default
		 * app or a given app.
		 *
		 * `getDatabase()` can be called with no arguments to access the default
		 * app's `Database` service or as `getDatabase(app)` to access the
		 * `Database` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Database service for the default app
		 * const defaultDatabase = getDatabase();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Database service for a specific app
		 * const otherDatabase = getDatabase(app);
		 * ```
		 *
		 * @param App - whose `Database` service to
		 *   return. If not provided, the default `Database` service will be returned.
		 *
		 * @returns The default `Database` service if no app
		 *   is provided or the `Database` service associated with the provided app.
		 */
		function getDatabase(app) {
		    return getDatabaseInstance({ app });
		}
		exports.getDatabase = getDatabase;
		/**
		 * Gets the {@link Database} service for the default
		 * app or a given app.
		 *
		 * `getDatabaseWithUrl()` can be called with no arguments to access the default
		 * app's {@link Database} service or as `getDatabaseWithUrl(app)` to access the
		 * {@link Database} service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Database service for the default app
		 * const defaultDatabase = getDatabaseWithUrl('https://example.firebaseio.com');
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Database service for a specific app
		 * const otherDatabase = getDatabaseWithUrl('https://example.firebaseio.com', app);
		 * ```
		 *
		 * @param App - whose `Database` service to
		 *   return. If not provided, the default `Database` service will be returned.
		 *
		 * @returns The default `Database` service if no app
		 *   is provided or the `Database` service associated with the provided app.
		 */
		function getDatabaseWithUrl(url, app) {
		    return getDatabaseInstance({ url, app });
		}
		exports.getDatabaseWithUrl = getDatabaseWithUrl;
		function getDatabaseInstance(options) {
		    let { app } = options;
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    const dbService = firebaseApp.getOrInitService('database', (app) => new database_1.DatabaseService(app));
		    return dbService.getDatabase(options.url);
		}
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseDatabaseError", { enumerable: true, get: function () { return error_1.FirebaseDatabaseError; } }); 
	} (database$1));
	return database$1;
}

var messaging = {};

/*! firebase-admin v12.7.0 */

var hasRequiredMessaging;

function requireMessaging () {
	if (hasRequiredMessaging) return messaging;
	hasRequiredMessaging = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MessagingClientErrorCode = exports.FirebaseMessagingError = exports.getMessaging = exports.Messaging = void 0;
		/**
		 * Firebase Cloud Messaging (FCM).
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const messaging_1 = /*@__PURE__*/ requireMessaging$1();
		var messaging_2 = /*@__PURE__*/ requireMessaging$1();
		Object.defineProperty(exports, "Messaging", { enumerable: true, get: function () { return messaging_2.Messaging; } });
		/**
		 * Gets the {@link Messaging} service for the default app or a given app.
		 *
		 * `admin.messaging()` can be called with no arguments to access the default
		 * app's `Messaging` service or as `admin.messaging(app)` to access the
		 * `Messaging` service associated with aspecific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Messaging service for the default app
		 * const defaultMessaging = getMessaging();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Messaging service for a given app
		 * const otherMessaging = getMessaging(otherApp);
		 * ```
		 *
		 * @param app - Optional app whose `Messaging` service to
		 *   return. If not provided, the default `Messaging` service will be returned.
		 *
		 * @returns The default `Messaging` service if no
		 *   app is provided or the `Messaging` service associated with the provided
		 *   app.
		 */
		function getMessaging(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('messaging', (app) => new messaging_1.Messaging(app));
		}
		exports.getMessaging = getMessaging;
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseMessagingError", { enumerable: true, get: function () { return error_1.FirebaseMessagingError; } });
		Object.defineProperty(exports, "MessagingClientErrorCode", { enumerable: true, get: function () { return error_1.MessagingClientErrorCode; } }); 
	} (messaging));
	return messaging;
}

var firestore = {};

var firestoreInternal = {};

/*! firebase-admin v12.7.0 */

var hasRequiredFirestoreInternal;

function requireFirestoreInternal () {
	if (hasRequiredFirestoreInternal) return firestoreInternal;
	hasRequiredFirestoreInternal = 1;
	/*!
	 * @license
	 * Copyright 2017 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(firestoreInternal, "__esModule", { value: true });
	firestoreInternal.getFirestoreOptions = firestoreInternal.FirestoreService = void 0;
	const error_1 = error;
	const credential_internal_1 = credentialInternal;
	const validator = validator$2;
	const utils = utils$1;
	class FirestoreService {
	    constructor(app) {
	        this.databases = new Map();
	        this.firestoreSettings = new Map();
	        this.appInternal = app;
	    }
	    initializeDatabase(databaseId, settings) {
	        const existingInstance = this.databases.get(databaseId);
	        if (existingInstance) {
	            const initialSettings = this.firestoreSettings.get(databaseId) ?? {};
	            if (this.checkIfSameSettings(settings, initialSettings)) {
	                return existingInstance;
	            }
	            throw new error_1.FirebaseFirestoreError({
	                code: 'failed-precondition',
	                message: 'initializeFirestore() has already been called with ' +
	                    'different options. To avoid this error, call initializeFirestore() with the ' +
	                    'same options as when it was originally called, or call getFirestore() to return the' +
	                    ' already initialized instance.'
	            });
	        }
	        const newInstance = initFirestore(this.app, databaseId, settings);
	        this.databases.set(databaseId, newInstance);
	        this.firestoreSettings.set(databaseId, settings);
	        return newInstance;
	    }
	    getDatabase(databaseId) {
	        let database = this.databases.get(databaseId);
	        if (database === undefined) {
	            database = initFirestore(this.app, databaseId, {});
	            this.databases.set(databaseId, database);
	            this.firestoreSettings.set(databaseId, {});
	        }
	        return database;
	    }
	    checkIfSameSettings(settingsA, settingsB) {
	        const a = settingsA ?? {};
	        const b = settingsB ?? {};
	        // If we start passing more settings to Firestore constructor,
	        // replace this with deep equality check.
	        return (a.preferRest === b.preferRest);
	    }
	    /**
	     * Returns the app associated with this Storage instance.
	     *
	     * @returns The app associated with this Storage instance.
	     */
	    get app() {
	        return this.appInternal;
	    }
	}
	firestoreInternal.FirestoreService = FirestoreService;
	function getFirestoreOptions(app, firestoreSettings) {
	    if (!validator.isNonNullObject(app) || !('options' in app)) {
	        throw new error_1.FirebaseFirestoreError({
	            code: 'invalid-argument',
	            message: 'First argument passed to admin.firestore() must be a valid Firebase app instance.',
	        });
	    }
	    const projectId = utils.getExplicitProjectId(app);
	    const credential = app.options.credential;
	    // eslint-disable-next-line @typescript-eslint/no-var-requires
	    const { version: firebaseVersion } = require$$4$1;
	    const preferRest = firestoreSettings?.preferRest;
	    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
	        return {
	            credentials: {
	                private_key: credential.privateKey,
	                client_email: credential.clientEmail,
	            },
	            // When the SDK is initialized with ServiceAccountCredentials an explicit projectId is
	            // guaranteed to be available.
	            projectId: projectId,
	            firebaseVersion,
	            preferRest,
	        };
	    }
	    else if ((0, credential_internal_1.isApplicationDefault)(app.options.credential)) {
	        // Try to use the Google application default credentials.
	        // If an explicit project ID is not available, let Firestore client discover one from the
	        // environment. This prevents the users from having to set GOOGLE_CLOUD_PROJECT in GCP runtimes.
	        return validator.isNonEmptyString(projectId)
	            ? { projectId, firebaseVersion, preferRest }
	            : { firebaseVersion, preferRest };
	    }
	    throw new error_1.FirebaseFirestoreError({
	        code: 'invalid-credential',
	        message: 'Failed to initialize Google Cloud Firestore client with the available credentials. ' +
	            'Must initialize the SDK with a certificate credential or application default credentials ' +
	            'to use Cloud Firestore API.',
	    });
	}
	firestoreInternal.getFirestoreOptions = getFirestoreOptions;
	function initFirestore(app, databaseId, firestoreSettings) {
	    const options = getFirestoreOptions(app, firestoreSettings);
	    options.databaseId = databaseId;
	    let firestoreDatabase;
	    try {
	        // Lazy-load the Firestore implementation here, which in turns loads gRPC.
	        firestoreDatabase = require('@google-cloud/firestore').Firestore;
	    }
	    catch (err) {
	        throw new error_1.FirebaseFirestoreError({
	            code: 'missing-dependencies',
	            message: 'Failed to import the Cloud Firestore client library for Node.js. '
	                + 'Make sure to install the "@google-cloud/firestore" npm package. '
	                + `Original error: ${err}`,
	        });
	    }
	    return new firestoreDatabase(options);
	}
	return firestoreInternal;
}

const require$$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(path$2);

/*! firebase-admin v12.7.0 */

var hasRequiredFirestore;

function requireFirestore () {
	if (hasRequiredFirestore) return firestore;
	hasRequiredFirestore = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FirebaseFirestoreError = exports.initializeFirestore = exports.getFirestore = exports.setLogFunction = exports.v1 = exports.WriteResult = exports.WriteBatch = exports.Transaction = exports.Timestamp = exports.QuerySnapshot = exports.QueryPartition = exports.QueryDocumentSnapshot = exports.Query = exports.GrpcStatus = exports.GeoPoint = exports.Firestore = exports.Filter = exports.FieldValue = exports.FieldPath = exports.DocumentSnapshot = exports.DocumentReference = exports.CollectionReference = exports.CollectionGroup = exports.BundleBuilder = exports.BulkWriter = exports.AggregateQuerySnapshot = exports.AggregateQuery = exports.AggregateField = void 0;
		const app_1 = /*@__PURE__*/ requireApp();
		const firestore_internal_1 = /*@__PURE__*/ requireFirestoreInternal();
		const path_1 = require$$2;
		var firestore_1 = require$$7;
		Object.defineProperty(exports, "AggregateField", { enumerable: true, get: function () { return firestore_1.AggregateField; } });
		Object.defineProperty(exports, "AggregateQuery", { enumerable: true, get: function () { return firestore_1.AggregateQuery; } });
		Object.defineProperty(exports, "AggregateQuerySnapshot", { enumerable: true, get: function () { return firestore_1.AggregateQuerySnapshot; } });
		Object.defineProperty(exports, "BulkWriter", { enumerable: true, get: function () { return firestore_1.BulkWriter; } });
		Object.defineProperty(exports, "BundleBuilder", { enumerable: true, get: function () { return firestore_1.BundleBuilder; } });
		Object.defineProperty(exports, "CollectionGroup", { enumerable: true, get: function () { return firestore_1.CollectionGroup; } });
		Object.defineProperty(exports, "CollectionReference", { enumerable: true, get: function () { return firestore_1.CollectionReference; } });
		Object.defineProperty(exports, "DocumentReference", { enumerable: true, get: function () { return firestore_1.DocumentReference; } });
		Object.defineProperty(exports, "DocumentSnapshot", { enumerable: true, get: function () { return firestore_1.DocumentSnapshot; } });
		Object.defineProperty(exports, "FieldPath", { enumerable: true, get: function () { return firestore_1.FieldPath; } });
		Object.defineProperty(exports, "FieldValue", { enumerable: true, get: function () { return firestore_1.FieldValue; } });
		Object.defineProperty(exports, "Filter", { enumerable: true, get: function () { return firestore_1.Filter; } });
		Object.defineProperty(exports, "Firestore", { enumerable: true, get: function () { return firestore_1.Firestore; } });
		Object.defineProperty(exports, "GeoPoint", { enumerable: true, get: function () { return firestore_1.GeoPoint; } });
		Object.defineProperty(exports, "GrpcStatus", { enumerable: true, get: function () { return firestore_1.GrpcStatus; } });
		Object.defineProperty(exports, "Query", { enumerable: true, get: function () { return firestore_1.Query; } });
		Object.defineProperty(exports, "QueryDocumentSnapshot", { enumerable: true, get: function () { return firestore_1.QueryDocumentSnapshot; } });
		Object.defineProperty(exports, "QueryPartition", { enumerable: true, get: function () { return firestore_1.QueryPartition; } });
		Object.defineProperty(exports, "QuerySnapshot", { enumerable: true, get: function () { return firestore_1.QuerySnapshot; } });
		Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return firestore_1.Timestamp; } });
		Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return firestore_1.Transaction; } });
		Object.defineProperty(exports, "WriteBatch", { enumerable: true, get: function () { return firestore_1.WriteBatch; } });
		Object.defineProperty(exports, "WriteResult", { enumerable: true, get: function () { return firestore_1.WriteResult; } });
		Object.defineProperty(exports, "v1", { enumerable: true, get: function () { return firestore_1.v1; } });
		Object.defineProperty(exports, "setLogFunction", { enumerable: true, get: function () { return firestore_1.setLogFunction; } });
		function getFirestore(appOrDatabaseId, optionalDatabaseId) {
		    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0, app_1.getApp)();
		    const databaseId = (typeof appOrDatabaseId === 'string' ? appOrDatabaseId : optionalDatabaseId) || path_1.DEFAULT_DATABASE_ID;
		    const firebaseApp = app;
		    const firestoreService = firebaseApp.getOrInitService('firestore', (app) => new firestore_internal_1.FirestoreService(app));
		    return firestoreService.getDatabase(databaseId);
		}
		exports.getFirestore = getFirestore;
		function initializeFirestore(app, settings, databaseId) {
		    settings ?? (settings = {});
		    databaseId ?? (databaseId = path_1.DEFAULT_DATABASE_ID);
		    const firebaseApp = app;
		    const firestoreService = firebaseApp.getOrInitService('firestore', (app) => new firestore_internal_1.FirestoreService(app));
		    return firestoreService.initializeDatabase(databaseId, settings);
		}
		exports.initializeFirestore = initializeFirestore;
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseFirestoreError", { enumerable: true, get: function () { return error_1.FirebaseFirestoreError; } }); 
	} (firestore));
	return firestore;
}

var instanceId = {};

/*! firebase-admin v12.7.0 */

var hasRequiredInstanceId;

function requireInstanceId () {
	if (hasRequiredInstanceId) return instanceId;
	hasRequiredInstanceId = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.InstanceIdClientErrorCode = exports.FirebaseInstanceIdError = exports.getInstanceId = exports.InstanceId = void 0;
		/**
		 * Firebase Instance ID service.
		 *
		 * @packageDocumentation
		 */
		const index_1 = /*@__PURE__*/ requireApp();
		const instance_id_1 = /*@__PURE__*/ requireInstanceId$1();
		Object.defineProperty(exports, "InstanceId", { enumerable: true, get: function () { return instance_id_1.InstanceId; } });
		/**
		 * Gets the {@link InstanceId} service for the default app or a given app.
		 *
		 * This API is deprecated. Developers are advised to use the
		 * {@link firebase-admin.installations#getInstallations}
		 * API to delete their instance IDs and Firebase installation IDs.
		 *
		 * `getInstanceId()` can be called with no arguments to access the default
		 * app's `InstanceId` service or as `getInstanceId(app)` to access the
		 * `InstanceId` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the Instance ID service for the default app
		 * const defaultInstanceId = getInstanceId();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the Instance ID service for a given app
		 * const otherInstanceId = getInstanceId(otherApp);
		 *```
		 *
		 * This API is deprecated. Developers are advised to use the `admin.installations()`
		 * API to delete their instance IDs and Firebase installation IDs.
		 *
		 * @param app - Optional app whose `InstanceId` service to
		 *   return. If not provided, the default `InstanceId` service will be
		 *   returned.
		 *
		 * @returns The default `InstanceId` service if
		 *   no app is provided or the `InstanceId` service associated with the
		 *   provided app.
		 *
		 * @deprecated Use {@link firebase-admin.installations#getInstallations} instead.
		 */
		function getInstanceId(app) {
		    if (typeof app === 'undefined') {
		        app = (0, index_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('instanceId', (app) => new instance_id_1.InstanceId(app));
		}
		exports.getInstanceId = getInstanceId;
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseInstanceIdError", { enumerable: true, get: function () { return error_1.FirebaseInstanceIdError; } });
		Object.defineProperty(exports, "InstanceIdClientErrorCode", { enumerable: true, get: function () { return error_1.InstanceIdClientErrorCode; } }); 
	} (instanceId));
	return instanceId;
}

var machineLearning = {};

/*! firebase-admin v12.7.0 */

var hasRequiredMachineLearning;

function requireMachineLearning () {
	if (hasRequiredMachineLearning) return machineLearning;
	hasRequiredMachineLearning = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getMachineLearning = exports.Model = exports.MachineLearning = void 0;
		/**
		 * Firebase Machine Learning.
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const machine_learning_1 = /*@__PURE__*/ requireMachineLearning$1();
		var machine_learning_2 = /*@__PURE__*/ requireMachineLearning$1();
		Object.defineProperty(exports, "MachineLearning", { enumerable: true, get: function () { return machine_learning_2.MachineLearning; } });
		Object.defineProperty(exports, "Model", { enumerable: true, get: function () { return machine_learning_2.Model; } });
		/**
		 * Gets the {@link MachineLearning} service for the default app or a given app.
		 *
		 * `getMachineLearning()` can be called with no arguments to access the
		 * default app's `MachineLearning` service or as `getMachineLearning(app)` to access
		 * the `MachineLearning` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the MachineLearning service for the default app
		 * const defaultMachineLearning = getMachineLearning();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the MachineLearning service for a given app
		 * const otherMachineLearning = getMachineLearning(otherApp);
		 * ```
		 *
		 * @param app - Optional app whose `MachineLearning` service to
		 *   return. If not provided, the default `MachineLearning` service
		 *   will be returned.
		 *
		 * @returns The default `MachineLearning` service if no app is provided or the
		 *   `MachineLearning` service associated with the provided app.
		 */
		function getMachineLearning(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('machineLearning', (app) => new machine_learning_1.MachineLearning(app));
		}
		exports.getMachineLearning = getMachineLearning; 
	} (machineLearning));
	return machineLearning;
}

var projectManagement = {};

/*! firebase-admin v12.7.0 */

var hasRequiredProjectManagement;

function requireProjectManagement () {
	if (hasRequiredProjectManagement) return projectManagement;
	hasRequiredProjectManagement = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FirebaseProjectManagementError = exports.getProjectManagement = exports.IosApp = exports.ShaCertificate = exports.AndroidApp = exports.ProjectManagement = exports.AppPlatform = void 0;
		/**
		 * Firebase project management.
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const project_management_1 = /*@__PURE__*/ requireProjectManagement$1();
		var app_metadata_1 = /*@__PURE__*/ requireAppMetadata();
		Object.defineProperty(exports, "AppPlatform", { enumerable: true, get: function () { return app_metadata_1.AppPlatform; } });
		var project_management_2 = /*@__PURE__*/ requireProjectManagement$1();
		Object.defineProperty(exports, "ProjectManagement", { enumerable: true, get: function () { return project_management_2.ProjectManagement; } });
		var android_app_1 = /*@__PURE__*/ requireAndroidApp();
		Object.defineProperty(exports, "AndroidApp", { enumerable: true, get: function () { return android_app_1.AndroidApp; } });
		Object.defineProperty(exports, "ShaCertificate", { enumerable: true, get: function () { return android_app_1.ShaCertificate; } });
		var ios_app_1 = /*@__PURE__*/ requireIosApp();
		Object.defineProperty(exports, "IosApp", { enumerable: true, get: function () { return ios_app_1.IosApp; } });
		/**
		 * Gets the {@link ProjectManagement} service for the default app or a given app.
		 *
		 * `getProjectManagement()` can be called with no arguments to access the
		 * default app's `ProjectManagement` service, or as `getProjectManagement(app)` to access
		 * the `ProjectManagement` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the ProjectManagement service for the default app
		 * const defaultProjectManagement = getProjectManagement();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the ProjectManagement service for a given app
		 * const otherProjectManagement = getProjectManagement(otherApp);
		 * ```
		 *
		 * @param app - Optional app whose `ProjectManagement` service
		 *     to return. If not provided, the default `ProjectManagement` service will
		 *     be returned. *
		 * @returns The default `ProjectManagement` service if no app is provided or the
		 *   `ProjectManagement` service associated with the provided app.
		 */
		function getProjectManagement(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('projectManagement', (app) => new project_management_1.ProjectManagement(app));
		}
		exports.getProjectManagement = getProjectManagement;
		var error_1 = error;
		Object.defineProperty(exports, "FirebaseProjectManagementError", { enumerable: true, get: function () { return error_1.FirebaseProjectManagementError; } }); 
	} (projectManagement));
	return projectManagement;
}

var securityRules = {};

/*! firebase-admin v12.7.0 */

var hasRequiredSecurityRules;

function requireSecurityRules () {
	if (hasRequiredSecurityRules) return securityRules;
	hasRequiredSecurityRules = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getSecurityRules = exports.SecurityRules = exports.RulesetMetadataList = exports.Ruleset = void 0;
		/**
		 * Security Rules for Cloud Firestore and Cloud Storage.
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const security_rules_1 = /*@__PURE__*/ requireSecurityRules$1();
		var security_rules_2 = /*@__PURE__*/ requireSecurityRules$1();
		Object.defineProperty(exports, "Ruleset", { enumerable: true, get: function () { return security_rules_2.Ruleset; } });
		Object.defineProperty(exports, "RulesetMetadataList", { enumerable: true, get: function () { return security_rules_2.RulesetMetadataList; } });
		Object.defineProperty(exports, "SecurityRules", { enumerable: true, get: function () { return security_rules_2.SecurityRules; } });
		/**
		 * Gets the {@link SecurityRules} service for the default app or a given app.
		 *
		 * `admin.securityRules()` can be called with no arguments to access the
		 * default app's `SecurityRules` service, or as `admin.securityRules(app)` to access
		 * the `SecurityRules` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the SecurityRules service for the default app
		 * const defaultSecurityRules = getSecurityRules();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the SecurityRules service for a given app
		 * const otherSecurityRules = getSecurityRules(otherApp);
		 * ```
		 *
		 * @param app - Optional app to return the `SecurityRules` service
		 *     for. If not provided, the default `SecurityRules` service
		 *     is returned.
		 * @returns The default `SecurityRules` service if no app is provided, or the
		 *   `SecurityRules` service associated with the provided app.
		 */
		function getSecurityRules(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('securityRules', (app) => new security_rules_1.SecurityRules(app));
		}
		exports.getSecurityRules = getSecurityRules; 
	} (securityRules));
	return securityRules;
}

var remoteConfig = {};

/*! firebase-admin v12.7.0 */

var hasRequiredRemoteConfig;

function requireRemoteConfig () {
	if (hasRequiredRemoteConfig) return remoteConfig;
	hasRequiredRemoteConfig = 1;
	(function (exports) {
		/*!
		 * Copyright 2020 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *   http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getRemoteConfig = exports.RemoteConfig = exports.PercentConditionOperator = exports.CustomSignalOperator = void 0;
		/**
		 * Firebase Remote Config.
		 *
		 * @packageDocumentation
		 */
		const app_1 = /*@__PURE__*/ requireApp();
		const remote_config_1 = /*@__PURE__*/ requireRemoteConfig$1();
		var remote_config_api_1 = /*@__PURE__*/ requireRemoteConfigApi();
		Object.defineProperty(exports, "CustomSignalOperator", { enumerable: true, get: function () { return remote_config_api_1.CustomSignalOperator; } });
		Object.defineProperty(exports, "PercentConditionOperator", { enumerable: true, get: function () { return remote_config_api_1.PercentConditionOperator; } });
		var remote_config_2 = /*@__PURE__*/ requireRemoteConfig$1();
		Object.defineProperty(exports, "RemoteConfig", { enumerable: true, get: function () { return remote_config_2.RemoteConfig; } });
		/**
		 * Gets the {@link RemoteConfig} service for the default app or a given app.
		 *
		 * `getRemoteConfig()` can be called with no arguments to access the default
		 * app's `RemoteConfig` service or as `getRemoteConfig(app)` to access the
		 * `RemoteConfig` service associated with a specific app.
		 *
		 * @example
		 * ```javascript
		 * // Get the `RemoteConfig` service for the default app
		 * const defaultRemoteConfig = getRemoteConfig();
		 * ```
		 *
		 * @example
		 * ```javascript
		 * // Get the `RemoteConfig` service for a given app
		 * const otherRemoteConfig = getRemoteConfig(otherApp);
		 * ```
		 *
		 * @param app - Optional app for which to return the `RemoteConfig` service.
		 *   If not provided, the default `RemoteConfig` service is returned.
		 *
		 * @returns The default `RemoteConfig` service if no
		 *   app is provided, or the `RemoteConfig` service associated with the provided
		 *   app.
		 */
		function getRemoteConfig(app) {
		    if (typeof app === 'undefined') {
		        app = (0, app_1.getApp)();
		    }
		    const firebaseApp = app;
		    return firebaseApp.getOrInitService('remoteConfig', (app) => new remote_config_1.RemoteConfig(app));
		}
		exports.getRemoteConfig = getRemoteConfig; 
	} (remoteConfig));
	return remoteConfig;
}

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(firebaseNamespace, "__esModule", { value: true });
firebaseNamespace.defaultNamespace = firebaseNamespace.FirebaseNamespace = firebaseNamespace.FirebaseNamespaceInternals = void 0;
const lifecycle_1 = lifecycle;
const credential_factory_1 = credentialFactory;
const index_1 = utils$1;
/**
 * Internals of a FirebaseNamespace instance.
 */
class FirebaseNamespaceInternals {
    constructor(appStore) {
        this.appStore = appStore;
    }
    /**
     * Initializes the App instance.
     *
     * @param options - Optional options for the App instance. If none present will try to initialize
     *   from the FIREBASE_CONFIG environment variable. If the environment variable contains a string
     *   that starts with '{' it will be parsed as JSON, otherwise it will be assumed to be pointing
     *   to a file.
     * @param appName - Optional name of the FirebaseApp instance.
     *
     * @returns A new App instance.
     */
    initializeApp(options, appName) {
        const app = this.appStore.initializeApp(options, appName);
        return extendApp(app);
    }
    /**
     * Returns the App instance with the provided name (or the default App instance
     * if no name is provided).
     *
     * @param appName - Optional name of the FirebaseApp instance to return.
     * @returns The App instance which has the provided name.
     */
    app(appName) {
        const app = this.appStore.getApp(appName);
        return extendApp(app);
    }
    /*
     * Returns an array of all the non-deleted App instances.
     */
    get apps() {
        return this.appStore.getApps().map((app) => extendApp(app));
    }
}
firebaseNamespace.FirebaseNamespaceInternals = FirebaseNamespaceInternals;
const firebaseCredential = {
    cert: credential_factory_1.cert, refreshToken: credential_factory_1.refreshToken, applicationDefault: credential_factory_1.applicationDefault
};
/**
 * Global Firebase context object.
 */
class FirebaseNamespace {
    /* tslint:enable */
    constructor(appStore) {
        // Hack to prevent Babel from modifying the object returned as the default admin namespace.
        /* tslint:disable:variable-name */
        this.__esModule = true;
        /* tslint:enable:variable-name */
        this.credential = firebaseCredential;
        this.SDK_VERSION = (0, index_1.getSdkVersion)();
        /* tslint:disable */
        // TODO(jwenger): Database is the only consumer of firebase.Promise. We should update it to use
        // use the native Promise and then remove this.
        this.Promise = Promise;
        this.INTERNAL = new FirebaseNamespaceInternals(appStore ?? new lifecycle_1.AppStore());
    }
    /**
     * Gets the `Auth` service namespace. The returned namespace can be used to get the
     * `Auth` service for the default app or an explicitly specified app.
     */
    get auth() {
        const fn = (app) => {
            return this.ensureApp(app).auth();
        };
        const auth = /*@__PURE__*/ requireAuth$1().Auth;
        return Object.assign(fn, { Auth: auth });
    }
    /**
     * Gets the `Database` service namespace. The returned namespace can be used to get the
     * `Database` service for the default app or an explicitly specified app.
     */
    get database() {
        const fn = (app) => {
            return this.ensureApp(app).database();
        };
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        return Object.assign(fn, require$$4);
    }
    /**
     * Gets the `Messaging` service namespace. The returned namespace can be used to get the
     * `Messaging` service for the default app or an explicitly specified app.
     */
    get messaging() {
        const fn = (app) => {
            return this.ensureApp(app).messaging();
        };
        const messaging = /*@__PURE__*/ requireMessaging$1().Messaging;
        return Object.assign(fn, { Messaging: messaging });
    }
    /**
     * Gets the `Storage` service namespace. The returned namespace can be used to get the
     * `Storage` service for the default app or an explicitly specified app.
     */
    get storage() {
        const fn = (app) => {
            return this.ensureApp(app).storage();
        };
        const storage = /*@__PURE__*/ requireStorage$1().Storage;
        return Object.assign(fn, { Storage: storage });
    }
    /**
     * Gets the `Firestore` service namespace. The returned namespace can be used to get the
     * `Firestore` service for the default app or an explicitly specified app.
     */
    get firestore() {
        let fn = (app) => {
            return this.ensureApp(app).firestore();
        };
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const firestore = require$$7;
        fn = Object.assign(fn, firestore.Firestore);
        // `v1beta1` and `v1` are lazy-loaded in the Firestore SDK. We use the same trick here
        // to avoid triggering this lazy-loading upon initialization.
        Object.defineProperty(fn, 'v1beta1', {
            get: () => {
                return firestore.v1beta1;
            },
        });
        Object.defineProperty(fn, 'v1', {
            get: () => {
                return firestore.v1;
            },
        });
        return fn;
    }
    /**
     * Gets the `MachineLearning` service namespace. The returned namespace can be
     * used to get the `MachineLearning` service for the default app or an
     * explicityly specified app.
     */
    get machineLearning() {
        const fn = (app) => {
            return this.ensureApp(app).machineLearning();
        };
        const machineLearning = /*@__PURE__*/ requireMachineLearning$1().MachineLearning;
        return Object.assign(fn, { MachineLearning: machineLearning });
    }
    /**
     * Gets the `Installations` service namespace. The returned namespace can be used to get the
     * `Installations` service for the default app or an explicitly specified app.
     */
    get installations() {
        const fn = (app) => {
            return this.ensureApp(app).installations();
        };
        const installations = /*@__PURE__*/ requireInstallations$1().Installations;
        return Object.assign(fn, { Installations: installations });
    }
    /**
     * Gets the `InstanceId` service namespace. The returned namespace can be used to get the
     * `Instance` service for the default app or an explicitly specified app.
     */
    get instanceId() {
        const fn = (app) => {
            return this.ensureApp(app).instanceId();
        };
        const instanceId = /*@__PURE__*/ requireInstanceId$1().InstanceId;
        return Object.assign(fn, { InstanceId: instanceId });
    }
    /**
     * Gets the `ProjectManagement` service namespace. The returned namespace can be used to get the
     * `ProjectManagement` service for the default app or an explicitly specified app.
     */
    get projectManagement() {
        const fn = (app) => {
            return this.ensureApp(app).projectManagement();
        };
        const projectManagement = /*@__PURE__*/ requireProjectManagement$1().ProjectManagement;
        return Object.assign(fn, { ProjectManagement: projectManagement });
    }
    /**
     * Gets the `SecurityRules` service namespace. The returned namespace can be used to get the
     * `SecurityRules` service for the default app or an explicitly specified app.
     */
    get securityRules() {
        const fn = (app) => {
            return this.ensureApp(app).securityRules();
        };
        const securityRules = /*@__PURE__*/ requireSecurityRules$1().SecurityRules;
        return Object.assign(fn, { SecurityRules: securityRules });
    }
    /**
     * Gets the `RemoteConfig` service namespace. The returned namespace can be used to get the
     * `RemoteConfig` service for the default app or an explicitly specified app.
     */
    get remoteConfig() {
        const fn = (app) => {
            return this.ensureApp(app).remoteConfig();
        };
        const remoteConfig = /*@__PURE__*/ requireRemoteConfig$1().RemoteConfig;
        return Object.assign(fn, { RemoteConfig: remoteConfig });
    }
    /**
     * Gets the `AppCheck` service namespace. The returned namespace can be used to get the
     * `AppCheck` service for the default app or an explicitly specified app.
     */
    get appCheck() {
        const fn = (app) => {
            return this.ensureApp(app).appCheck();
        };
        const appCheck = /*@__PURE__*/ requireAppCheck$1().AppCheck;
        return Object.assign(fn, { AppCheck: appCheck });
    }
    // TODO: Change the return types to app.App in the following methods.
    /**
     * Initializes the FirebaseApp instance.
     *
     * @param options - Optional options for the FirebaseApp instance.
     *   If none present will try to initialize from the FIREBASE_CONFIG environment variable.
     *   If the environment variable contains a string that starts with '{' it will be parsed as JSON,
     *   otherwise it will be assumed to be pointing to a file.
     * @param appName - Optional name of the FirebaseApp instance.
     *
     * @returns A new FirebaseApp instance.
     */
    initializeApp(options, appName) {
        return this.INTERNAL.initializeApp(options, appName);
    }
    /**
     * Returns the FirebaseApp instance with the provided name (or the default FirebaseApp instance
     * if no name is provided).
     *
     * @param appName - Optional name of the FirebaseApp instance to return.
     * @returns The FirebaseApp instance which has the provided name.
     */
    app(appName) {
        return this.INTERNAL.app(appName);
    }
    /*
     * Returns an array of all the non-deleted FirebaseApp instances.
     */
    get apps() {
        return this.INTERNAL.apps;
    }
    ensureApp(app) {
        if (typeof app === 'undefined') {
            app = this.app();
        }
        return app;
    }
}
firebaseNamespace.FirebaseNamespace = FirebaseNamespace;
/**
 * In order to maintain backward compatibility, we instantiate a default namespace instance in
 * this module, and delegate all app lifecycle operations to it. In a future implementation where
 * the old admin namespace is no longer supported, we should remove this.
 *
 * @internal
 */
firebaseNamespace.defaultNamespace = new FirebaseNamespace(lifecycle_1.defaultAppStore);
function extendApp(app) {
    const result = app;
    if (result.__extended) {
        return result;
    }
    result.auth = () => {
        const fn = /*@__PURE__*/ requireAuth().getAuth;
        return fn(app);
    };
    result.appCheck = () => {
        const fn = /*@__PURE__*/ requireAppCheck().getAppCheck;
        return fn(app);
    };
    result.database = (url) => {
        const fn = /*@__PURE__*/ requireDatabase().getDatabaseWithUrl;
        return fn(url, app);
    };
    result.messaging = () => {
        const fn = /*@__PURE__*/ requireMessaging().getMessaging;
        return fn(app);
    };
    result.storage = () => {
        const fn = /*@__PURE__*/ requireStorage().getStorage;
        return fn(app);
    };
    result.firestore = () => {
        const fn = /*@__PURE__*/ requireFirestore().getFirestore;
        return fn(app);
    };
    result.instanceId = () => {
        const fn = /*@__PURE__*/ requireInstanceId().getInstanceId;
        return fn(app);
    };
    result.installations = () => {
        const fn = /*@__PURE__*/ requireInstallations().getInstallations;
        return fn(app);
    };
    result.machineLearning = () => {
        const fn = /*@__PURE__*/ requireMachineLearning().getMachineLearning;
        return fn(app);
    };
    result.projectManagement = () => {
        const fn = /*@__PURE__*/ requireProjectManagement().getProjectManagement;
        return fn(app);
    };
    result.securityRules = () => {
        const fn = /*@__PURE__*/ requireSecurityRules().getSecurityRules;
        return fn(app);
    };
    result.remoteConfig = () => {
        const fn = /*@__PURE__*/ requireRemoteConfig().getRemoteConfig;
        return fn(app);
    };
    result.__extended = true;
    return result;
}

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const firebase_namespace_1 = firebaseNamespace;
// Inject a circular default export to allow users to use both:
//
//   import firebaseAdmin from 'firebase-admin';
//   which becomes: var firebaseAdmin = require('firebase-admin').default;
//
// as well as the more correct:
//
//   import * as firebaseAdmin from 'firebase-admin';
//   which becomes: var firebaseAdmin = require('firebase-admin');
firebase_namespace_1.defaultNamespace.default = firebase_namespace_1.defaultNamespace;
var defaultNamespace = firebase_namespace_1.defaultNamespace;

/*! firebase-admin v12.7.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const firebase = defaultNamespace;
// Only Node.js has a process variable that is of [[Class]] process
const processGlobal = typeof process !== 'undefined' ? process : 0;
if (Object.prototype.toString.call(processGlobal) !== '[object process]') {
    const message = `
======== WARNING! ========

firebase-admin appears to have been installed in an unsupported environment.
This package should only be used in server-side or backend Node.js environments,
and should not be used in web browsers or other client-side environments.

Use the Firebase JS SDK for client-side Firebase integrations:

https://firebase.google.com/docs/web/setup
`;
    // tslint:disable-next-line:no-console
    console.error(message);
}
var lib = firebase;

const admin = /*@__PURE__*/getDefaultExportFromCjs(lib);

let initialized$1 = false;
function ensureFirebaseAdmin() {
  if (initialized$1) return admin;
  const config = useRuntimeConfig();
  const projectId = config.fbProjectId;
  const clientEmail = config.fbClientEmail;
  const privateKeyRaw = config.fbPrivateKey;
  const privateKey = (privateKeyRaw || "").replace(/\\n/g, "\n");
  const storageBucket = process.env.FB_STORAGE_BUCKET || (projectId ? `${projectId}.appspot.com` : void 0);
  if (!projectId || !clientEmail || !privateKey) {
    throw createError$1({ statusCode: 500, statusMessage: "Firebase Admin not configured. Set FB_PROJECT_ID, FB_CLIENT_EMAIL, FB_PRIVATE_KEY." });
  }
  if (!admin.apps.length) {
    admin.initializeApp({
      credential: admin.credential.cert({ projectId, clientEmail, privateKey }),
      storageBucket
    });
  }
  initialized$1 = true;
  return admin;
}
function getFirebaseBucket() {
  const adm = ensureFirebaseAdmin();
  const bucketName = process.env.FB_STORAGE_BUCKET || `${useRuntimeConfig().fbProjectId}.appspot.com`;
  return adm.storage().bucket(bucketName);
}

function getFirestore() {
  const admin = ensureFirebaseAdmin();
  return admin.firestore();
}
async function getNextSequence(seqName) {
  const db = getFirestore();
  const ref = db.collection("_counters").doc(seqName);
  const res = await db.runTransaction(async (tx) => {
    var _a;
    const snap = await tx.get(ref);
    const current = (snap.exists ? (_a = snap.data()) == null ? void 0 : _a.value : 0) || 0;
    const next = current + 1;
    tx.set(ref, { value: next }, { merge: true });
    return next;
  });
  return res;
}

const _rg35a4UUAPGZIvOX6SWn_foEEFlVstN6FSSihsgVfLU = defineNitroPlugin(async () => {
  try {
    const enabled = process.env.SEED_OWNER_EMAIL && process.env.SEED_OWNER_PASSWORD;
    if (!enabled) return;
    const db = getFirestore();
    const email = String(process.env.SEED_OWNER_EMAIL);
    const id = email;
    const snap = await db.collection("users").doc(id).get();
    if (snap.exists && String(process.env.SEED_FORCE || "").toLowerCase() !== "true") return;
    const name = process.env.SEED_OWNER_NAME || "Owner";
    const usernameEnv = process.env.SEED_OWNER_USERNAME || email.split("@")[0];
    await db.collection("users").doc(id).set({
      id,
      name,
      email,
      username: usernameEnv,
      accountId: 1,
      role: "OWNER",
      // passwordHash kept for legacy UI forms but not used by auth
      passwordHash: String(process.env.SEED_OWNER_PASSWORD),
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    }, { merge: true });
    console.log("[seed] OWNER user created via Firestore SEED_* envs");
  } catch (err) {
    console.error("[seed] failed:", err);
  }
});

const plugins = [
  _rg35a4UUAPGZIvOX6SWn_foEEFlVstN6FSSihsgVfLU
];

const _SxA8c9 = defineEventHandler(() => {});

const _lazy_Op6xeg = () => Promise.resolve().then(function () { return index$f; });
const _lazy_gFj76I = () => Promise.resolve().then(function () { return index$d; });
const _lazy_MDYzPo = () => Promise.resolve().then(function () { return index_get$5; });
const _lazy__mAuxi = () => Promise.resolve().then(function () { return bootstrapOwner_post$1; });
const _lazy_MddwoC = () => Promise.resolve().then(function () { return bootstrap_post$1; });
const _lazy_26aIrI = () => Promise.resolve().then(function () { return firebase_post$1; });
const _lazy_h_9Ndy = () => Promise.resolve().then(function () { return login_post$1; });
const _lazy_960zbK = () => Promise.resolve().then(function () { return logout_post$1; });
const _lazy_PDAt0_ = () => Promise.resolve().then(function () { return me_get$1; });
const _lazy_B49k3I = () => Promise.resolve().then(function () { return recaptcha_post$1; });
const _lazy_qgcegS = () => Promise.resolve().then(function () { return index$b; });
const _lazy_fSnLOj = () => Promise.resolve().then(function () { return settings$1; });
const _lazy_rhkEh0 = () => Promise.resolve().then(function () { return _projectId_$7; });
const _lazy_u3a_gl = () => Promise.resolve().then(function () { return _id_$1; });
const _lazy_OZHTHY = () => Promise.resolve().then(function () { return index$9; });
const _lazy_PFhbWT = () => Promise.resolve().then(function () { return permissions$1; });
const _lazy_0AGppj = () => Promise.resolve().then(function () { return _peerId_$1; });
const _lazy_Ty5Cpc = () => Promise.resolve().then(function () { return _projectId_$5; });
const _lazy_hWfLMz = () => Promise.resolve().then(function () { return transfer_post$1; });
const _lazy_iptHfj = () => Promise.resolve().then(function () { return _slug__get$1; });
const _lazy_Lyjpew = () => Promise.resolve().then(function () { return index_get$3; });
const _lazy_pMz5Ws = () => Promise.resolve().then(function () { return index_post$3; });
const _lazy_mSTVLK = () => Promise.resolve().then(function () { return _projectId_$3; });
const _lazy_mpIBKd = () => Promise.resolve().then(function () { return index$7; });
const _lazy_0nCpQS = () => Promise.resolve().then(function () { return index$5; });
const _lazy_mYzZIA = () => Promise.resolve().then(function () { return index$3; });
const _lazy_NxvqCO = () => Promise.resolve().then(function () { return index$1; });
const _lazy_3RdRSB = () => Promise.resolve().then(function () { return _projectId_$1; });
const _lazy_sO2JFq = () => Promise.resolve().then(function () { return index_get$1; });
const _lazy_F0bBaM = () => Promise.resolve().then(function () { return index_post$1; });
const _lazy_sn6zPv = () => Promise.resolve().then(function () { return index_put$1; });
const _lazy_eXjnyM = () => Promise.resolve().then(function () { return password_post$1; });
const _lazy_J9381O = () => Promise.resolve().then(function () { return renderer$1; });

const handlers = [
  { route: '/api/activity-log', handler: _lazy_Op6xeg, lazy: true, middleware: false, method: undefined },
  { route: '/api/assignments', handler: _lazy_gFj76I, lazy: true, middleware: false, method: undefined },
  { route: '/api/audit-logs', handler: _lazy_MDYzPo, lazy: true, middleware: false, method: "get" },
  { route: '/api/auth/bootstrap-owner', handler: _lazy__mAuxi, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/bootstrap', handler: _lazy_MddwoC, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/firebase', handler: _lazy_26aIrI, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/login', handler: _lazy_h_9Ndy, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/logout', handler: _lazy_960zbK, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/me', handler: _lazy_PDAt0_, lazy: true, middleware: false, method: "get" },
  { route: '/api/auth/recaptcha', handler: _lazy_B49k3I, lazy: true, middleware: false, method: "post" },
  { route: '/api/banner', handler: _lazy_qgcegS, lazy: true, middleware: false, method: undefined },
  { route: '/api/banner/settings', handler: _lazy_fSnLOj, lazy: true, middleware: false, method: undefined },
  { route: '/api/files/:projectId', handler: _lazy_rhkEh0, lazy: true, middleware: false, method: undefined },
  { route: '/api/home-pages/:id', handler: _lazy_u3a_gl, lazy: true, middleware: false, method: undefined },
  { route: '/api/home-pages', handler: _lazy_OZHTHY, lazy: true, middleware: false, method: undefined },
  { route: '/api/home-pages/permissions', handler: _lazy_PFhbWT, lazy: true, middleware: false, method: undefined },
  { route: '/api/im/:peerId', handler: _lazy_0AGppj, lazy: true, middleware: false, method: undefined },
  { route: '/api/messages/:projectId', handler: _lazy_Ty5Cpc, lazy: true, middleware: false, method: undefined },
  { route: '/api/owner/transfer', handler: _lazy_hWfLMz, lazy: true, middleware: false, method: "post" },
  { route: '/api/projects/:slug', handler: _lazy_iptHfj, lazy: true, middleware: false, method: "get" },
  { route: '/api/projects', handler: _lazy_Lyjpew, lazy: true, middleware: false, method: "get" },
  { route: '/api/projects', handler: _lazy_pMz5Ws, lazy: true, middleware: false, method: "post" },
  { route: '/api/roadmap/:projectId', handler: _lazy_mSTVLK, lazy: true, middleware: false, method: undefined },
  { route: '/api/site-title', handler: _lazy_mpIBKd, lazy: true, middleware: false, method: undefined },
  { route: '/api/time-entries', handler: _lazy_0nCpQS, lazy: true, middleware: false, method: undefined },
  { route: '/api/todo-items', handler: _lazy_mYzZIA, lazy: true, middleware: false, method: undefined },
  { route: '/api/todo-subitems', handler: _lazy_NxvqCO, lazy: true, middleware: false, method: undefined },
  { route: '/api/todos/:projectId', handler: _lazy_3RdRSB, lazy: true, middleware: false, method: undefined },
  { route: '/api/users', handler: _lazy_sO2JFq, lazy: true, middleware: false, method: "get" },
  { route: '/api/users', handler: _lazy_F0bBaM, lazy: true, middleware: false, method: "post" },
  { route: '/api/users', handler: _lazy_sn6zPv, lazy: true, middleware: false, method: "put" },
  { route: '/api/users/password', handler: _lazy_eXjnyM, lazy: true, middleware: false, method: "post" },
  { route: '/__nuxt_error', handler: _lazy_J9381O, lazy: true, middleware: false, method: undefined },
  { route: '/__nuxt_island/**', handler: _SxA8c9, lazy: false, middleware: false, method: undefined },
  { route: '/**', handler: _lazy_J9381O, lazy: true, middleware: false, method: undefined }
];

function createNitroApp() {
  const config = useRuntimeConfig();
  const hooks = createHooks();
  const captureError = (error, context = {}) => {
    const promise = hooks.callHookParallel("error", error, context).catch((error_) => {
      console.error("Error while capturing another error", error_);
    });
    if (context.event && isEvent(context.event)) {
      const errors = context.event.context.nitro?.errors;
      if (errors) {
        errors.push({ error, context });
      }
      if (context.event.waitUntil) {
        context.event.waitUntil(promise);
      }
    }
  };
  const h3App = createApp({
    debug: destr(false),
    onError: (error, event) => {
      captureError(error, { event, tags: ["request"] });
      return errorHandler(error, event);
    },
    onRequest: async (event) => {
      event.context.nitro = event.context.nitro || { errors: [] };
      const fetchContext = event.node.req?.__unenv__;
      if (fetchContext?._platform) {
        event.context = {
          _platform: fetchContext?._platform,
          // #3335
          ...fetchContext._platform,
          ...event.context
        };
      }
      if (!event.context.waitUntil && fetchContext?.waitUntil) {
        event.context.waitUntil = fetchContext.waitUntil;
      }
      event.fetch = (req, init) => fetchWithEvent(event, req, init, { fetch: localFetch });
      event.$fetch = (req, init) => fetchWithEvent(event, req, init, {
        fetch: $fetch
      });
      event.waitUntil = (promise) => {
        if (!event.context.nitro._waitUntilPromises) {
          event.context.nitro._waitUntilPromises = [];
        }
        event.context.nitro._waitUntilPromises.push(promise);
        if (event.context.waitUntil) {
          event.context.waitUntil(promise);
        }
      };
      event.captureError = (error, context) => {
        captureError(error, { event, ...context });
      };
      await nitroApp$1.hooks.callHook("request", event).catch((error) => {
        captureError(error, { event, tags: ["request"] });
      });
    },
    onBeforeResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("beforeResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    },
    onAfterResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("afterResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    }
  });
  const router = createRouter({
    preemptive: true
  });
  const nodeHandler = toNodeListener(h3App);
  const localCall = (aRequest) => b(
    nodeHandler,
    aRequest
  );
  const localFetch = (input, init) => {
    if (!input.toString().startsWith("/")) {
      return globalThis.fetch(input, init);
    }
    return C(
      nodeHandler,
      input,
      init
    ).then((response) => normalizeFetchResponse(response));
  };
  const $fetch = createFetch({
    fetch: localFetch,
    Headers: Headers$1,
    defaults: { baseURL: config.app.baseURL }
  });
  globalThis.$fetch = $fetch;
  h3App.use(createRouteRulesHandler({ localFetch }));
  for (const h of handlers) {
    let handler = h.lazy ? lazyEventHandler(h.handler) : h.handler;
    if (h.middleware || !h.route) {
      const middlewareBase = (config.app.baseURL + (h.route || "/")).replace(
        /\/+/g,
        "/"
      );
      h3App.use(middlewareBase, handler);
    } else {
      const routeRules = getRouteRulesForPath(
        h.route.replace(/:\w+|\*\*/g, "_")
      );
      if (routeRules.cache) {
        handler = cachedEventHandler(handler, {
          group: "nitro/routes",
          ...routeRules.cache
        });
      }
      router.use(h.route, handler, h.method);
    }
  }
  h3App.use(config.app.baseURL, router.handler);
  const app = {
    hooks,
    h3App,
    router,
    localCall,
    localFetch,
    captureError
  };
  return app;
}
function runNitroPlugins(nitroApp2) {
  for (const plugin of plugins) {
    try {
      plugin(nitroApp2);
    } catch (error) {
      nitroApp2.captureError(error, { tags: ["plugin"] });
      throw error;
    }
  }
}
const nitroApp$1 = createNitroApp();
function useNitroApp() {
  return nitroApp$1;
}
runNitroPlugins(nitroApp$1);

function defineRenderHandler(render) {
  const runtimeConfig = useRuntimeConfig();
  return eventHandler(async (event) => {
    const nitroApp = useNitroApp();
    const ctx = { event, render, response: void 0 };
    await nitroApp.hooks.callHook("render:before", ctx);
    if (!ctx.response) {
      if (event.path === `${runtimeConfig.app.baseURL}favicon.ico`) {
        setResponseHeader(event, "Content-Type", "image/x-icon");
        return send(
          event,
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
        );
      }
      ctx.response = await ctx.render(event);
      if (!ctx.response) {
        const _currentStatus = getResponseStatus(event);
        setResponseStatus(event, _currentStatus === 200 ? 500 : _currentStatus);
        return send(
          event,
          "No response returned from render handler: " + event.path
        );
      }
    }
    await nitroApp.hooks.callHook("render:response", ctx.response, ctx);
    if (ctx.response.headers) {
      setResponseHeaders(event, ctx.response.headers);
    }
    if (ctx.response.statusCode || ctx.response.statusMessage) {
      setResponseStatus(
        event,
        ctx.response.statusCode,
        ctx.response.statusMessage
      );
    }
    return ctx.response.body;
  });
}

const nitroApp = useNitroApp();
const handler = toNodeListener(nitroApp.h3App);
const listener = function(req, res) {
  const query = req.headers["x-now-route-matches"];
  if (query) {
    const { url } = parseQuery(query);
    if (url) {
      req.url = url;
    }
  }
  return handler(req, res);
};

var shared_cjs_prod = {};

/**
* @vue/shared v3.5.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

Object.defineProperty(shared_cjs_prod, '__esModule', { value: true });

// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  });
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `CACHED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

function normalizeCssVarValue(value) {
  if (value == null) {
    return "initial";
  }
  if (typeof value === "string") {
    return value === "" ? " " : value;
  }
  return String(value);
}

shared_cjs_prod.EMPTY_ARR = EMPTY_ARR;
shared_cjs_prod.EMPTY_OBJ = EMPTY_OBJ;
shared_cjs_prod.NO = NO;
shared_cjs_prod.NOOP = NOOP;
shared_cjs_prod.PatchFlagNames = PatchFlagNames;
shared_cjs_prod.PatchFlags = PatchFlags;
shared_cjs_prod.ShapeFlags = ShapeFlags;
shared_cjs_prod.SlotFlags = SlotFlags;
shared_cjs_prod.camelize = camelize;
shared_cjs_prod.capitalize = capitalize;
shared_cjs_prod.cssVarNameEscapeSymbolsRE = cssVarNameEscapeSymbolsRE;
shared_cjs_prod.def = def;
var escapeHtml_1 = shared_cjs_prod.escapeHtml = escapeHtml;
shared_cjs_prod.escapeHtmlComment = escapeHtmlComment;
shared_cjs_prod.extend = extend;
shared_cjs_prod.genCacheKey = genCacheKey;
shared_cjs_prod.genPropsAccessExp = genPropsAccessExp;
shared_cjs_prod.generateCodeFrame = generateCodeFrame;
shared_cjs_prod.getEscapedCssVarName = getEscapedCssVarName;
shared_cjs_prod.getGlobalThis = getGlobalThis;
shared_cjs_prod.hasChanged = hasChanged;
shared_cjs_prod.hasOwn = hasOwn;
shared_cjs_prod.hyphenate = hyphenate;
shared_cjs_prod.includeBooleanAttr = includeBooleanAttr;
shared_cjs_prod.invokeArrayFns = invokeArrayFns;
shared_cjs_prod.isArray = isArray;
shared_cjs_prod.isBooleanAttr = isBooleanAttr;
shared_cjs_prod.isBuiltInDirective = isBuiltInDirective;
shared_cjs_prod.isDate = isDate;
shared_cjs_prod.isFunction = isFunction;
shared_cjs_prod.isGloballyAllowed = isGloballyAllowed;
shared_cjs_prod.isGloballyWhitelisted = isGloballyWhitelisted;
shared_cjs_prod.isHTMLTag = isHTMLTag;
shared_cjs_prod.isIntegerKey = isIntegerKey;
shared_cjs_prod.isKnownHtmlAttr = isKnownHtmlAttr;
shared_cjs_prod.isKnownMathMLAttr = isKnownMathMLAttr;
shared_cjs_prod.isKnownSvgAttr = isKnownSvgAttr;
shared_cjs_prod.isMap = isMap;
shared_cjs_prod.isMathMLTag = isMathMLTag;
shared_cjs_prod.isModelListener = isModelListener;
shared_cjs_prod.isObject = isObject;
shared_cjs_prod.isOn = isOn;
shared_cjs_prod.isPlainObject = isPlainObject;
shared_cjs_prod.isPromise = isPromise;
shared_cjs_prod.isRegExp = isRegExp;
shared_cjs_prod.isRenderableAttrValue = isRenderableAttrValue;
shared_cjs_prod.isReservedProp = isReservedProp;
shared_cjs_prod.isSSRSafeAttrName = isSSRSafeAttrName;
shared_cjs_prod.isSVGTag = isSVGTag;
shared_cjs_prod.isSet = isSet;
shared_cjs_prod.isSpecialBooleanAttr = isSpecialBooleanAttr;
shared_cjs_prod.isString = isString;
shared_cjs_prod.isSymbol = isSymbol;
shared_cjs_prod.isVoidTag = isVoidTag;
shared_cjs_prod.looseEqual = looseEqual;
shared_cjs_prod.looseIndexOf = looseIndexOf;
shared_cjs_prod.looseToNumber = looseToNumber;
shared_cjs_prod.makeMap = makeMap;
shared_cjs_prod.normalizeClass = normalizeClass;
shared_cjs_prod.normalizeCssVarValue = normalizeCssVarValue;
shared_cjs_prod.normalizeProps = normalizeProps;
shared_cjs_prod.normalizeStyle = normalizeStyle;
shared_cjs_prod.objectToString = objectToString;
shared_cjs_prod.parseStringStyle = parseStringStyle;
shared_cjs_prod.propsToAttrMap = propsToAttrMap;
shared_cjs_prod.remove = remove;
shared_cjs_prod.slotFlagsText = slotFlagsText;
shared_cjs_prod.stringifyStyle = stringifyStyle;
shared_cjs_prod.toDisplayString = toDisplayString;
shared_cjs_prod.toHandlerKey = toHandlerKey;
shared_cjs_prod.toNumber = toNumber;
shared_cjs_prod.toRawType = toRawType;
shared_cjs_prod.toTypeString = toTypeString;

const _messages = { "appName": "Nuxt", "statusCode": 500, "statusMessage": "Internal server error", "description": "This page is temporarily unavailable.", "refresh": "Refresh this page" };
const template$1 = (messages) => {
  messages = { ..._messages, ...messages };
  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml_1(messages.statusCode) + " - " + escapeHtml_1(messages.statusMessage) + " | " + escapeHtml_1(messages.appName) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.grid{display:grid}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.place-content-center{place-content:center}.overflow-hidden{overflow:hidden}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2{padding-left:.5rem;padding-right:.5rem}.text-center{text-align:center}.text-\\[80px\\]{font-size:80px}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold{font-weight:600}.leading-none{line-height:1}.tracking-wide{letter-spacing:.025em}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media (min-width:640px){.sm\\:text-\\[110px\\]{font-size:110px}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide"><div class="max-w-520px text-center"><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]">` + escapeHtml_1(messages.statusCode) + '</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl">' + escapeHtml_1(messages.statusMessage) + '</h2><p class="mb-4 px-2 text-[#64748B] text-md">' + escapeHtml_1(messages.description) + "</p></div></body></html>";
};

const error500 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template$1
}, Symbol.toStringTag, { value: 'Module' }));

async function getCurrentUser(event) {
  const cookieVal = getCookie(event, "uid");
  const uid = cookieVal ? String(cookieVal) : null;
  if (!uid) return null;
  const db = getFirestore();
  const doc = await db.collection("users").doc(uid).get();
  if (!doc.exists) return null;
  return { id: uid, ...doc.data() };
}
function setUserSession(event, userId) {
  setCookie(event, "uid", String(userId), { httpOnly: true, sameSite: "lax", path: "/" });
  setCookie(event, "uid_js", String(userId), { httpOnly: false, sameSite: "lax", path: "/" });
}
function clearUserSession(event) {
  deleteCookie(event, "uid", { path: "/" });
  deleteCookie(event, "uid_js", { path: "/" });
}

const index$e = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  if (me.role !== "OWNER" && me.role !== "MANAGER") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
  const query = getQuery(event);
  const userId = query.userId ? String(query.userId) : void 0;
  const status = query.status || "all";
  const db = getFirestore();
  let snap = await db.collection("assignments").orderBy("createdAt", "desc").limit(100).get().catch(async () => {
    return await db.collection("assignments").get();
  });
  let items = snap.docs.map((d) => d.data());
  if (status === "completed") items = items.filter((i) => i.completed);
  if (status === "assigned") items = items.filter((i) => !i.completed);
  if (userId) items = items.filter((i) => String(i.assignedToId) === userId);
  return items.map((i) => ({
    id: i.id,
    title: i.title,
    createdAt: i.createdAt,
    completedAt: i.completedAt,
    completed: !!i.completed,
    assignedTo: { id: i.assignedToId, name: i.assignedToId },
    assignedBy: { id: i.assignedById, name: i.assignedById }
  }));
});

const index$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$e
}, Symbol.toStringTag, { value: 'Module' }));

const index$c = defineEventHandler(async (event) => {
  var _a;
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const method = getMethod(event);
  const db = getFirestore();
  if (method === "GET") {
    const query = getQuery(event);
    const view = query.view || "me";
    const userId = query.userId ? String(query.userId) : void 0;
    const isMgr = me.role === "OWNER" || me.role === "MANAGER" || me.role === "ADMIN_MANAGER" || me.role === "ADMIN";
    if ((view === "all" || view === "byUser" || view === "authored") && !isMgr) {
      throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    }
    let snap;
    if (view === "me") {
      snap = await db.collection("assignments").where("assignedToId", "==", String(me.id)).get();
    } else if (view === "byUser" && userId) {
      snap = await db.collection("assignments").where("assignedToId", "==", userId).get();
    } else if (view === "authored") {
      snap = await db.collection("assignments").where("assignedById", "==", String(me.id)).get();
    } else {
      snap = await db.collection("assignments").get();
    }
    const list = snap.docs.map((d) => d.data()).sort((a, b) => String(b.createdAt || "").localeCompare(String(a.createdAt || "")));
    return list;
  }
  if (method === "POST") {
    const isMgr = me.role === "OWNER" || me.role === "MANAGER" || me.role === "ADMIN_MANAGER" || me.role === "ADMIN";
    if (!isMgr) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.title) || !(body == null ? void 0 : body.assignedToId)) throw createError$1({ statusCode: 400, statusMessage: "title and assignedToId required" });
    const id = await getNextSequence("assignments");
    const doc = {
      id,
      title: body.title,
      details: (_a = body.details) != null ? _a : null,
      assignedToId: String(body.assignedToId),
      assignedById: String(me.id),
      completed: false,
      dueDate: body.dueDate ? new Date(body.dueDate).toISOString() : null,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await db.collection("assignments").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id required" });
    const ref = db.collection("assignments").doc(String(body.id));
    const snap = await ref.get();
    if (!snap.exists) throw createError$1({ statusCode: 404, statusMessage: "Not found" });
    const a = snap.data();
    const canComplete = String(me.id) === String(a.assignedToId) || me.role === "OWNER" || me.role === "MANAGER" || me.role === "ADMIN";
    if (!canComplete) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const completed = body.completed === true;
    await ref.set({ ...a, completed, completedAt: completed ? (/* @__PURE__ */ new Date()).toISOString() : null }, { merge: true });
    return (await ref.get()).data();
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$c
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$4 = defineEventHandler(async (event) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  if (me.role !== "OWNER" && me.role !== "ADMIN") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
  const q = getQuery(event);
  const action = typeof q.action === "string" ? q.action : void 0;
  const startStr = typeof q.start === "string" ? q.start : void 0;
  const endStr = typeof q.end === "string" ? q.end : void 0;
  const start = startStr ? /* @__PURE__ */ new Date(startStr + "T00:00:00.000Z") : void 0;
  const end = endStr ? /* @__PURE__ */ new Date(endStr + "T23:59:59.999Z") : void 0;
  const where = {};
  if (action) where.action = action;
  if (start || end) where.createdAt = { gte: start, lte: end };
  const db = getFirestore();
  const snap = await db.collection("auditLogs").orderBy("createdAt", "desc").limit(200).get().catch(async () => {
    return await db.collection("auditLogs").limit(200).get();
  });
  let logs = snap.docs.map((d) => d.data());
  if (where.action) logs = logs.filter((l) => l.action === where.action);
  if ((_a = where.createdAt) == null ? void 0 : _a.gte) logs = logs.filter((l) => new Date(l.createdAt) >= where.createdAt.gte);
  if ((_b = where.createdAt) == null ? void 0 : _b.lte) logs = logs.filter((l) => new Date(l.createdAt) <= where.createdAt.lte);
  if (q.format === "csv") {
    const escape = (v) => {
      if (v === null || v === void 0) return "";
      const s = String(v);
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    };
    const rows = [["createdAt", "action", "actorId", "actorName", "targetId", "targetName", "details"]];
    for (const l of logs) {
      rows.push([
        l.createdAt.toISOString(),
        l.action,
        l.actorUserId,
        (_d = (_c = l.actor) == null ? void 0 : _c.name) != null ? _d : "",
        (_e = l.targetUserId) != null ? _e : "",
        (_g = (_f = l.target) == null ? void 0 : _f.name) != null ? _g : "",
        JSON.stringify(l.details)
      ].map(escape));
    }
    const csv = rows.map((r) => r.join(",")).join("\n");
    setHeader(event, "Content-Type", "text/csv; charset=utf-8");
    setHeader(event, "Content-Disposition", 'attachment; filename="audit-logs.csv"');
    return csv;
  }
  return logs;
});

const index_get$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$4
}, Symbol.toStringTag, { value: 'Module' }));

const bootstrapOwner_post = defineEventHandler(async () => {
  throw createError$1({ statusCode: 400, statusMessage: "Bootstrap disabled. Use Firebase sign-in." });
});

const bootstrapOwner_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: bootstrapOwner_post
}, Symbol.toStringTag, { value: 'Module' }));

const bootstrap_post = defineEventHandler(async () => {
  throw createError$1({ statusCode: 400, statusMessage: "Bootstrap disabled. Use Firebase sign-in." });
});

const bootstrap_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: bootstrap_post
}, Symbol.toStringTag, { value: 'Module' }));

let initialized = false;
function ensureAdmin() {
  if (initialized) return;
  const config = useRuntimeConfig();
  const projectId = config.fbProjectId;
  const clientEmail = config.fbClientEmail;
  const privateKeyRaw = config.fbPrivateKey;
  const privateKey = (privateKeyRaw || "").replace(/\\n/g, "\n");
  if (!projectId || !clientEmail || !privateKey) {
    console.error("[Auth] Missing Firebase Admin env. Ensure FB_PROJECT_ID, FB_CLIENT_EMAIL, FB_PRIVATE_KEY are set.");
    throw createError$1({ statusCode: 500, statusMessage: "Server auth not configured. Missing Firebase Admin credentials." });
  }
  if (!admin.apps.length) {
    try {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId,
          clientEmail,
          privateKey
        })
      });
    } catch (e) {
      const detail = (e == null ? void 0 : e.message) || String(e);
      console.error("[Auth] Failed to initialize Firebase Admin SDK:", detail);
      const statusMessage = "Failed to initialize Firebase Admin SDK";
      throw createError$1({ statusCode: 500, statusMessage });
    }
  }
  initialized = true;
}
const firebase_post = defineEventHandler(async (event) => {
  ensureAdmin();
  const body = await readBody(event);
  if (!(body == null ? void 0 : body.idToken)) throw createError$1({ statusCode: 400, statusMessage: "idToken required" });
  let decoded;
  try {
    decoded = await admin.auth().verifyIdToken(body.idToken);
  } catch (e) {
    console.error("[Auth] verifyIdToken failed:", (e == null ? void 0 : e.message) || e);
    throw createError$1({ statusCode: 401, statusMessage: "Invalid or expired Google ID token" });
  }
  const email = decoded.email;
  if (!email) throw createError$1({ statusCode: 400, statusMessage: "Email required" });
  const db = getFirestore();
  const existing = await db.collection("users").where("email", "==", email).limit(1).get();
  let uid;
  let name = decoded.name || email.split("@")[0];
  let role = "USER";
  if (existing.empty) {
    const totalSnap = await db.collection("users").limit(1).get();
    role = totalSnap.empty ? "OWNER" : "USER";
    uid = decoded.uid || email;
    await db.collection("users").doc(uid).set({ id: uid, email, name, role, accountId: 1, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
  } else {
    const doc = existing.docs[0];
    uid = doc.id;
    const data = doc.data();
    name = data.name || name;
    role = data.role || role;
  }
  setUserSession(event, uid);
  return { ok: true, user: { id: uid, name, role } };
});

const firebase_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: firebase_post
}, Symbol.toStringTag, { value: 'Module' }));

const login_post = defineEventHandler(async (event) => {
  throw createError$1({ statusCode: 400, statusMessage: "Password login disabled. Use Google sign-in." });
});

const login_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: login_post
}, Symbol.toStringTag, { value: 'Module' }));

const logout_post = defineEventHandler(async (event) => {
  clearUserSession(event);
  return { ok: true };
});

const logout_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: logout_post
}, Symbol.toStringTag, { value: 'Module' }));

const me_get = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  return { id: me.id, name: me.name, email: me.email, role: me.role };
});

const me_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: me_get
}, Symbol.toStringTag, { value: 'Module' }));

const recaptcha_post = defineEventHandler(() => {
  return { success: false, disabled: true };
});

const recaptcha_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: recaptcha_post
}, Symbol.toStringTag, { value: 'Module' }));

const PUBLIC_DIR = path$3.join(process.cwd(), "public");
const BASENAME = "banner";
const ALLOWED_EXTS = [".jpg", ".jpeg", ".png", ".gif", ".webp"];
async function findExistingBanner() {
  for (const ext of ALLOWED_EXTS) {
    const p = path$3.join(PUBLIC_DIR, `${BASENAME}${ext}`);
    try {
      const stat = await promises.stat(p);
      return { path: p, url: `/${BASENAME}${ext}?v=${encodeURIComponent(stat.mtimeMs.toString())}` };
    } catch {
    }
  }
  return null;
}
const index$a = defineEventHandler(async (event) => {
  var _a;
  const method = getMethod(event);
  if (method === "GET") {
    try {
      const db = getFirestore();
      const snap = await db.collection("settings").doc("site").get();
      const url = (snap.exists ? (_a = snap.data()) == null ? void 0 : _a.bannerUrl : void 0) || null;
      if (url) return { url };
    } catch {
    }
    const found = await findExistingBanner();
    return { url: found ? found.url : null };
  }
  if (method === "POST") {
    const me = await getCurrentUser(event);
    if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
    if (me.role !== "ADMIN" && me.role !== "OWNER") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const form = await readMultipartFormData(event);
    const file = form == null ? void 0 : form.find((f) => f && f.filename && f.data);
    if (!file || !file.filename || !file.data) throw createError$1({ statusCode: 400, statusMessage: "No file uploaded" });
    const incomingExt = path$3.extname(file.filename || "").toLowerCase();
    const ext = ALLOWED_EXTS.includes(incomingExt) ? incomingExt : file.type && file.type.includes("png") ? ".png" : file.type && file.type.includes("webp") ? ".webp" : ".jpg";
    let publicUrl = null;
    const storageMode = (process.env.FILES_STORAGE || "").toLowerCase();
    const isVercel = Boolean(process.env.VERCEL);
    try {
      if (storageMode === "firebase") {
        const bucket = getFirebaseBucket();
        const pathname = `banner/${BASENAME}${ext}`;
        const fileRef = bucket.file(pathname);
        await fileRef.save(file.data, { contentType: file.type || void 0, resumable: false, public: true });
        publicUrl = `https://storage.googleapis.com/${bucket.name}/${pathname}`;
      } else if (isVercel) {
        const token = process.env.BLOB_READ_WRITE_TOKEN;
        if (!token) throw new Error("Missing BLOB_READ_WRITE_TOKEN");
        const pathname = `banner/${BASENAME}${ext}`;
        const uploaded = await put(pathname, file.data, { access: "public", addRandomSuffix: false, token });
        publicUrl = uploaded.url;
      } else {
        for (const e of ALLOWED_EXTS) {
          const p = path$3.join(PUBLIC_DIR, `${BASENAME}${e}`);
          try {
            await promises.unlink(p);
          } catch {
          }
        }
        const dest = path$3.join(PUBLIC_DIR, `${BASENAME}${ext}`);
        await promises.writeFile(dest, file.data);
        const stat = await promises.stat(dest);
        publicUrl = `/${BASENAME}${ext}?v=${encodeURIComponent(stat.mtimeMs.toString())}`;
      }
    } catch (e) {
      throw createError$1({ statusCode: 500, statusMessage: "Failed to save banner. Configure storage (Firebase or Vercel Blob)." });
    }
    try {
      const db = getFirestore();
      await db.collection("settings").doc("site").set({ bannerUrl: publicUrl }, { merge: true });
    } catch {
    }
    return { ok: true, url: publicUrl };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$a
}, Symbol.toStringTag, { value: 'Module' }));

const settings = defineEventHandler(() => {
  throw createError$1({ statusCode: 404, statusMessage: "Not Found" });
});

const settings$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: settings
}, Symbol.toStringTag, { value: 'Module' }));

const UPLOADS_ROOT = path$3.join(process.cwd(), "public", "uploads", "projects");
async function ensureDir(dir) {
  try {
    await promises.mkdir(dir, { recursive: true });
  } catch {
  }
}
function sanitizeFilename(name) {
  const base = path$3.basename(name);
  return base.replace(/[^a-zA-Z0-9._-]/g, "_");
}
const _projectId_$6 = defineEventHandler(async (event) => {
  const { projectId } = getRouterParams(event);
  const projectIdNum = Number(projectId);
  if (!projectId || Number.isNaN(projectIdNum)) {
    throw createError$1({ statusCode: 400, statusMessage: "projectId must be a number" });
  }
  const method = getMethod(event);
  if (method === "GET") {
    const me = await getCurrentUser(event);
    const scope = String(getQuery(event).scope || "shared");
    const db = getFirestore();
    let q = db.collection("files").where("projectId", "==", projectIdNum);
    if (scope === "private") {
      if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
      q = q.where("ownerUserId", "==", String(me.id));
    } else {
      q = q.where("ownerUserId", "==", null);
    }
    const snap = await q.orderBy("createdAt", "desc").get();
    return snap.docs.map((d) => d.data());
  }
  if (method === "POST") {
    const me = await getCurrentUser(event);
    if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
    const query = getQuery(event);
    const scope = String(query.scope || "shared");
    const form = await readMultipartFormData(event);
    const file = form == null ? void 0 : form.find((f) => f && f.filename && f.data);
    if (!file || !file.filename || !file.data) throw createError$1({ statusCode: 400, statusMessage: "No file uploaded" });
    const safe = sanitizeFilename(file.filename);
    const storageMode = (process.env.FILES_STORAGE || "").toLowerCase();
    const isVercel = Boolean(process.env.VERCEL);
    const blobToken = process.env.BLOB_READ_WRITE_TOKEN;
    let publicPath = "";
    if (storageMode === "firebase") {
      const bucket = getFirebaseBucket();
      const pathname = `projects/${projectIdNum}/${Date.now()}-${safe}`;
      const fileRef = bucket.file(pathname);
      await fileRef.save(file.data, { contentType: file.type || void 0, resumable: false, public: true });
      publicPath = `https://storage.googleapis.com/${bucket.name}/${pathname}`;
    } else if (isVercel) {
      if (!blobToken) {
        throw createError$1({ statusCode: 500, statusMessage: "Blob storage not configured. Create a Vercel Blob store." });
      }
      const pathname = `projects/${projectIdNum}/${Date.now()}-${safe}`;
      const uploaded = await put(pathname, file.data, { access: "public", addRandomSuffix: false, token: blobToken });
      publicPath = uploaded.url;
    } else {
      const projectDir = path$3.join(UPLOADS_ROOT, String(projectIdNum));
      await ensureDir(projectDir);
      let dest = path$3.join(projectDir, safe);
      try {
        await promises.stat(dest);
        const ext = path$3.extname(safe);
        const nameOnly = path$3.basename(safe, ext);
        const unique = `${nameOnly}-${Date.now()}${ext || ""}`;
        dest = path$3.join(projectDir, unique);
      } catch {
      }
      await promises.writeFile(dest, file.data);
      publicPath = dest.replace(path$3.join(process.cwd(), "public"), "").replace(/\\/g, "/");
    }
    const db = getFirestore();
    const id = await getNextSequence("files");
    const createdAt = (/* @__PURE__ */ new Date()).toISOString();
    const doc = {
      id,
      path: publicPath,
      metadata: { filename: safe, size: file.data.length, type: file.type || null, scope },
      projectId: projectIdNum,
      ownerUserId: scope === "private" ? String(me.id) : null,
      createdAt
    };
    await db.collection("files").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "DELETE") {
    const me = await getCurrentUser(event);
    if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    const existingSnap = await db.collection("files").doc(String(id)).get();
    if (!existingSnap.exists) throw createError$1({ statusCode: 404, statusMessage: "File not found" });
    const existing = existingSnap.data();
    if (existing.ownerUserId && existing.ownerUserId !== me.id) {
      throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    }
    try {
      const isBlobUrl = typeof existing.path === "string" && existing.path.startsWith("http");
      if (isBlobUrl) {
        if (existing.path.includes("storage.googleapis.com")) {
          try {
            const bucket = getFirebaseBucket();
            const pathname = existing.path.split(`https://storage.googleapis.com/${bucket.name}/`)[1];
            if (pathname) await bucket.file(pathname).delete({ ignoreNotFound: true });
          } catch {
          }
        } else {
          const blobToken = process.env.BLOB_READ_WRITE_TOKEN;
          await del(existing.path, blobToken ? { token: blobToken } : void 0);
        }
      } else {
        const fileFsPath = path$3.join(process.cwd(), "public", existing.path);
        await promises.unlink(fileFsPath);
      }
    } catch {
    }
    await db.collection("files").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _projectId_$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _projectId_$6
}, Symbol.toStringTag, { value: 'Module' }));

const _id_ = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const { id } = getRouterParams(event);
  const pageId = Number(id);
  if (!pageId) throw createError$1({ statusCode: 400, statusMessage: "Invalid id" });
  const method = getMethod(event);
  const db = getFirestore();
  const pageDoc = await db.collection("homePages").doc(String(pageId)).get();
  const page = pageDoc.exists ? pageDoc.data() : null;
  if (!page || page.accountId !== me.accountId) throw createError$1({ statusCode: 404, statusMessage: "Not found" });
  if (method === "GET") {
    if (me.role === "OWNER" || me.role === "ADMIN") return page;
    const accessSnap = await db.collection("homePagePermissions").where("homePageId", "==", pageId).where("userId", "==", String(me.id)).get();
    const access = !accessSnap.empty;
    if (!page.isDefault && !access) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    return page;
  }
  if (method === "PUT") {
    let canEdit = me.role === "OWNER" || me.role === "ADMIN";
    if (!canEdit) {
      const permSnap = await db.collection("homePagePermissions").where("homePageId", "==", pageId).where("userId", "==", String(me.id)).where("canEdit", "==", true).get();
      canEdit = !permSnap.empty;
    }
    if (!canEdit) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const body = await readBody(event);
    if (body.isDefault === true) {
      const snap = await db.collection("homePages").where("accountId", "==", me.accountId).where("isDefault", "==", true).get();
      for (const d of snap.docs) {
        await d.ref.update({ isDefault: false });
      }
    }
    const update = {};
    if (typeof body.name !== "undefined") update.name = body.name;
    if (typeof body.layout !== "undefined") update.layout = body.layout;
    if (typeof body.isDefault !== "undefined") update.isDefault = body.isDefault;
    await db.collection("homePages").doc(String(pageId)).update(update);
    const newDoc = await db.collection("homePages").doc(String(pageId)).get();
    return newDoc.data();
  }
  if (method === "DELETE") {
    if (me.role !== "OWNER" && me.role !== "ADMIN") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const permSnap = await db.collection("homePagePermissions").where("homePageId", "==", pageId).get();
    for (const d of permSnap.docs) {
      await d.ref.delete();
    }
    await db.collection("homePages").doc(String(pageId)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _id_$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id_
}, Symbol.toStringTag, { value: 'Module' }));

const index$8 = defineEventHandler(async (event) => {
  var _a, _b, _c;
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const method = getMethod(event);
  if (method === "GET") {
    const db = getFirestore();
    const existing = await db.collection("homePages").where("accountId", "==", me.accountId).get();
    if (existing.empty) {
      const id = await getNextSequence("homePages");
      await db.collection("homePages").doc(String(id)).set({ id, accountId: me.accountId, name: "Home", layout: { modules: [] }, isDefault: true, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
    }
    const mine = await db.collection("homePagePermissions").where("userId", "==", String(me.id)).get();
    if (mine.empty) {
      const id = await getNextSequence("homePages");
      const name = `My Page #${me.id}`;
      await db.collection("homePages").doc(String(id)).set({ id, accountId: me.accountId, name, layout: { modules: [] }, isDefault: false, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
      const pid = await getNextSequence("homePagePermissions");
      await db.collection("homePagePermissions").doc(String(pid)).set({ id: pid, homePageId: id, userId: String(me.id), canEdit: true, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
    }
    const pageSnap = await db.collection("homePages").where("accountId", "==", me.accountId).get();
    const permSnap = await db.collection("homePagePermissions").where("userId", "==", String(me.id)).get();
    const editableIds = new Set(permSnap.docs.map((d) => d.get("homePageId")));
    const pages = pageSnap.docs.map((d) => d.data()).filter((p) => p.isDefault || editableIds.has(p.id)).sort((a, b) => String(a.createdAt || "").localeCompare(String(b.createdAt || ""))).map((p) => ({ ...p, mine: editableIds.has(p.id) }));
    return pages;
  }
  if (method === "POST") {
    const body = await readBody(event);
    const name = ((body == null ? void 0 : body.name) || "").trim();
    if (!name) throw createError$1({ statusCode: 400, statusMessage: "name is required" });
    const db = getFirestore();
    const countSnap = await db.collection("homePages").where("accountId", "==", me.accountId).get();
    if (countSnap.size >= 4) throw createError$1({ statusCode: 400, statusMessage: "Page limit reached (4)" });
    if (me.role === "OWNER" || me.role === "ADMIN") {
      if (body.isDefault) {
        const snap = await db.collection("homePages").where("accountId", "==", me.accountId).where("isDefault", "==", true).get();
        for (const d of snap.docs) {
          await d.ref.update({ isDefault: false });
        }
      }
      const id2 = await getNextSequence("homePages");
      const doc2 = { id: id2, accountId: me.accountId, name, layout: (_a = body.layout) != null ? _a : { modules: [] }, isDefault: (_b = body.isDefault) != null ? _b : false, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
      await db.collection("homePages").doc(String(id2)).set(doc2);
      return doc2;
    }
    const id = await getNextSequence("homePages");
    const doc = { id, accountId: me.accountId, name, layout: (_c = body.layout) != null ? _c : { modules: [] }, isDefault: false, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
    await db.collection("homePages").doc(String(id)).set(doc);
    const pid = await getNextSequence("homePagePermissions");
    await db.collection("homePagePermissions").doc(String(pid)).set({ id: pid, homePageId: id, userId: String(me.id), canEdit: true, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
    return doc;
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$8
}, Symbol.toStringTag, { value: 'Module' }));

const permissions = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const method = getMethod(event);
  if (method === "POST") {
    if (me.role !== "OWNER" && me.role !== "ADMIN") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.homePageId)) throw createError$1({ statusCode: 400, statusMessage: "homePageId required" });
    const db = getFirestore();
    const pageDoc = await db.collection("homePages").doc(String(body.homePageId)).get();
    const page = pageDoc.exists ? pageDoc.data() : null;
    if (!page || page.accountId !== me.accountId) throw createError$1({ statusCode: 404, statusMessage: "Page not found" });
    const existing = await db.collection("homePagePermissions").where("homePageId", "==", page.id).get();
    for (const d of existing.docs) {
      await d.ref.delete();
    }
    for (const a of body.assignments.filter((a2) => a2.enabled)) {
      await db.collection("homePagePermissions").add({ homePageId: page.id, userId: String(a.userId), canEdit: !!a.canEdit, createdAt: (/* @__PURE__ */ new Date()).toISOString() });
    }
    return { ok: true };
  }
  if (method === "GET") {
    const query = getQuery(event);
    const homePageId = Number(query.homePageId);
    if (!homePageId) throw createError$1({ statusCode: 400, statusMessage: "homePageId required" });
    const db = getFirestore();
    const pageDoc = await db.collection("homePages").doc(String(homePageId)).get();
    const page = pageDoc.exists ? pageDoc.data() : null;
    if (!page || page.accountId !== me.accountId) throw createError$1({ statusCode: 404, statusMessage: "Page not found" });
    if (me.role !== "OWNER" && me.role !== "ADMIN") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const snap = await db.collection("homePagePermissions").where("homePageId", "==", homePageId).orderBy("createdAt", "asc").get();
    return snap.docs.map((d) => d.data());
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const permissions$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: permissions
}, Symbol.toStringTag, { value: 'Module' }));

function pairKeyFor(a, b) {
  const as = String(a);
  const bs = String(b);
  return as < bs ? `${as}_${bs}` : `${bs}_${as}`;
}
const _peerId_ = defineEventHandler(async (event) => {
  const { peerId } = getRouterParams(event);
  if (!peerId) {
    throw createError$1({ statusCode: 400, statusMessage: "peerId is required" });
  }
  const me = await getCurrentUser(event);
  if (!(me == null ? void 0 : me.id)) {
    throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  }
  const method = getMethod(event);
  const db = getFirestore();
  const key = pairKeyFor(me.id, peerId);
  if (method === "GET") {
    try {
      const snap = await db.collection("directMessages").where("pairKey", "==", key).orderBy("createdAt", "desc").limit(100).get();
      const list = snap.docs.map((d) => d.data());
      return list.sort((a, b) => String(a.createdAt || "").localeCompare(String(b.createdAt || "")));
    } catch (e) {
      const msg = String((e == null ? void 0 : e.message) || "");
      const code = String((e == null ? void 0 : e.code) || "");
      const needsIndex = msg.includes("FAILED_PRECONDITION") || code.includes("failed-precondition");
      if (!needsIndex) throw e;
      const snap = await db.collection("directMessages").where("pairKey", "==", key).get();
      const list = snap.docs.map((d) => d.data());
      list.sort((a, b) => String(a.createdAt || "").localeCompare(String(b.createdAt || "")));
      return list.slice(-100);
    }
  }
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.content) || !body.content.trim()) {
      throw createError$1({ statusCode: 400, statusMessage: "content is required" });
    }
    const id = await getNextSequence("directMessages");
    const doc = {
      id,
      fromUserId: String(me.id),
      toUserId: String(peerId),
      pairKey: key,
      content: body.content.trim(),
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await db.collection("directMessages").doc(String(id)).set(doc);
    return doc;
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _peerId_$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _peerId_
}, Symbol.toStringTag, { value: 'Module' }));

const _projectId_$4 = defineEventHandler(async (event) => {
  var _a;
  const { projectId } = getRouterParams(event);
  const projectIdNum = Number(projectId);
  if (!projectId || Number.isNaN(projectIdNum)) {
    throw createError$1({ statusCode: 400, statusMessage: "projectId must be a number" });
  }
  const method = getMethod(event);
  if (method === "GET") {
    const db = getFirestore();
    const snap = await db.collection("messages").where("projectId", "==", projectIdNum).orderBy("createdAt", "desc").get();
    return snap.docs.map((d) => d.data());
  }
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.title) || !(body == null ? void 0 : body.content)) {
      throw createError$1({ statusCode: 400, statusMessage: "title and content are required" });
    }
    const db = getFirestore();
    const id = await getNextSequence("messages");
    const doc = { id, title: body.title, content: body.content, userId: (_a = body.userId) != null ? _a : 1, projectId: projectIdNum, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
    await db.collection("messages").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    await db.collection("messages").doc(String(body.id)).update({ title: body.title, content: body.content });
    const snap = await db.collection("messages").doc(String(body.id)).get();
    return snap.data();
  }
  if (method === "DELETE") {
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    await db.collection("messages").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _projectId_$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _projectId_$4
}, Symbol.toStringTag, { value: 'Module' }));

const transfer_post = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  if (me.role !== "OWNER") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
  const body = await readBody(event);
  const targetId = String((body == null ? void 0 : body.targetUserId) || "");
  if (!targetId) throw createError$1({ statusCode: 400, statusMessage: "targetUserId required" });
  if (String(targetId) === String(me.id)) throw createError$1({ statusCode: 400, statusMessage: "Already owner" });
  const db = getFirestore();
  const targetSnap = await db.collection("users").doc(targetId).get();
  if (!targetSnap.exists) throw createError$1({ statusCode: 404, statusMessage: "Target user not found" });
  await db.collection("users").doc(String(me.id)).set({ role: "ADMIN" }, { merge: true });
  await db.collection("users").doc(targetId).set({ role: "OWNER" }, { merge: true });
  return { ok: true };
});

const transfer_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: transfer_post
}, Symbol.toStringTag, { value: 'Module' }));

const _slug__get = defineEventHandler(async (event) => {
  const { slug } = getRouterParams(event);
  if (!slug) {
    throw createError$1({ statusCode: 400, statusMessage: "slug is required" });
  }
  const db = getFirestore();
  const projSnap = await db.collection("projects").where("slug", "==", slug).limit(1).get();
  if (projSnap.empty) {
    throw createError$1({ statusCode: 404, statusMessage: "Project not found" });
  }
  const project = projSnap.docs[0].data();
  const messagesSnap = await db.collection("messages").where("projectId", "==", project.id).orderBy("createdAt", "desc").get();
  const todosSnap = await db.collection("todos").where("projectId", "==", project.id).get();
  const filesSnap = await db.collection("files").where("projectId", "==", project.id).orderBy("createdAt", "desc").get();
  const todos = todosSnap.docs.map((d) => d.data());
  for (const t of todos) {
    const itemsSnap = await db.collection("todoItems").where("todoId", "==", t.id).get();
    const items = itemsSnap.docs.map((d) => d.data());
    for (const it of items) {
      const subsSnap = await db.collection("todoSubItems").where("todoItemId", "==", it.id).get();
      it.subItems = subsSnap.docs.map((d) => d.data());
    }
    t.items = items;
  }
  return { ...project, messages: messagesSnap.docs.map((d) => d.data()), todos, files: filesSnap.docs.map((d) => d.data()) };
});

const _slug__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _slug__get
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$2 = defineEventHandler(async () => {
  const db = getFirestore();
  const snap = await db.collection("projects").orderBy("createdAt", "desc").get();
  return snap.docs.map((d) => ({ id: Number(d.get("id")), name: d.get("name"), slug: d.get("slug") }));
});

const index_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const index_post$2 = defineEventHandler(async (event) => {
  var _a, _b;
  const body = await readBody(event);
  if (!(body == null ? void 0 : body.name) || !(body == null ? void 0 : body.slug)) {
    throw createError$1({ statusCode: 400, statusMessage: "name and slug are required" });
  }
  const db = getFirestore();
  const id = await getNextSequence("projects");
  const now = /* @__PURE__ */ new Date();
  await db.collection("projects").doc(String(id)).set({
    id,
    name: body.name,
    slug: body.slug,
    accountId: (_a = body.accountId) != null ? _a : 1,
    createdAt: now.toISOString(),
    updatedAt: now.toISOString()
  });
  return { id, name: body.name, slug: body.slug, accountId: (_b = body.accountId) != null ? _b : 1 };
});

const index_post$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post$2
}, Symbol.toStringTag, { value: 'Module' }));

const _projectId_$2 = defineEventHandler(async (event) => {
  var _a;
  const { projectId } = getRouterParams(event);
  const projectIdNum = Number(projectId);
  if (!projectId || Number.isNaN(projectIdNum)) {
    throw createError$1({ statusCode: 400, statusMessage: "projectId must be a number" });
  }
  const method = getMethod(event);
  if (method === "GET") {
    const db = getFirestore();
    const snap = await db.collection("roadmapEntries").where("projectId", "==", projectIdNum).orderBy("date", "asc").get().catch(async () => {
      return await db.collection("roadmapEntries").where("projectId", "==", projectIdNum).get();
    });
    return snap.docs.map((d) => d.data());
  }
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.description) || !(body == null ? void 0 : body.date)) {
      throw createError$1({ statusCode: 400, statusMessage: "description and date are required" });
    }
    const parsedDate = new Date(body.date);
    if (Number.isNaN(parsedDate.getTime())) {
      throw createError$1({ statusCode: 400, statusMessage: "date must be a valid date" });
    }
    const db = getFirestore();
    const id = await getNextSequence("roadmapEntries");
    const doc = { id, description: body.description, date: parsedDate.toISOString(), userId: String((_a = body.userId) != null ? _a : "1"), projectId: projectIdNum, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
    await db.collection("roadmapEntries").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    const ref = db.collection("roadmapEntries").doc(String(body.id));
    const snap = await ref.get();
    if (!snap.exists) throw createError$1({ statusCode: 404, statusMessage: "Not found" });
    const data = {};
    if (typeof body.description === "string") data.description = body.description;
    if (body.date) {
      const d = new Date(body.date);
      if (Number.isNaN(d.getTime())) {
        throw createError$1({ statusCode: 400, statusMessage: "date must be a valid date" });
      }
      data.date = d.toISOString();
    }
    await ref.set({ ...snap.data(), ...data, updatedAt: (/* @__PURE__ */ new Date()).toISOString() }, { merge: true });
    return (await ref.get()).data();
  }
  if (method === "DELETE") {
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    await db.collection("roadmapEntries").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _projectId_$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _projectId_$2
}, Symbol.toStringTag, { value: 'Module' }));

const titlePath = path$3.join(process.cwd(), "public", "site-title.json");
const index$6 = defineEventHandler(async (event) => {
  var _a, _b, _c;
  const method = getMethod(event);
  if (method === "GET") {
    try {
      const db = getFirestore();
      const snap = await db.collection("settings").doc("site").get();
      const title = (snap.exists ? (_a = snap.data()) == null ? void 0 : _a.title : void 0) || null;
      if (title) return { title };
    } catch {
    }
    try {
      const raw = await promises.readFile(titlePath, "utf-8");
      const data = JSON.parse(raw);
      return { title: (_b = data.title) != null ? _b : "Home" };
    } catch {
      return { title: "Home" };
    }
  }
  if (method === "POST") {
    const me = await getCurrentUser(event);
    if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
    if (me.role !== "ADMIN" && me.role !== "OWNER") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    const body = await readBody(event);
    const title = ((_c = body == null ? void 0 : body.title) != null ? _c : "").toString().trim();
    if (!title) throw createError$1({ statusCode: 400, statusMessage: "Title required" });
    try {
      const db = getFirestore();
      await db.collection("settings").doc("site").set({ title }, { merge: true });
      return { ok: true, title };
    } catch (e) {
      if (!process.env.VERCEL) {
        await promises.writeFile(titlePath, JSON.stringify({ title }, null, 2), "utf-8");
        return { ok: true, title };
      }
      throw createError$1({ statusCode: 500, statusMessage: "Failed to save title. Configure Firebase Admin for production." });
    }
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$6
}, Symbol.toStringTag, { value: 'Module' }));

function normalizeDateForLocalDay(date, tzOffsetMinutes) {
  const local = new Date(date.getTime() - (tzOffsetMinutes != null ? tzOffsetMinutes : 0) * 6e4);
  const y = local.getUTCFullYear();
  const m = local.getUTCMonth();
  const d = local.getUTCDate();
  const iso = new Date(Date.UTC(y, m, d, 0, 0, 0, 0)).toISOString();
  return iso;
}
const index$4 = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const method = getMethod(event);
  const db = getFirestore();
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.userId) || !(body == null ? void 0 : body.action)) {
      throw createError$1({ statusCode: 400, statusMessage: "userId and action are required" });
    }
    const requestedUserId = String(body.userId);
    if (me.role !== "ADMIN" && requestedUserId !== String(me.id)) {
      throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    }
    const now = body.timestamp ? new Date(body.timestamp) : /* @__PURE__ */ new Date();
    const dayKey = normalizeDateForLocalDay(now, body.tzOffsetMinutes || 0);
    const docId = `${requestedUserId}_${dayKey}`;
    const ref = db.collection("timeEntries").doc(docId);
    const snap = await ref.get();
    if (!snap.exists) {
      await ref.set({ id: docId, userId: requestedUserId, date: dayKey });
    }
    const field = body.action;
    const data = (await ref.get()).data() || { id: docId, userId: requestedUserId, date: dayKey };
    if (data[field]) {
      return { ok: true, entry: data };
    }
    const patch = {};
    patch[field] = now.toISOString();
    await ref.set({ ...data, ...patch }, { merge: true });
    const updated = (await ref.get()).data();
    return { ok: true, entry: updated };
  }
  if (method === "GET") {
    const q = getQuery(event);
    const userId = String(q.userId || me.id);
    if (String(me.id) !== userId && !(me.role === "ADMIN" || me.role === "MANAGER" || me.role === "OWNER" || me.role === "ADMIN_MANAGER")) {
      throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    }
    const startStr = typeof q.start === "string" ? q.start : null;
    const endStr = typeof q.end === "string" ? q.end : null;
    let startIso;
    let endIso;
    if (startStr && endStr) {
      startIso = (/* @__PURE__ */ new Date(startStr + "T00:00:00.000Z")).toISOString();
      endIso = (/* @__PURE__ */ new Date(endStr + "T23:59:59.999Z")).toISOString();
    } else {
      const today = /* @__PURE__ */ new Date();
      const ago = new Date(today);
      ago.setDate(today.getDate() - 30);
      startIso = new Date(Date.UTC(ago.getUTCFullYear(), ago.getUTCMonth(), ago.getUTCDate())).toISOString();
      endIso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate(), 23, 59, 59, 999)).toISOString();
    }
    const snap = await db.collection("timeEntries").where("userId", "==", userId).where("date", ">=", startIso).where("date", "<=", endIso).orderBy("date", "desc").get();
    const items = snap.docs.map((d) => d.data());
    return items;
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$4
}, Symbol.toStringTag, { value: 'Module' }));

const index$2 = defineEventHandler(async (event) => {
  var _a;
  const method = getMethod(event);
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.todoId) || !(body == null ? void 0 : body.content)) throw createError$1({ statusCode: 400, statusMessage: "todoId and content required" });
    const db = getFirestore();
    const id = await getNextSequence("todoItems");
    const doc = { id, todoId: Number(body.todoId), content: body.content, position: (_a = body.position) != null ? _a : 0, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
    await db.collection("todoItems").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    const db = getFirestore();
    if (Array.isArray(body == null ? void 0 : body.order)) {
      await Promise.all(body.order.map((it) => db.collection("todoItems").doc(String(it.id)).update({ position: it.position })));
      return { ok: true };
    }
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id required" });
    await db.collection("todoItems").doc(String(body.id)).update({ content: body.content, done: body.done, position: body.position });
    const snap = await db.collection("todoItems").doc(String(body.id)).get();
    return snap.data();
  }
  if (method === "DELETE") {
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id required" });
    const db = getFirestore();
    const subs = await db.collection("todoSubItems").where("todoItemId", "==", id).get();
    for (const s of subs.docs) {
      await s.ref.delete();
    }
    await db.collection("todoItems").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index$2
}, Symbol.toStringTag, { value: 'Module' }));

const index = defineEventHandler(async (event) => {
  var _a;
  const method = getMethod(event);
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.todoItemId) || !(body == null ? void 0 : body.content)) {
      throw createError$1({ statusCode: 400, statusMessage: "todoItemId and content required" });
    }
    const db = getFirestore();
    const id = await getNextSequence("todoSubItems");
    const doc = { id, todoItemId: Number(body.todoItemId), content: body.content, position: (_a = body.position) != null ? _a : 0, createdAt: (/* @__PURE__ */ new Date()).toISOString() };
    await db.collection("todoSubItems").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    const db = getFirestore();
    if (Array.isArray(body == null ? void 0 : body.order)) {
      await Promise.all(body.order.map((it) => db.collection("todoSubItems").doc(String(it.id)).update({ position: it.position })));
      return { ok: true };
    }
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id required" });
    await db.collection("todoSubItems").doc(String(body.id)).update({ content: body.content, done: body.done, position: body.position });
    const snap = await db.collection("todoSubItems").doc(String(body.id)).get();
    return snap.data();
  }
  if (method === "DELETE") {
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id required" });
    const db = getFirestore();
    await db.collection("todoSubItems").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const index$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: 'Module' }));

const _projectId_ = defineEventHandler(async (event) => {
  const { projectId } = getRouterParams(event);
  const projectIdNum = Number(projectId);
  if (!projectId || Number.isNaN(projectIdNum)) {
    throw createError$1({ statusCode: 400, statusMessage: "projectId must be a number" });
  }
  const method = getMethod(event);
  if (method === "GET") {
    const db = getFirestore();
    const listsSnap = await db.collection("todos").where("projectId", "==", projectIdNum).get();
    const lists = listsSnap.docs.map((d) => d.data());
    for (const list of lists) {
      const itemsSnap = await db.collection("todoItems").where("todoId", "==", list.id).orderBy("position", "asc").get();
      const items = itemsSnap.docs.map((d) => d.data());
      for (const it of items) {
        const subsSnap = await db.collection("todoSubItems").where("todoItemId", "==", it.id).orderBy("position", "asc").get();
        it.subItems = subsSnap.docs.map((d) => d.data());
      }
      list.items = items;
    }
    return lists.sort((a, b) => String(b.createdAt || "").localeCompare(String(a.createdAt || "")));
  }
  if (method === "POST") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.title)) throw createError$1({ statusCode: 400, statusMessage: "title is required" });
    const db = getFirestore();
    const id = await getNextSequence("todos");
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const doc = { id, title: body.title, userId: Number(body.userId || 1), projectId: projectIdNum, createdAt: now, updatedAt: now };
    await db.collection("todos").doc(String(id)).set(doc);
    return doc;
  }
  if (method === "PUT") {
    const body = await readBody(event);
    if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    await db.collection("todos").doc(String(body.id)).update({ title: body.title });
    const snap = await db.collection("todos").doc(String(body.id)).get();
    return snap.data();
  }
  if (method === "DELETE") {
    const query = getQuery(event);
    const id = Number(query.id);
    if (!id) throw createError$1({ statusCode: 400, statusMessage: "id is required" });
    const db = getFirestore();
    const items = await db.collection("todoItems").where("todoId", "==", id).get();
    for (const it of items.docs) {
      const subs = await db.collection("todoSubItems").where("todoItemId", "==", it.get("id")).get();
      for (const s of subs.docs) {
        await s.ref.delete();
      }
      await it.ref.delete();
    }
    await db.collection("todos").doc(String(id)).delete();
    return { ok: true };
  }
  throw createError$1({ statusCode: 405, statusMessage: "Method Not Allowed" });
});

const _projectId_$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _projectId_
}, Symbol.toStringTag, { value: 'Module' }));

const index_get = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const db = getFirestore();
  const isMgr = me.role === "OWNER" || me.role === "ADMIN" || me.role === "MANAGER" || me.role === "ADMIN_MANAGER";
  if (isMgr) {
    const snap = await db.collection("users").get();
    const list = snap.docs.map((d) => ({ id: d.id, ...d.data() })).sort((a, b) => String(b.createdAt || "").localeCompare(String(a.createdAt || "")));
    return list;
  }
  const meSnap = await db.collection("users").doc(String(me.id)).get();
  return meSnap.exists ? [{ id: meSnap.id, ...meSnap.data() }] : [];
});

const index_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get
}, Symbol.toStringTag, { value: 'Module' }));

const index_post = defineEventHandler(async (event) => {
  var _a, _b, _c;
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  if (me.role !== "ADMIN" && me.role !== "OWNER") throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
  const body = await readBody(event);
  if (!(body == null ? void 0 : body.name) || !(body == null ? void 0 : body.email)) throw createError$1({ statusCode: 400, statusMessage: "name and email required" });
  const username = body.username && body.username.trim() !== "" ? body.username.trim() : body.email.includes("@") ? body.email.split("@")[0] : body.name.toLowerCase().replace(/\s+/g, "");
  const requestedRole = (_a = body.role) != null ? _a : "USER";
  if (requestedRole === "ADMIN_MANAGER" && me.role !== "OWNER") {
    throw createError$1({ statusCode: 403, statusMessage: "Only OWNER can assign ADMIN_MANAGER" });
  }
  const db = getFirestore();
  const id = body.email;
  const doc = {
    id,
    name: body.name,
    email: body.email,
    username,
    accountId: (_b = me.accountId) != null ? _b : 1,
    role: requestedRole,
    managerId: (_c = body.managerId) != null ? _c : null,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await db.collection("users").doc(String(id)).set(doc);
  return doc;
});

const index_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post
}, Symbol.toStringTag, { value: 'Module' }));

const index_put = defineEventHandler(async (event) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  const body = await readBody(event);
  if (!(body == null ? void 0 : body.id)) throw createError$1({ statusCode: 400, statusMessage: "id required" });
  const db = getFirestore();
  const ref = db.collection("users").doc(String(body.id));
  const snap = await ref.get();
  if (!snap.exists) throw createError$1({ statusCode: 404, statusMessage: "User not found" });
  const target = { id: snap.id, ...snap.data() };
  if (me.role === "OWNER") {
    const updated2 = { ...target, role: (_a = body.role) != null ? _a : target.role, managerId: (_b = body.managerId) != null ? _b : target.managerId, name: (_c = body.name) != null ? _c : target.name, email: (_d = body.email) != null ? _d : target.email, username: (_e = body.username) != null ? _e : target.username };
    await ref.set(updated2, { merge: true });
    return updated2;
  }
  if (me.role === "ADMIN") {
    if (body.role === "OWNER" || body.role === "ADMIN_MANAGER") throw createError$1({ statusCode: 403, statusMessage: "Cannot assign OWNER/ADMIN_MANAGER" });
    const updated2 = { ...target, role: (_f = body.role) != null ? _f : target.role, managerId: (_g = body.managerId) != null ? _g : target.managerId, name: (_h = body.name) != null ? _h : target.name, email: (_i = body.email) != null ? _i : target.email, username: (_j = body.username) != null ? _j : target.username };
    await ref.set(updated2, { merge: true });
    return updated2;
  }
  if (me.role === "MANAGER" || me.role === "ADMIN_MANAGER") {
    const isEditableTarget = target.managerId === me.id;
    if (!isEditableTarget) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
    if (body.role === "ADMIN" || body.role === "OWNER" || body.role === "ADMIN_MANAGER") throw createError$1({ statusCode: 403, statusMessage: "Cannot assign ADMIN/OWNER/ADMIN_MANAGER" });
    if (body.managerId !== void 0) {
      throw createError$1({ statusCode: 403, statusMessage: "Managers cannot change manager assignment" });
    }
    const updated2 = { ...target, role: (_k = body.role) != null ? _k : target.role, name: (_l = body.name) != null ? _l : target.name, email: (_m = body.email) != null ? _m : target.email, username: (_n = body.username) != null ? _n : target.username };
    await ref.set(updated2, { merge: true });
    return updated2;
  }
  if (me.id !== target.id) throw createError$1({ statusCode: 403, statusMessage: "Forbidden" });
  const updated = { ...target, name: (_o = body.name) != null ? _o : target.name, email: (_p = body.email) != null ? _p : target.email, username: (_q = body.username) != null ? _q : target.username };
  await ref.set(updated, { merge: true });
  return updated;
});

const index_put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_put
}, Symbol.toStringTag, { value: 'Module' }));

const password_post = defineEventHandler(async (event) => {
  const me = await getCurrentUser(event);
  if (!me) throw createError$1({ statusCode: 401, statusMessage: "Unauthorized" });
  throw createError$1({ statusCode: 400, statusMessage: "Password login disabled. Use Google sign-in." });
});

const password_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: password_post
}, Symbol.toStringTag, { value: 'Module' }));

function createRendererContext({ manifest, precomputed, buildAssetsURL }) {
  if (!manifest && !precomputed) {
    throw new Error("Either manifest or precomputed data must be provided");
  }
  const ctx = {
    // Options
    buildAssetsURL: buildAssetsURL || withLeadingSlash,
    manifest,
    precomputed,
    updateManifest,
    // Internal cache
    _dependencies: {},
    _dependencySets: {},
    _entrypoints: []
  };
  function updateManifest(manifest2) {
    const manifestEntries = Object.entries(manifest2);
    ctx.manifest = manifest2;
    ctx._dependencies = {};
    ctx._dependencySets = {};
    ctx._entrypoints = manifestEntries.filter((e) => e[1].isEntry).map(([module]) => module);
  }
  if (precomputed) {
    ctx._dependencies = precomputed.dependencies;
    ctx._entrypoints = precomputed.entrypoints;
  } else if (manifest) {
    updateManifest(manifest);
  }
  return ctx;
}
function getModuleDependencies(id, rendererContext) {
  if (rendererContext._dependencies[id]) {
    return rendererContext._dependencies[id];
  }
  const dependencies = rendererContext._dependencies[id] = {
    scripts: {},
    styles: {},
    preload: {},
    prefetch: {}
  };
  if (!rendererContext.manifest) {
    return dependencies;
  }
  const meta = rendererContext.manifest[id];
  if (!meta) {
    return dependencies;
  }
  if (meta.file) {
    dependencies.preload[id] = meta;
    if (meta.isEntry || meta.sideEffects) {
      dependencies.scripts[id] = meta;
    }
  }
  for (const css of meta.css || []) {
    dependencies.styles[css] = dependencies.preload[css] = dependencies.prefetch[css] = rendererContext.manifest[css];
  }
  for (const asset of meta.assets || []) {
    dependencies.preload[asset] = dependencies.prefetch[asset] = rendererContext.manifest[asset];
  }
  for (const depId of meta.imports || []) {
    const depDeps = getModuleDependencies(depId, rendererContext);
    for (const key in depDeps.styles) {
      dependencies.styles[key] = depDeps.styles[key];
    }
    for (const key in depDeps.preload) {
      dependencies.preload[key] = depDeps.preload[key];
    }
    for (const key in depDeps.prefetch) {
      dependencies.prefetch[key] = depDeps.prefetch[key];
    }
  }
  const filteredPreload = {};
  for (const id2 in dependencies.preload) {
    const dep = dependencies.preload[id2];
    if (dep.preload) {
      filteredPreload[id2] = dep;
    }
  }
  dependencies.preload = filteredPreload;
  return dependencies;
}
function getAllDependencies(ids, rendererContext) {
  let cacheKey = "";
  const sortedIds = [...ids].sort();
  for (let i = 0; i < sortedIds.length; i++) {
    if (i > 0) cacheKey += ",";
    cacheKey += sortedIds[i];
  }
  if (rendererContext._dependencySets[cacheKey]) {
    return rendererContext._dependencySets[cacheKey];
  }
  const allDeps = {
    scripts: {},
    styles: {},
    preload: {},
    prefetch: {}
  };
  for (const id of ids) {
    const deps = getModuleDependencies(id, rendererContext);
    for (const key in deps.scripts) {
      allDeps.scripts[key] = deps.scripts[key];
    }
    for (const key in deps.styles) {
      allDeps.styles[key] = deps.styles[key];
    }
    for (const key in deps.preload) {
      allDeps.preload[key] = deps.preload[key];
    }
    for (const key in deps.prefetch) {
      allDeps.prefetch[key] = deps.prefetch[key];
    }
    for (const dynamicDepId of rendererContext.manifest?.[id]?.dynamicImports || []) {
      const dynamicDeps = getModuleDependencies(dynamicDepId, rendererContext);
      for (const key in dynamicDeps.scripts) {
        allDeps.prefetch[key] = dynamicDeps.scripts[key];
      }
      for (const key in dynamicDeps.styles) {
        allDeps.prefetch[key] = dynamicDeps.styles[key];
      }
      for (const key in dynamicDeps.preload) {
        allDeps.prefetch[key] = dynamicDeps.preload[key];
      }
    }
  }
  const filteredPrefetch = {};
  for (const id in allDeps.prefetch) {
    const dep = allDeps.prefetch[id];
    if (dep.prefetch) {
      filteredPrefetch[id] = dep;
    }
  }
  allDeps.prefetch = filteredPrefetch;
  for (const id in allDeps.preload) {
    delete allDeps.prefetch[id];
  }
  for (const style in allDeps.styles) {
    delete allDeps.preload[style];
    delete allDeps.prefetch[style];
  }
  rendererContext._dependencySets[cacheKey] = allDeps;
  return allDeps;
}
function getRequestDependencies(ssrContext, rendererContext) {
  if (ssrContext._requestDependencies) {
    return ssrContext._requestDependencies;
  }
  const ids = new Set(Array.from([
    ...rendererContext._entrypoints,
    ...ssrContext.modules || ssrContext._registeredComponents || []
  ]));
  const deps = getAllDependencies(ids, rendererContext);
  ssrContext._requestDependencies = deps;
  return deps;
}
function renderStyles(ssrContext, rendererContext) {
  const { styles } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in styles) {
    const resource = styles[key];
    result += `<link rel="stylesheet" href="${rendererContext.buildAssetsURL(resource.file)}" crossorigin>`;
  }
  return result;
}
function renderResourceHints(ssrContext, rendererContext) {
  const { preload, prefetch } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in preload) {
    const resource = preload[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const rel = resource.module ? "modulepreload" : "preload";
    const crossorigin = resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? " crossorigin" : "";
    if (resource.resourceType && resource.mimeType) {
      result += `<link rel="${rel}" as="${resource.resourceType}" type="${resource.mimeType}"${crossorigin} href="${href}">`;
    } else if (resource.resourceType) {
      result += `<link rel="${rel}" as="${resource.resourceType}"${crossorigin} href="${href}">`;
    } else {
      result += `<link rel="${rel}"${crossorigin} href="${href}">`;
    }
  }
  for (const key in prefetch) {
    const resource = prefetch[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const crossorigin = resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? " crossorigin" : "";
    if (resource.resourceType && resource.mimeType) {
      result += `<link rel="prefetch" as="${resource.resourceType}" type="${resource.mimeType}"${crossorigin} href="${href}">`;
    } else if (resource.resourceType) {
      result += `<link rel="prefetch" as="${resource.resourceType}"${crossorigin} href="${href}">`;
    } else {
      result += `<link rel="prefetch"${crossorigin} href="${href}">`;
    }
  }
  return result;
}
function renderResourceHeaders(ssrContext, rendererContext) {
  const { preload, prefetch } = getRequestDependencies(ssrContext, rendererContext);
  const links = [];
  for (const key in preload) {
    const resource = preload[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const rel = resource.module ? "modulepreload" : "preload";
    let header = `<${href}>; rel="${rel}"`;
    if (resource.resourceType) {
      header += `; as="${resource.resourceType}"`;
    }
    if (resource.mimeType) {
      header += `; type="${resource.mimeType}"`;
    }
    if (resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module) {
      header += "; crossorigin";
    }
    links.push(header);
  }
  for (const key in prefetch) {
    const resource = prefetch[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    let header = `<${href}>; rel="prefetch"`;
    if (resource.resourceType) {
      header += `; as="${resource.resourceType}"`;
    }
    if (resource.mimeType) {
      header += `; type="${resource.mimeType}"`;
    }
    if (resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module) {
      header += "; crossorigin";
    }
    links.push(header);
  }
  return {
    link: links.join(", ")
  };
}
function getPreloadLinks(ssrContext, rendererContext) {
  const { preload } = getRequestDependencies(ssrContext, rendererContext);
  const result = [];
  for (const key in preload) {
    const resource = preload[key];
    result.push({
      rel: resource.module ? "modulepreload" : "preload",
      as: resource.resourceType,
      type: resource.mimeType ?? null,
      crossorigin: resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? "" : null,
      href: rendererContext.buildAssetsURL(resource.file)
    });
  }
  return result;
}
function getPrefetchLinks(ssrContext, rendererContext) {
  const { prefetch } = getRequestDependencies(ssrContext, rendererContext);
  const result = [];
  for (const key in prefetch) {
    const resource = prefetch[key];
    result.push({
      rel: "prefetch",
      as: resource.resourceType,
      type: resource.mimeType ?? null,
      crossorigin: resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? "" : null,
      href: rendererContext.buildAssetsURL(resource.file)
    });
  }
  return result;
}
function renderScripts(ssrContext, rendererContext) {
  const { scripts } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in scripts) {
    const resource = scripts[key];
    if (resource.module) {
      result += `<script type="module" src="${rendererContext.buildAssetsURL(resource.file)}" crossorigin><\/script>`;
    } else {
      result += `<script src="${rendererContext.buildAssetsURL(resource.file)}" defer crossorigin><\/script>`;
    }
  }
  return result;
}
function createRenderer(createApp, renderOptions) {
  const rendererContext = createRendererContext(renderOptions);
  return {
    rendererContext,
    async renderToString(ssrContext) {
      ssrContext._registeredComponents = ssrContext._registeredComponents || /* @__PURE__ */ new Set();
      const _createApp = await Promise.resolve(createApp).then((r) => "default" in r ? r.default : r);
      const app = await _createApp(ssrContext);
      const html = await renderOptions.renderToString(app, ssrContext);
      const wrap = (fn) => () => fn(ssrContext, rendererContext);
      return {
        html,
        renderResourceHeaders: wrap(renderResourceHeaders),
        renderResourceHints: wrap(renderResourceHints),
        renderStyles: wrap(renderStyles),
        renderScripts: wrap(renderScripts)
      };
    }
  };
}

var vue = {exports: {}};

var vue_cjs_prod = {};

const require$$0 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(compilerDom);

const require$$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(runtimeDom);

/**
* vue v3.5.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

(function (exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	var compilerDom = require$$0;
	var runtimeDom = require$$1;
	var shared = shared_cjs_prod;

	function _interopNamespaceDefault(e) {
	  var n = Object.create(null);
	  if (e) {
	    for (var k in e) {
	      n[k] = e[k];
	    }
	  }
	  n.default = e;
	  return Object.freeze(n);
	}

	var runtimeDom__namespace = /*#__PURE__*/_interopNamespaceDefault(runtimeDom);

	const compileCache = /* @__PURE__ */ Object.create(null);
	function compileToFunction(template, options) {
	  if (!shared.isString(template)) {
	    if (template.nodeType) {
	      template = template.innerHTML;
	    } else {
	      return shared.NOOP;
	    }
	  }
	  const key = shared.genCacheKey(template, options);
	  const cached = compileCache[key];
	  if (cached) {
	    return cached;
	  }
	  if (template[0] === "#") {
	    const el = document.querySelector(template);
	    template = el ? el.innerHTML : ``;
	  }
	  const opts = shared.extend(
	    {
	      hoistStatic: true,
	      onError: void 0,
	      onWarn: shared.NOOP
	    },
	    options
	  );
	  if (!opts.isCustomElement && typeof customElements !== "undefined") {
	    opts.isCustomElement = (tag) => !!customElements.get(tag);
	  }
	  const { code } = compilerDom.compile(template, opts);
	  const render = new Function("Vue", code)(runtimeDom__namespace);
	  render._rc = true;
	  return compileCache[key] = render;
	}
	runtimeDom.registerRuntimeCompiler(compileToFunction);

	exports.compile = compileToFunction;
	Object.keys(runtimeDom).forEach(function (k) {
	  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
	}); 
} (vue_cjs_prod));

{
  vue.exports = vue_cjs_prod;
}

var vueExports = vue.exports;

const VueResolver = (_, value) => {
  return vueExports.isRef(value) ? vueExports.toValue(value) : value;
};

const headSymbol = "usehead";
function vueInstall(head) {
  const plugin = {
    install(app) {
      app.config.globalProperties.$unhead = head;
      app.config.globalProperties.$head = head;
      app.provide(headSymbol, head);
    }
  };
  return plugin.install;
}

function createHead(options = {}) {
  const head = createHead$1({
    ...options,
    propResolvers: [VueResolver]
  });
  head.install = vueInstall(head);
  return head;
}

const appHead = {"meta":[{"name":"viewport","content":"width=device-width, initial-scale=1"},{"charset":"utf-8"}],"link":[],"style":[],"script":[],"noscript":[]};

const appRootTag = "div";

const appRootAttrs = {"id":"__nuxt"};

const appTeleportTag = "div";

const appTeleportAttrs = {"id":"teleports"};

const appSpaLoaderTag = "div";

const appSpaLoaderAttrs = {"id":"__nuxt-loader"};

const appId = "nuxt-app";

function buildAssetsDir() {
  return useRuntimeConfig().app.buildAssetsDir;
}
function buildAssetsURL(...path) {
  return joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path);
}
function publicAssetsURL(...path) {
  const app = useRuntimeConfig().app;
  const publicBase = app.cdnURL || app.baseURL;
  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase;
}

const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;
const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;
const getClientManifest = () => Promise.resolve().then(function () { return client_manifest$1; }).then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
const getSPARenderer = lazyCachedFunction(async () => {
  const manifest = await getClientManifest();
  const spaTemplate = await Promise.resolve().then(function () { return _virtual__spaTemplate; }).then((r) => r.template).catch(() => "").then((r) => {
    {
      const APP_SPA_LOADER_OPEN_TAG = `<${appSpaLoaderTag}${propsToString(appSpaLoaderAttrs)}>`;
      const APP_SPA_LOADER_CLOSE_TAG = `</${appSpaLoaderTag}>`;
      const appTemplate = APP_ROOT_OPEN_TAG + APP_ROOT_CLOSE_TAG;
      const loaderTemplate = r ? APP_SPA_LOADER_OPEN_TAG + r + APP_SPA_LOADER_CLOSE_TAG : "";
      return appTemplate + loaderTemplate;
    }
  });
  const options = {
    manifest,
    renderToString: () => spaTemplate,
    buildAssetsURL
  };
  const renderer = createRenderer(() => () => {
  }, options);
  const result = await renderer.renderToString({});
  const renderToString = (ssrContext) => {
    const config = useRuntimeConfig(ssrContext.event);
    ssrContext.modules ||= /* @__PURE__ */ new Set();
    ssrContext.payload.serverRendered = false;
    ssrContext.config = {
      public: config.public,
      app: config.app
    };
    return Promise.resolve(result);
  };
  return {
    rendererContext: renderer.rendererContext,
    renderToString
  };
});
function lazyCachedFunction(fn) {
  let res = null;
  return () => {
    if (res === null) {
      res = fn().catch((err) => {
        res = null;
        throw err;
      });
    }
    return res;
  };
}
function getRenderer(ssrContext) {
  return getSPARenderer() ;
}

function renderPayloadResponse(ssrContext) {
  return {
    body: stringify$1(splitPayload(ssrContext).payload, ssrContext._payloadReducers) ,
    statusCode: getResponseStatus(ssrContext.event),
    statusMessage: getResponseStatusText(ssrContext.event),
    headers: {
      "content-type": "application/json;charset=utf-8" ,
      "x-powered-by": "Nuxt"
    }
  };
}
function renderPayloadJsonScript(opts) {
  const contents = opts.data ? stringify$1(opts.data, opts.ssrContext._payloadReducers) : "";
  const payload = {
    "type": "application/json",
    "innerHTML": contents,
    "data-nuxt-data": appId,
    "data-ssr": false
  };
  {
    payload.id = "__NUXT_DATA__";
  }
  if (opts.src) {
    payload["data-src"] = opts.src;
  }
  const config = uneval(opts.ssrContext.config);
  return [
    payload,
    {
      innerHTML: `window.__NUXT__={};window.__NUXT__.config=${config}`
    }
  ];
}
function splitPayload(ssrContext) {
  const { data, prerenderedAt, ...initial } = ssrContext.payload;
  return {
    initial: { ...initial, prerenderedAt },
    payload: { data, prerenderedAt }
  };
}

const unheadOptions = {
  disableDefaults: true,
};

function createSSRContext(event) {
  const ssrContext = {
    url: event.path,
    event,
    runtimeConfig: useRuntimeConfig(event),
    noSSR: true,
    head: createHead(unheadOptions),
    error: false,
    nuxt: void 0,
    /* NuxtApp */
    payload: {},
    _payloadReducers: /* @__PURE__ */ Object.create(null),
    modules: /* @__PURE__ */ new Set()
  };
  return ssrContext;
}
function setSSRError(ssrContext, error) {
  ssrContext.error = true;
  ssrContext.payload = { error };
  ssrContext.url = error.url;
}

const renderSSRHeadOptions = {"omitLineBreaks":true};

const entryFileName = "CIZOaD51.js";

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
const relative = function(from, to) {
  const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
  const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
    return _to.join("/");
  }
  const _fromCopy = [..._from];
  for (const segment of _fromCopy) {
    if (_to[0] !== segment) {
      break;
    }
    _from.shift();
    _to.shift();
  }
  return [..._from.map(() => ".."), ..._to].join("/");
};

globalThis.__buildAssetsURL = buildAssetsURL;
globalThis.__publicAssetsURL = publicAssetsURL;
const HAS_APP_TELEPORTS = !!(appTeleportAttrs.id);
const APP_TELEPORT_OPEN_TAG = HAS_APP_TELEPORTS ? `<${appTeleportTag}${propsToString(appTeleportAttrs)}>` : "";
const APP_TELEPORT_CLOSE_TAG = HAS_APP_TELEPORTS ? `</${appTeleportTag}>` : "";
const PAYLOAD_URL_RE = /^[^?]*\/_payload.json(?:\?.*)?$/ ;
let entryPath;
const renderer = defineRenderHandler(async (event) => {
  const nitroApp = useNitroApp();
  const ssrError = event.path.startsWith("/__nuxt_error") ? getQuery(event) : null;
  if (ssrError && !("__unenv__" in event.node.req)) {
    throw createError$1({
      statusCode: 404,
      statusMessage: "Page Not Found: /__nuxt_error"
    });
  }
  const ssrContext = createSSRContext(event);
  const headEntryOptions = { mode: "server" };
  ssrContext.head.push(appHead, headEntryOptions);
  if (ssrError) {
    ssrError.statusCode &&= Number.parseInt(ssrError.statusCode);
    if (typeof ssrError.data === "string") {
      try {
        ssrError.data = destr(ssrError.data);
      } catch {
      }
    }
    setSSRError(ssrContext, ssrError);
  }
  const isRenderingPayload = PAYLOAD_URL_RE.test(ssrContext.url);
  if (isRenderingPayload) {
    const url = ssrContext.url.substring(0, ssrContext.url.lastIndexOf("/")) || "/";
    ssrContext.url = url;
    event._path = event.node.req.url = url;
  }
  const routeOptions = getRouteRules(event);
  if (routeOptions.ssr === false) {
    ssrContext.noSSR = true;
  }
  const renderer = await getRenderer();
  const _rendered = await renderer.renderToString(ssrContext).catch(async (error) => {
    if (ssrContext._renderResponse && error.message === "skipping render") {
      return {};
    }
    const _err = !ssrError && ssrContext.payload?.error || error;
    await ssrContext.nuxt?.hooks.callHook("app:error", _err);
    throw _err;
  });
  const inlinedStyles = [];
  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext, renderResult: _rendered });
  if (ssrContext._renderResponse) {
    return ssrContext._renderResponse;
  }
  if (ssrContext.payload?.error && !ssrError) {
    throw ssrContext.payload.error;
  }
  if (isRenderingPayload) {
    const response = renderPayloadResponse(ssrContext);
    return response;
  }
  const NO_SCRIPTS = routeOptions.noScripts;
  const { styles, scripts } = getRequestDependencies(ssrContext, renderer.rendererContext);
  if (!NO_SCRIPTS) {
    let path = entryPath;
    if (!path) {
      path = buildAssetsURL(entryFileName);
      if (/^(?:\/|\.+\/)/.test(path) || hasProtocol(path, { acceptRelative: true })) {
        entryPath = path;
      } else {
        path = relative(event.path.replace(/\/[^/]+$/, "/"), joinURL("/", path));
        if (!/^(?:\/|\.+\/)/.test(path)) {
          path = `./${path}`;
        }
      }
    }
    ssrContext.head.push({
      script: [{
        tagPosition: "head",
        tagPriority: -2,
        type: "importmap",
        innerHTML: JSON.stringify({ imports: { "#entry": path } })
      }]
    }, headEntryOptions);
  }
  if (ssrContext._preloadManifest && !NO_SCRIPTS) {
    ssrContext.head.push({
      link: [
        { rel: "preload", as: "fetch", fetchpriority: "low", crossorigin: "anonymous", href: buildAssetsURL(`builds/meta/${ssrContext.runtimeConfig.app.buildId}.json`) }
      ]
    }, { ...headEntryOptions, tagPriority: "low" });
  }
  if (inlinedStyles.length) {
    ssrContext.head.push({ style: inlinedStyles });
  }
  const link = [];
  for (const resource of Object.values(styles)) {
    link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: "" });
  }
  if (link.length) {
    ssrContext.head.push({ link }, headEntryOptions);
  }
  if (!NO_SCRIPTS) {
    ssrContext.head.push({
      link: getPreloadLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      link: getPrefetchLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      script: renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) 
    }, {
      ...headEntryOptions,
      // this should come before another end of body scripts
      tagPosition: "bodyClose",
      tagPriority: "high"
    });
  }
  if (!routeOptions.noScripts) {
    const tagPosition = "head";
    ssrContext.head.push({
      script: Object.values(scripts).map((resource) => ({
        type: resource.module ? "module" : null,
        src: renderer.rendererContext.buildAssetsURL(resource.file),
        defer: resource.module ? null : true,
        // if we are rendering script tag payloads that import an async payload
        // we need to ensure this resolves before executing the Nuxt entry
        tagPosition,
        crossorigin: ""
      }))
    }, headEntryOptions);
  }
  const { headTags, bodyTags, bodyTagsOpen, htmlAttrs, bodyAttrs } = await renderSSRHead(ssrContext.head, renderSSRHeadOptions);
  const htmlContext = {
    htmlAttrs: htmlAttrs ? [htmlAttrs] : [],
    head: normalizeChunks([headTags]),
    bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
    bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
    body: [
      _rendered.html,
      APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : "") + APP_TELEPORT_CLOSE_TAG
    ],
    bodyAppend: [bodyTags]
  };
  await nitroApp.hooks.callHook("render:html", htmlContext, { event });
  return {
    body: renderHTMLDocument(htmlContext),
    statusCode: getResponseStatus(event),
    statusMessage: getResponseStatusText(event),
    headers: {
      "content-type": "text/html;charset=utf-8",
      "x-powered-by": "Nuxt"
    }
  };
});
function normalizeChunks(chunks) {
  const result = [];
  for (const _chunk of chunks) {
    const chunk = _chunk?.trim();
    if (chunk) {
      result.push(chunk);
    }
  }
  return result;
}
function joinTags(tags) {
  return tags.join("");
}
function joinAttrs(chunks) {
  if (chunks.length === 0) {
    return "";
  }
  return " " + chunks.join(" ");
}
function renderHTMLDocument(html) {
  return `<!DOCTYPE html><html${joinAttrs(html.htmlAttrs)}><head>${joinTags(html.head)}</head><body${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPrepend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body></html>`;
}

const renderer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: renderer
}, Symbol.toStringTag, { value: 'Module' }));

const client_manifest = {
  "../node_modules/nuxt/dist/app/components/error-404.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "D44FMmxR.js",
    "name": "error-404",
    "src": "../node_modules/nuxt/dist/app/components/error-404.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js",
      "_DlAUqK2U.js"
    ],
    "css": [
      "error-404.DlVPZ4GE.css"
    ]
  },
  "error-404.DlVPZ4GE.css": {
    "file": "error-404.DlVPZ4GE.css",
    "resourceType": "style",
    "prefetch": true,
    "preload": true
  },
  "../node_modules/nuxt/dist/app/components/error-500.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "DViDmhL1.js",
    "name": "error-500",
    "src": "../node_modules/nuxt/dist/app/components/error-500.vue",
    "isDynamicEntry": true,
    "imports": [
      "_DlAUqK2U.js",
      "../node_modules/nuxt/dist/app/entry.js"
    ],
    "css": [
      "error-500.DjyirMQI.css"
    ]
  },
  "error-500.DjyirMQI.css": {
    "file": "error-500.DjyirMQI.css",
    "resourceType": "style",
    "prefetch": true,
    "preload": true
  },
  "../node_modules/nuxt/dist/app/entry.js": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "CIZOaD51.js",
    "name": "entry",
    "src": "../node_modules/nuxt/dist/app/entry.js",
    "isEntry": true,
    "dynamicImports": [
      "middleware/owner-only.ts",
      "../node_modules/nuxt/dist/app/components/error-404.vue",
      "../node_modules/nuxt/dist/app/components/error-500.vue"
    ],
    "css": [
      "entry.CB61oOgG.css"
    ]
  },
  "entry.CB61oOgG.css": {
    "file": "entry.CB61oOgG.css",
    "resourceType": "style",
    "prefetch": true,
    "preload": true
  },
  "_DlAUqK2U.js": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "DlAUqK2U.js",
    "name": "_plugin-vue_export-helper"
  },
  "_rBv2ZT4f.js": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "rBv2ZT4f.js",
    "name": "user",
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "middleware/owner-only.ts": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "DeGDkLWL.js",
    "name": "owner-only",
    "src": "middleware/owner-only.ts",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/activity-log.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "DBBPYEy2.js",
    "name": "activity-log",
    "src": "pages/activity-log.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/audit-logs.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "Cy4syMZu.js",
    "name": "audit-logs",
    "src": "pages/audit-logs.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/index.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "CplxUqJD.js",
    "name": "index",
    "src": "pages/index.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js",
      "_DlAUqK2U.js",
      "_rBv2ZT4f.js"
    ],
    "css": [
      "index.BZvSYlDF.css"
    ]
  },
  "index.BZvSYlDF.css": {
    "file": "index.BZvSYlDF.css",
    "resourceType": "style",
    "prefetch": true,
    "preload": true
  },
  "pages/login.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "DxxrbZzH.js",
    "name": "login",
    "src": "pages/login.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/owner.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "CuWsi1xR.js",
    "name": "owner",
    "src": "pages/owner.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/projects/[slug].vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "CGrvQcgA.js",
    "name": "_slug_",
    "src": "pages/projects/[slug].vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js",
      "_rBv2ZT4f.js",
      "_DlAUqK2U.js"
    ],
    "css": [
      "_slug_.D7hwoZfp.css"
    ]
  },
  "_slug_.D7hwoZfp.css": {
    "file": "_slug_.D7hwoZfp.css",
    "resourceType": "style",
    "prefetch": true,
    "preload": true
  },
  "pages/projects/index.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "CvZjs4CL.js",
    "name": "index",
    "src": "pages/projects/index.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  },
  "pages/time-report.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "Djx30IsV.js",
    "name": "time-report",
    "src": "pages/time-report.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js",
      "_rBv2ZT4f.js"
    ]
  },
  "pages/users.vue": {
    "resourceType": "script",
    "module": true,
    "prefetch": true,
    "preload": true,
    "file": "V47ZrhTL.js",
    "name": "users",
    "src": "pages/users.vue",
    "isDynamicEntry": true,
    "imports": [
      "../node_modules/nuxt/dist/app/entry.js"
    ]
  }
};

const client_manifest$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: client_manifest
}, Symbol.toStringTag, { value: 'Module' }));

const template = "";

const _virtual__spaTemplate = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template
}, Symbol.toStringTag, { value: 'Module' }));

export { listener as default };
//# sourceMappingURL=index.mjs.map
